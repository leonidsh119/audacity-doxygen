<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.11">
  <compounddef id="todo" kind="page">
    <compoundname>todo</compoundname>
    <title>Todo List</title>
    <detaileddescription>
<para><variablelist>
<varlistentry><term><anchor id="todo_1_todo000043"/>Class <ref refid="class_audio_i_o" kindref="compound">AudioIO</ref>  </term></varlistentry>
<listitem><para>run through all functions called from audio and portaudio threads to verify they are thread-safe. Note that synchronization of the style: &quot;A sets flag to signal B, B clears flag to acknowledge completion&quot; is not thread safe in a general multiple-CPU context. For example, B can write to a buffer and set a completion flag. The flag write can occur before the buffer write due to out-of-order execution. Then A can see the flag and read the buffer before buffer writes complete. </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000044"/>Member <ref refid="class_audio_i_o_1a71facd3c7274394b70eaff652e1bc97e" kindref="member">AudioIO::GetOptimalSupportedSampleRate</ref>  ()</term></varlistentry>
<listitem><para>: should this take into account PortAudio&apos;s value for <ref refid="struct_pa_device_info_1a68f435353bfe1a4c9b632203a9afcacb" kindref="member">PaDeviceInfo::defaultSampleRate</ref>? In principal this should let us work out which rates are &quot;real&quot; and which resampled in the drivers, and so prefer the real rates.  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000045"/>Member <ref refid="class_audio_i_o_1aef42a8e615a55e2b914a989e8b63af0b" kindref="member">AudioIO::HandleDeviceChange</ref>  ()</term></varlistentry>
<listitem><para>: Make this do a sample rate query and store the result in the <ref refid="class_audio_i_o" kindref="compound">AudioIO</ref> object to avoid doing it later? Would simplify the GetSupported*Rate functions considerably  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000005"/>Member <ref refid="samplefmt_8h_1a4db4c77f928d32c7d8854732f50b8c04" kindref="member">av_samples_alloc</ref>  (uint8_t **audio_data, int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)</term></varlistentry>
<listitem><para>return the size of the allocated buffer in case of success at the next bump  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000004"/>Member <ref refid="samplefmt_8h_1a673254a62fa75dab3211caf17c73c6eb" kindref="member">av_samples_fill_arrays</ref>  (uint8_t **audio_data, int *linesize, const uint8_t *buf, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)</term></varlistentry>
<listitem><para>return minimum size in bytes required for the buffer in case of success at the next bump  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000001"/>Member <ref refid="group__lavc__misc_1ga66b44aad56fa22a78fb8916eb8cc0516" kindref="member">avcodec_fill_audio_frame</ref>  (<ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> *frame, int nb_channels, enum AVSampleFormat sample_fmt, const uint8_t *buf, int buf_size, int align)</term></varlistentry>
<listitem><para>return the size in bytes required to store the samples in case of success, at the next libavutil bump  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000002"/>Member <ref refid="group__lavf__decoding_1gad42172e27cddafb81096939783b157bb" kindref="member">avformat_find_stream_info</ref>  (<ref refid="struct_a_v_format_context" kindref="compound">AVFormatContext</ref> *ic, AVDictionary **options)</term></varlistentry>
<listitem><para>Let the user decide somehow what information is needed so that we do not waste time getting stuff the user does not need.  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000003"/>Member <ref refid="struct_a_v_option_1a6c72d22b8c599e89abba088b85dfcd8a" kindref="member">AVOption::help</ref>  </term></varlistentry>
<listitem><para>What about other languages?  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000062"/>Member <ref refid="class_expanding_tool_bar_1ad1dc9d80b11f61df0f9761c55d5aa33d" kindref="member">ExpandingToolBar::ExpandingToolBar</ref>  (wxWindow *parent, wxWindowID id, const wxPoint &amp;pos=wxDefaultPosition, const wxSize &amp;size=wxDefaultSize)</term></varlistentry>
<listitem><para>check whether this is a memory leak (and check similar code)  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000046"/>Member <ref refid="class_file_names_1a703e46fe9ac21e11b497d08f3856400c" kindref="member">FileNames::TempDir</ref>  ()</term></varlistentry>
<listitem><para>put a counter in here to see if it gets used a lot. if it does, then maybe we should cache the path name each time.  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000051"/>Member <ref refid="_track_artist_8h_1a00fc87b63f1436536d3090852d57f810" kindref="member">GetWaveYPos</ref>  (float value, float min, float max, int height, bool dB, bool outer, float dBr, bool clip)</term></varlistentry>
<listitem><para>Should this function move int GuiWaveTrack where it can then use the zoomMin, zoomMax and height values without having to have them passed in to it??  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000015"/>Member <ref refid="pa__front_8c_1a92f56f88cbd14da0e8e03077e835d104" kindref="member">Pa_CloseStream</ref>  (PaStream *stream)</term></varlistentry>
<listitem><para>REVIEW: shouldn&apos;t we close anyway? see: <ulink url="http://www.portaudio.com/trac/ticket/115">http://www.portaudio.com/trac/ticket/115</ulink>  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000007"/>File <ref refid="pa__converters_8c" kindref="compound">pa_converters.c</ref>  </term></varlistentry>
<listitem><para>Consider whether functions which dither but don&apos;t clip should exist, V18 automatically enabled clipping whenever dithering was selected. Perhaps we should do the same. see: &quot;require clipping for dithering sample conversion functions?&quot; <ulink url="http://www.portaudio.com/trac/ticket/112">http://www.portaudio.com/trac/ticket/112</ulink></para><para>implement the converters marked IMPLEMENT ME: Int32_To_Int24_Dither, Int32_To_UInt8_Dither, Int24_To_Int16_Dither, Int24_To_Int8_Dither, Int24_To_UInt8_Dither, Int16_To_Int8_Dither, Int16_To_UInt8_Dither see: &quot;some conversion functions are not implemented in pa_converters.c&quot; <ulink url="http://www.portaudio.com/trac/ticket/35">http://www.portaudio.com/trac/ticket/35</ulink></para><para>review the converters marked REVIEW: Float32_To_Int32, Float32_To_Int32_Dither, Float32_To_Int32_Clip, Float32_To_Int32_DitherClip, Int32_To_Int16_Dither, Int32_To_Int8_Dither, Int16_To_Int32  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000010"/>File <ref refid="pa__cpuload_8c" kindref="compound">pa_cpuload.c</ref>  </term></varlistentry>
<listitem><para>Dynamically calculate the coefficients used to smooth the CPU Load Measurements over time to provide a uniform characterisation of CPU Load independent of rate at which PaUtil_BeginCpuLoadMeasurement / PaUtil_EndCpuLoadMeasurement are called. see <ulink url="http://www.portaudio.com/trac/ticket/113">http://www.portaudio.com/trac/ticket/113</ulink>  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000013"/>Member <ref refid="pa__front_8c_1ae606855a611cf29c7d2d7421df5e3b5d" kindref="member">Pa_GetErrorText</ref>  (PaError errorCode)</term></varlistentry>
<listitem><para>could catenate the last host error text to result in the case of paUnanticipatedHostError. see: <ulink url="http://www.portaudio.com/trac/ticket/114">http://www.portaudio.com/trac/ticket/114</ulink>  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000042"/>File <ref refid="patest__toomanysines_8c" kindref="compound">patest_toomanysines.c</ref>  </term></varlistentry>
<listitem><para>This may not be needed now that we have &quot;patest_out_overflow.c&quot;.  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000011"/>Member <ref refid="pa__cpuload_8h_1a8c29cc1cf3b6fd9bf18a2c3fc9f0ef2a" kindref="member">PaUtil_EndCpuLoadMeasurement</ref>  (<ref refid="struct_pa_util_cpu_load_measurer" kindref="compound">PaUtilCpuLoadMeasurer</ref> *measurer, unsigned long framesProcessed)</term></varlistentry>
<listitem><para>these coefficients shouldn&apos;t be hardwired see: <ulink url="http://www.portaudio.com/trac/ticket/113">http://www.portaudio.com/trac/ticket/113</ulink>  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000027"/>Member <ref refid="pa__win__wmme_8c_1af8f8a8ef4c1f1a39686109801807a4ee" kindref="member">ProcessingThreadProc</ref>  (void *pArg)</term></varlistentry>
<listitem><para>support paInputUnderflow, paOutputOverflow and paNeverDropInput </para><para>FIXME/REVIEW: can&apos;t return host error info from an asyncronous thread. see <ulink url="http://www.portaudio.com/trac/ticket/143">http://www.portaudio.com/trac/ticket/143</ulink> </para><para>if all of the other buffers are also ready then we discard all but the most recent. This is an input buffer overflow. FIXME: these buffers should be passed to the callback in a paNeverDropInput stream. <ulink url="http://www.portaudio.com/trac/ticket/142">http://www.portaudio.com/trac/ticket/142</ulink></para><para>implement inputBufferAdcTime </para><para>FIXME: should probably reset the output device immediately once the callback returns paAbort see: <ulink url="http://www.portaudio.com/trac/ticket/141">http://www.portaudio.com/trac/ticket/141</ulink> </para><para>need to handle PaNeverDropInput here where necessary  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000040"/>Member <ref refid="pa__mac__core__internal_8h_1a3aa8874a48f232c61d4101706df2b269" kindref="member">ReadStream</ref>  (PaStream *stream, void *buffer, unsigned long frames)</term></varlistentry>
<listitem><para>REVIEW: consider what to do if the input overflows. do we requeue all of the buffers? should we be running a thread to make sure they are always queued? see: <ulink url="http://www.portaudio.com/trac/ticket/117">http://www.portaudio.com/trac/ticket/117</ulink>  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000048"/>Member <ref refid="class_shuttle_1ab9d16128c80cdb3c494b0830127a6936" kindref="member">Shuttle::TransferLongLong</ref>  (const wxString &amp;Name, wxLongLong_t &amp;iValue, const wxLongLong_t &amp;iDefault)</term></varlistentry>
<listitem><para>Fix for long long values.  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000049"/>Member <ref refid="class_shuttle_gui_base_1a7f7670bb731cda2f9c1da83640ba2e2d" kindref="member">ShuttleGuiBase::AddRadioButton</ref>  (const wxString &amp;Prompt)</term></varlistentry>
<listitem><para>This function and the next one, suitably adapted, could be used by TieRadioButton.  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000050"/>Member <ref refid="class_theme_base_1abb088440b44d8fa1274094c8e8e9096c" kindref="member">ThemeBase::ReadImageCache</ref>  (bool bBinaryRead=true, bool bOkIfNotFound=false)</term></varlistentry>
<listitem><para>revisit this hack which makes adding NEW colours easier but which prevents a colour of (1,1,1) from being added. find an alternative way to make adding NEW colours easier. e.g. initialise the background to translucent, perhaps.  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000052"/>File <ref refid="_track_panel_8cpp" kindref="compound">TrackPanel.cpp</ref>  </term></varlistentry>
<listitem><para>Refactoring of the <ref refid="class_track_panel" kindref="compound">TrackPanel</ref>, possibly as described in <ref refid="TrackPanelRefactor" kindref="compound">Track Panel Refactor</ref> </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000053"/>Member <ref refid="class_track_panel_1a81709530372aa825194618eca5e6b6c2" kindref="member">TrackPanel::DoZoomInOut</ref>  (wxMouseEvent &amp;event, int x)</term></varlistentry>
<listitem><para>MAGIC NUMBER: We&apos;ve got several in this method.  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000056"/>Member <ref refid="class_track_panel_1a984cfefe6eb6bcc49b44d1b2346ef166" kindref="member">TrackPanel::HandleGlyphDragRelease</ref>  (<ref refid="class_label_track" kindref="compound">LabelTrack</ref> *lTrack, wxMouseEvent &amp;event)</term></varlistentry>
<listitem><para>This method is one of a large number of methods in <ref refid="class_track_panel" kindref="compound">TrackPanel</ref> which suitably modified belong in other classes.  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000055"/>Member <ref refid="class_track_panel_1aa9dd18c1cdb37737045a87617db85323" kindref="member">TrackPanel::HandleLabelTrackClick</ref>  (<ref refid="class_label_track" kindref="compound">LabelTrack</ref> *lTrack, wxRect &amp;rect, wxMouseEvent &amp;event)</term></varlistentry>
<listitem><para>This method is one of a large number of methods in <ref refid="class_track_panel" kindref="compound">TrackPanel</ref> which suitably modified belong in other classes.  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000054"/>Member <ref refid="class_track_panel_1a701733b821a60732c8c4d66676b8b5b1" kindref="member">TrackPanel::HandleSampleEditingClick</ref>  (wxMouseEvent &amp;event)</term></varlistentry>
<listitem><para>Should mCapturedTrack take the place of mDrawingTrack??  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000057"/>Member <ref refid="class_track_panel_1a39f65a04ecb950f794590d58261ab133" kindref="member">TrackPanel::HandleTextDragRelease</ref>  (<ref refid="class_label_track" kindref="compound">LabelTrack</ref> *lTrack, wxMouseEvent &amp;event)</term></varlistentry>
<listitem><para>This method is one of a large number of methods in <ref refid="class_track_panel" kindref="compound">TrackPanel</ref> which suitably modified belong in other classes.  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000058"/>Member <ref refid="class_track_panel_1a47315148ac50d0e24e7d88148973c8c4" kindref="member">TrackPanel::OnPrevTrack</ref>  (bool shift=false)</term></varlistentry>
<listitem><para>Merge related methods, <ref refid="class_track_panel_1a47315148ac50d0e24e7d88148973c8c4" kindref="member">TrackPanel::OnPrevTrack</ref> and <ref refid="class_track_panel_1ae6a78ddc3629f49a13437566200a4f95" kindref="member">TrackPanel::OnNextTrack</ref>.  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000059"/>Member <ref refid="class_track_panel_1a3b538964a9818c509d22f76d14629981" kindref="member">TrackPanel::OnRateOther</ref>  (wxCommandEvent &amp;event)</term></varlistentry>
<listitem><para>Remove artificial constants!! </para><para>Make a real dialog box out of this!!  </para></listitem>
<varlistentry><term><anchor id="todo_1_todo000041"/>Member <ref refid="pa__mac__core__internal_8h_1a3520d8a8ca48a25c9b99708f6033811d" kindref="member">WriteStream</ref>  (PaStream *stream, const void *buffer, unsigned long frames)</term></varlistentry>
<listitem><para>REVIEW: consider what to do if the output underflows. do we requeue all the existing buffers with zeros? should we run a separate thread to keep the buffers enqueued at all times? see: <ulink url="http://www.portaudio.com/trac/ticket/117">http://www.portaudio.com/trac/ticket/117</ulink> </para></listitem>
</variablelist>
</para>    </detaileddescription>
  </compounddef>
</doxygen>
