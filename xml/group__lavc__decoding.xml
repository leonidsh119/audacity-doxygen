<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.11">
  <compounddef id="group__lavc__decoding" kind="group">
    <compoundname>lavc_decoding</compoundname>
    <title>Decoding</title>
    <innergroup refid="group__lavc__parsing">Frame parsing</innergroup>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="group__lavc__decoding_1ga352363bce7d3ed82c101b3bc001d1c16" prot="public" static="no">
        <name>AVDiscard</name>
        <enumvalue id="group__lavc__decoding_1gga352363bce7d3ed82c101b3bc001d1c16a93d0436f7651b58debe3f995e2582dcd" prot="public">
          <name>AVDISCARD_NONE</name>
          <initializer>=-16</initializer>
          <briefdescription>
<para>discard nothing </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lavc__decoding_1gga352363bce7d3ed82c101b3bc001d1c16a81453d8c452e8ee794daf7fde1c80b5b" prot="public">
          <name>AVDISCARD_DEFAULT</name>
          <initializer>=  0</initializer>
          <briefdescription>
<para>discard useless packets like 0 size packets in avi </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lavc__decoding_1gga352363bce7d3ed82c101b3bc001d1c16ac5a5a87ffcd6fb2362ac18449d29bde8" prot="public">
          <name>AVDISCARD_NONREF</name>
          <initializer>=  8</initializer>
          <briefdescription>
<para>discard all non reference </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lavc__decoding_1gga352363bce7d3ed82c101b3bc001d1c16a776541ad00a4f13c3fdcd363988bffb3" prot="public">
          <name>AVDISCARD_BIDIR</name>
          <initializer>= 16</initializer>
          <briefdescription>
<para>discard all bidirectional frames </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lavc__decoding_1gga352363bce7d3ed82c101b3bc001d1c16a31c8164477d9f571f82003065d2ab6f1" prot="public">
          <name>AVDISCARD_NONKEY</name>
          <initializer>= 32</initializer>
          <briefdescription>
<para>discard all frames except keyframes </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lavc__decoding_1gga352363bce7d3ed82c101b3bc001d1c16a07517e3890ba7e19a612945483dc066a" prot="public">
          <name>AVDISCARD_ALL</name>
          <initializer>= 48</initializer>
          <briefdescription>
<para>discard all </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="621" column="1" bodyfile="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" bodystart="621" bodyend="630"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__lavc__decoding_1ga19a0ca553277f019dd5b0fec6e1f9dca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_a_v_codec" kindref="compound">AVCodec</ref> *</type>
        <definition>AVCodec* avcodec_find_decoder</definition>
        <argsstring>(enum AVCodecID id)</argsstring>
        <name>avcodec_find_decoder</name>
        <param>
          <type>enum <ref refid="group__lavc__core_1gaadca229ad2c20e060a14fec08a5cc7ce" kindref="member">AVCodecID</ref></type>
          <declname>id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Find a registered decoder with a matching codec ID.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>AVCodecID of the requested decoder </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A decoder if one was found, NULL otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="3733" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavc__decoding_1ga776f2359007e8457799503068419e791" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_a_v_codec" kindref="compound">AVCodec</ref> *</type>
        <definition>AVCodec* avcodec_find_decoder_by_name</definition>
        <argsstring>(const char *name)</argsstring>
        <name>avcodec_find_decoder_by_name</name>
        <param>
          <type><ref refid="getopt1_8c_1a2c212835823e3c54a8ab6d95c652660e" kindref="member">const</ref> char *</type>
          <declname>name</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Find a registered decoder with the specified name.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>name of the requested decoder </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A decoder if one was found, NULL otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="3741" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavc__decoding_1ga666e4cc55f8a14c3b1ea66aaef2f6970" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="attributes_8h_1aa6d076561d3a9eea4729ee632652de02" kindref="member">attribute_deprecated</ref> <ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
        <definition>attribute_deprecated int avcodec_default_get_buffer</definition>
        <argsstring>(AVCodecContext *s, AVFrame *pic)</argsstring>
        <name>avcodec_default_get_buffer</name>
        <param>
          <type><ref refid="struct_a_v_codec_context" kindref="compound">AVCodecContext</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type><ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> *</type>
          <declname>pic</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="3744" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavc__decoding_1ga4544e55d2417bfe6e746dcaf2195dde0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="attributes_8h_1aa6d076561d3a9eea4729ee632652de02" kindref="member">attribute_deprecated</ref> <ref refid="sound_8c_1ae35f5844602719cf66324f4de2a658b3" kindref="member">void</ref></type>
        <definition>attribute_deprecated void avcodec_default_release_buffer</definition>
        <argsstring>(AVCodecContext *s, AVFrame *pic)</argsstring>
        <name>avcodec_default_release_buffer</name>
        <param>
          <type><ref refid="struct_a_v_codec_context" kindref="compound">AVCodecContext</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type><ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> *</type>
          <declname>pic</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="3745" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavc__decoding_1ga3f7158d88758be42cc1ab6b9e6df9f0d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="attributes_8h_1aa6d076561d3a9eea4729ee632652de02" kindref="member">attribute_deprecated</ref> <ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
        <definition>attribute_deprecated int avcodec_default_reget_buffer</definition>
        <argsstring>(AVCodecContext *s, AVFrame *pic)</argsstring>
        <name>avcodec_default_reget_buffer</name>
        <param>
          <type><ref refid="struct_a_v_codec_context" kindref="compound">AVCodecContext</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type><ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> *</type>
          <declname>pic</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="3746" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavc__decoding_1ga09dee227d3666720eff1f6913d11699d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
        <definition>int avcodec_default_get_buffer2</definition>
        <argsstring>(AVCodecContext *s, AVFrame *frame, int flags)</argsstring>
        <name>avcodec_default_get_buffer2</name>
        <param>
          <type><ref refid="struct_a_v_codec_context" kindref="compound">AVCodecContext</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type><ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> *</type>
          <declname>frame</declname>
        </param>
        <param>
          <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
          <declname>flags</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The default callback for <ref refid="struct_a_v_codec_context_1aef79333a4c6abf1628c55d75ec82bede" kindref="member">AVCodecContext.get_buffer2()</ref>. It is made public so it can be called by custom get_buffer2() implementations for decoders without CODEC_CAP_DR1 set. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="3754" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavc__decoding_1gaad92aaeee369795273fc6cfc6ef3b189" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="attributes_8h_1aa6d076561d3a9eea4729ee632652de02" kindref="member">attribute_deprecated</ref> unsigned</type>
        <definition>attribute_deprecated unsigned avcodec_get_edge_width</definition>
        <argsstring>(void)</argsstring>
        <name>avcodec_get_edge_width</name>
        <param>
          <type><ref refid="sound_8c_1ae35f5844602719cf66324f4de2a658b3" kindref="member">void</ref></type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return the amount of padding in pixels which the get_buffer callback must provide around the edge of the image for codecs which do not have the CODEC_FLAG_EMU_EDGE flag.</para><para><simplesect kind="return"><para>Required padding in pixels.</para></simplesect>
<xrefsect id="deprecated_1_deprecated000005"><xreftitle>Deprecated</xreftitle><xrefdescription><para>CODEC_FLAG_EMU_EDGE is deprecated, so this function is no longer needed </para></xrefdescription></xrefsect></para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="3768" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavc__decoding_1ga48432a3760eec9fce0f0ef7b298859f1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="sound_8c_1ae35f5844602719cf66324f4de2a658b3" kindref="member">void</ref></type>
        <definition>void avcodec_align_dimensions</definition>
        <argsstring>(AVCodecContext *s, int *width, int *height)</argsstring>
        <name>avcodec_align_dimensions</name>
        <param>
          <type><ref refid="struct_a_v_codec_context" kindref="compound">AVCodecContext</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref> *</type>
          <declname>width</declname>
        </param>
        <param>
          <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref> *</type>
          <declname>height</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Modify width and height values so that they will result in a memory buffer that is acceptable for the codec if you do not use any horizontal padding.</para><para>May only be used if a codec with CODEC_CAP_DR1 has been opened. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="3778" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavc__decoding_1ga34e3269dc1b9e2c98e9371241722e7e2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="sound_8c_1ae35f5844602719cf66324f4de2a658b3" kindref="member">void</ref></type>
        <definition>void avcodec_align_dimensions2</definition>
        <argsstring>(AVCodecContext *s, int *width, int *height, int linesize_align[AV_NUM_DATA_POINTERS])</argsstring>
        <name>avcodec_align_dimensions2</name>
        <param>
          <type><ref refid="struct_a_v_codec_context" kindref="compound">AVCodecContext</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref> *</type>
          <declname>width</declname>
        </param>
        <param>
          <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref> *</type>
          <declname>height</declname>
        </param>
        <param>
          <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
          <declname>linesize_align</declname>
          <array>[AV_NUM_DATA_POINTERS]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Modify width and height values so that they will result in a memory buffer that is acceptable for the codec if you also ensure that all line sizes are a multiple of the respective linesize_align[i].</para><para>May only be used if a codec with CODEC_CAP_DR1 has been opened. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="3787" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavc__decoding_1ga29744651709d05d125982e6ca20fcd95" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
        <definition>int avcodec_enum_to_chroma_pos</definition>
        <argsstring>(int *xpos, int *ypos, enum AVChromaLocation pos)</argsstring>
        <name>avcodec_enum_to_chroma_pos</name>
        <param>
          <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref> *</type>
          <declname>xpos</declname>
        </param>
        <param>
          <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref> *</type>
          <declname>ypos</declname>
        </param>
        <param>
          <type>enum <ref refid="group__lavc__core_1ga1f86ed1b6a420faccacf77c98db6c1ff" kindref="member">AVChromaLocation</ref></type>
          <declname>pos</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Converts AVChromaLocation to swscale x/y chroma position.</para><para>The positions represent the chroma (0,0) position in a coordinates system with luma (0,0) representing the origin and luma(1,1) representing 256,256</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>xpos</parametername>
</parameternamelist>
<parameterdescription>
<para>horizontal chroma sample position </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ypos</parametername>
</parameternamelist>
<parameterdescription>
<para>vertical chroma sample position </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="3799" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavc__decoding_1ga30c6c7e3af6c589814d5135561b69980" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>enum <ref refid="group__lavc__core_1ga1f86ed1b6a420faccacf77c98db6c1ff" kindref="member">AVChromaLocation</ref></type>
        <definition>enum AVChromaLocation avcodec_chroma_pos_to_enum</definition>
        <argsstring>(int xpos, int ypos)</argsstring>
        <name>avcodec_chroma_pos_to_enum</name>
        <param>
          <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
          <declname>xpos</declname>
        </param>
        <param>
          <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
          <declname>ypos</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Converts swscale x/y chroma position to AVChromaLocation.</para><para>The positions represent the chroma (0,0) position in a coordinates system with luma (0,0) representing the origin and luma(1,1) representing 256,256</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>xpos</parametername>
</parameternamelist>
<parameterdescription>
<para>horizontal chroma sample position </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ypos</parametername>
</parameternamelist>
<parameterdescription>
<para>vertical chroma sample position </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="3799" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavc__decoding_1gac552241713bbc0eae2206a75d211daf4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="attributes_8h_1aa6d076561d3a9eea4729ee632652de02" kindref="member">attribute_deprecated</ref> <ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
        <definition>attribute_deprecated int avcodec_decode_audio3</definition>
        <argsstring>(AVCodecContext *avctx, int16_t *samples, int *frame_size_ptr, AVPacket *avpkt)</argsstring>
        <name>avcodec_decode_audio3</name>
        <param>
          <type><ref refid="struct_a_v_codec_context" kindref="compound">AVCodecContext</ref> *</type>
          <declname>avctx</declname>
        </param>
        <param>
          <type><ref refid="lib-src_2ffmpeg_2win32_2stdint_8h_1a044293bfeff56852a28ed6c2cfbb2649" kindref="member">int16_t</ref> *</type>
          <declname>samples</declname>
        </param>
        <param>
          <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref> *</type>
          <declname>frame_size_ptr</declname>
        </param>
        <param>
          <type><ref refid="struct_a_v_packet" kindref="compound">AVPacket</ref> *</type>
          <declname>avpkt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Wrapper function which calls avcodec_decode_audio4.</para><para><xrefsect id="deprecated_1_deprecated000006"><xreftitle>Deprecated</xreftitle><xrefdescription><para>Use avcodec_decode_audio4 instead.</para></xrefdescription></xrefsect></para><para>Decode the audio frame of size avpkt-&gt;size from avpkt-&gt;data into samples. Some decoders may support multiple frames in a single <ref refid="struct_a_v_packet" kindref="compound">AVPacket</ref>, such decoders would then just decode the first frame. In this case, avcodec_decode_audio3 has to be called again with an <ref refid="struct_a_v_packet" kindref="compound">AVPacket</ref> that contains the remaining data in order to decode the second frame etc. If no frame could be outputted, frame_size_ptr is zero. Otherwise, it is the decompressed frame size in bytes.</para><para><simplesect kind="warning"><para>You must set frame_size_ptr to the allocated size of the output buffer before calling <ref refid="group__lavc__decoding_1gac552241713bbc0eae2206a75d211daf4" kindref="member">avcodec_decode_audio3()</ref>.</para></simplesect>
<simplesect kind="warning"><para>The input buffer must be FF_INPUT_BUFFER_PADDING_SIZE larger than the actual read bytes because some optimized bitstream readers read 32 or 64 bits at once and could read over the end.</para></simplesect>
<simplesect kind="warning"><para>The end of the input buffer avpkt-&gt;data should be set to 0 to ensure that no overreading happens for damaged MPEG streams.</para></simplesect>
<simplesect kind="warning"><para>You must not provide a custom get_buffer() when using <ref refid="group__lavc__decoding_1gac552241713bbc0eae2206a75d211daf4" kindref="member">avcodec_decode_audio3()</ref>. Doing so will override it with avcodec_default_get_buffer. Use <ref refid="group__lavc__decoding_1ga834bb1b062fbcc2de4cf7fb93f154a3e" kindref="member">avcodec_decode_audio4()</ref> instead, which does allow the application to provide a custom get_buffer().</para></simplesect>
<simplesect kind="note"><para>You might have to align the input buffer avpkt-&gt;data and output buffer samples. The alignment requirements depend on the CPU: On some CPUs it isn&apos;t necessary at all, on others it won&apos;t work at all if not aligned and on others it will work but it will have an impact on performance.</para></simplesect>
In practice, avpkt-&gt;data should have 4 byte alignment at minimum and samples should be 16 byte aligned unless the CPU doesn&apos;t need it (AltiVec and SSE do).</para><para><simplesect kind="note"><para>Codecs which have the CODEC_CAP_DELAY capability set have a delay between input and output, these need to be fed with avpkt-&gt;data=NULL, avpkt-&gt;size=0 at the end to return the remaining frames.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>avctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the codec context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">samples</parametername>
</parameternamelist>
<parameterdescription>
<para>the output buffer, sample type in avctx-&gt;sample_fmt If the sample format is planar, each channel plane will be the same size, with no padding between channels. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">frame_size_ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>the output buffer size in bytes </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">avpkt</parametername>
</parameternamelist>
<parameterdescription>
<para>The input <ref refid="struct_a_v_packet" kindref="compound">AVPacket</ref> containing the input buffer. You can create such packet with <ref refid="group__lavc__packet_1gac9cb9756175b96e7441575803757fb73" kindref="member">av_init_packet()</ref> and by then setting data and size, some decoders might in addition need other fields. All decoders are designed to use the least fields possible though. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>On error a negative value is returned, otherwise the number of bytes used or zero if no frame data was decompressed (used) from the input <ref refid="struct_a_v_packet" kindref="compound">AVPacket</ref>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="3867" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavc__decoding_1ga834bb1b062fbcc2de4cf7fb93f154a3e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
        <definition>int avcodec_decode_audio4</definition>
        <argsstring>(AVCodecContext *avctx, AVFrame *frame, int *got_frame_ptr, const AVPacket *avpkt)</argsstring>
        <name>avcodec_decode_audio4</name>
        <param>
          <type><ref refid="struct_a_v_codec_context" kindref="compound">AVCodecContext</ref> *</type>
          <declname>avctx</declname>
        </param>
        <param>
          <type><ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> *</type>
          <declname>frame</declname>
        </param>
        <param>
          <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref> *</type>
          <declname>got_frame_ptr</declname>
        </param>
        <param>
          <type><ref refid="getopt1_8c_1a2c212835823e3c54a8ab6d95c652660e" kindref="member">const</ref> <ref refid="struct_a_v_packet" kindref="compound">AVPacket</ref> *</type>
          <declname>avpkt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Decode the audio frame of size avpkt-&gt;size from avpkt-&gt;data into frame.</para><para>Some decoders may support multiple frames in a single <ref refid="struct_a_v_packet" kindref="compound">AVPacket</ref>. Such decoders would then just decode the first frame and the return value would be less than the packet size. In this case, avcodec_decode_audio4 has to be called again with an <ref refid="struct_a_v_packet" kindref="compound">AVPacket</ref> containing the remaining data in order to decode the second frame, etc... Even if no frames are returned, the packet needs to be fed to the decoder with remaining data until it is completely consumed or an error occurs.</para><para>Some decoders (those marked with CODEC_CAP_DELAY) have a delay between input and output. This means that for some packets they will not immediately produce decoded output and need to be flushed at the end of decoding to get all the decoded data. Flushing is done by calling this function with packets with avpkt-&gt;data set to NULL and avpkt-&gt;size set to 0 until it stops returning samples. It is safe to flush even those decoders that are not marked with CODEC_CAP_DELAY, then no samples will be returned.</para><para><simplesect kind="warning"><para>The input buffer, avpkt-&gt;data must be FF_INPUT_BUFFER_PADDING_SIZE larger than the actual read bytes because some optimized bitstream readers read 32 or 64 bits at once and could read over the end.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>avctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the codec context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">frame</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> in which to store decoded audio samples. The decoder will allocate a buffer for the decoded frame by calling the <ref refid="struct_a_v_codec_context_1aef79333a4c6abf1628c55d75ec82bede" kindref="member">AVCodecContext.get_buffer2()</ref> callback. When <ref refid="struct_a_v_codec_context_1ab16d1e0c729a7b63d918d5ec027ba064" kindref="member">AVCodecContext.refcounted_frames</ref> is set to 1, the frame is reference counted and the returned reference belongs to the caller. The caller must release the frame using <ref refid="group__lavu__frame_1ga0a2b687f9c1c5ed0089b01fd61227108" kindref="member">av_frame_unref()</ref> when the frame is no longer needed. The caller may safely write to the frame if <ref refid="group__lavu__frame_1ga3ba755bada5c3c8883361ef43fb5fb7a" kindref="member">av_frame_is_writable()</ref> returns 1. When <ref refid="struct_a_v_codec_context_1ab16d1e0c729a7b63d918d5ec027ba064" kindref="member">AVCodecContext.refcounted_frames</ref> is set to 0, the returned reference belongs to the decoder and is valid only until the next call to this function or until closing or flushing the decoder. The caller may not write to it. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">got_frame_ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Zero if no frame could be decoded, otherwise it is non-zero. Note that this field being set to zero does not mean that an error has occurred. For decoders with CODEC_CAP_DELAY set, no given decode call is guaranteed to produce a frame. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">avpkt</parametername>
</parameternamelist>
<parameterdescription>
<para>The input <ref refid="struct_a_v_packet" kindref="compound">AVPacket</ref> containing the input buffer. At least avpkt-&gt;data and avpkt-&gt;size should be set. Some decoders might also require additional fields to be set. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A negative error code is returned if an error occurred during decoding, otherwise the number of bytes consumed from the input <ref refid="struct_a_v_packet" kindref="compound">AVPacket</ref> is returned. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="3920" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavc__decoding_1ga99ee61b6dcffb7817a275d39da58cc74" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
        <definition>int avcodec_decode_video2</definition>
        <argsstring>(AVCodecContext *avctx, AVFrame *picture, int *got_picture_ptr, const AVPacket *avpkt)</argsstring>
        <name>avcodec_decode_video2</name>
        <param>
          <type><ref refid="struct_a_v_codec_context" kindref="compound">AVCodecContext</ref> *</type>
          <declname>avctx</declname>
        </param>
        <param>
          <type><ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> *</type>
          <declname>picture</declname>
        </param>
        <param>
          <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref> *</type>
          <declname>got_picture_ptr</declname>
        </param>
        <param>
          <type><ref refid="getopt1_8c_1a2c212835823e3c54a8ab6d95c652660e" kindref="member">const</ref> <ref refid="struct_a_v_packet" kindref="compound">AVPacket</ref> *</type>
          <declname>avpkt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Decode the video frame of size avpkt-&gt;size from avpkt-&gt;data into picture. Some decoders may support multiple frames in a single <ref refid="struct_a_v_packet" kindref="compound">AVPacket</ref>, such decoders would then just decode the first frame.</para><para><simplesect kind="warning"><para>The input buffer must be FF_INPUT_BUFFER_PADDING_SIZE larger than the actual read bytes because some optimized bitstream readers read 32 or 64 bits at once and could read over the end.</para></simplesect>
<simplesect kind="warning"><para>The end of the input buffer buf should be set to 0 to ensure that no overreading happens for damaged MPEG streams.</para></simplesect>
<simplesect kind="note"><para>Codecs which have the CODEC_CAP_DELAY capability set have a delay between input and output, these need to be fed with avpkt-&gt;data=NULL, avpkt-&gt;size=0 at the end to return the remaining frames.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>avctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the codec context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">picture</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> in which the decoded video frame will be stored. Use <ref refid="group__lavu__frame_1gac700017c5270c79c1e1befdeeb008b2f" kindref="member">av_frame_alloc()</ref> to get an <ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref>. The codec will allocate memory for the actual bitmap by calling the <ref refid="struct_a_v_codec_context_1aef79333a4c6abf1628c55d75ec82bede" kindref="member">AVCodecContext.get_buffer2()</ref> callback. When <ref refid="struct_a_v_codec_context_1ab16d1e0c729a7b63d918d5ec027ba064" kindref="member">AVCodecContext.refcounted_frames</ref> is set to 1, the frame is reference counted and the returned reference belongs to the caller. The caller must release the frame using <ref refid="group__lavu__frame_1ga0a2b687f9c1c5ed0089b01fd61227108" kindref="member">av_frame_unref()</ref> when the frame is no longer needed. The caller may safely write to the frame if <ref refid="group__lavu__frame_1ga3ba755bada5c3c8883361ef43fb5fb7a" kindref="member">av_frame_is_writable()</ref> returns 1. When <ref refid="struct_a_v_codec_context_1ab16d1e0c729a7b63d918d5ec027ba064" kindref="member">AVCodecContext.refcounted_frames</ref> is set to 0, the returned reference belongs to the decoder and is valid only until the next call to this function or until closing or flushing the decoder. The caller may not write to it.</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">avpkt</parametername>
</parameternamelist>
<parameterdescription>
<para>The input <ref refid="struct_a_v_packet" kindref="compound">AVPacket</ref> containing the input buffer. You can create such packet with <ref refid="group__lavc__packet_1gac9cb9756175b96e7441575803757fb73" kindref="member">av_init_packet()</ref> and by then setting data and size, some decoders might in addition need other fields like flags&amp;AV_PKT_FLAG_KEY. All decoders are designed to use the least fields possible. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">got_picture_ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Zero if no frame could be decompressed, otherwise, it is nonzero. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>On error a negative value is returned, otherwise the number of bytes used or zero if no frame could be decompressed. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="3963" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavc__decoding_1ga47db1b7f294b9f92684401b9c66a7c4b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
        <definition>int avcodec_decode_subtitle2</definition>
        <argsstring>(AVCodecContext *avctx, AVSubtitle *sub, int *got_sub_ptr, AVPacket *avpkt)</argsstring>
        <name>avcodec_decode_subtitle2</name>
        <param>
          <type><ref refid="struct_a_v_codec_context" kindref="compound">AVCodecContext</ref> *</type>
          <declname>avctx</declname>
        </param>
        <param>
          <type><ref refid="struct_a_v_subtitle" kindref="compound">AVSubtitle</ref> *</type>
          <declname>sub</declname>
        </param>
        <param>
          <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref> *</type>
          <declname>got_sub_ptr</declname>
        </param>
        <param>
          <type><ref refid="struct_a_v_packet" kindref="compound">AVPacket</ref> *</type>
          <declname>avpkt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Decode a subtitle message. Return a negative value on error, otherwise return the number of bytes used. If no subtitle could be decompressed, got_sub_ptr is zero. Otherwise, the subtitle is stored in *sub. Note that CODEC_CAP_DR1 is not available for subtitle codecs. This is for simplicity, because the performance difference is expect to be negligible and reusing a get_buffer written for video codecs would probably perform badly due to a potentially very different allocation pattern.</para><para>Some decoders (those marked with CODEC_CAP_DELAY) have a delay between input and output. This means that for some packets they will not immediately produce decoded output and need to be flushed at the end of decoding to get all the decoded data. Flushing is done by calling this function with packets with avpkt-&gt;data set to NULL and avpkt-&gt;size set to 0 until it stops returning subtitles. It is safe to flush even those decoders that are not marked with CODEC_CAP_DELAY, then no subtitles will be returned.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>avctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the codec context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">sub</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="struct_a_v_subtitle" kindref="compound">AVSubtitle</ref> in which the decoded subtitle will be stored, must be freed with avsubtitle_free if *got_sub_ptr is set. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">got_sub_ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Zero if no subtitle could be decompressed, otherwise, it is nonzero. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">avpkt</parametername>
</parameternamelist>
<parameterdescription>
<para>The input <ref refid="struct_a_v_packet" kindref="compound">AVPacket</ref> containing the input buffer. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="3991" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="define">
      <memberdef kind="define" id="group__lavc__decoding_1ga9207dd7cb4ee4416f8fd1f7a63af34b7" prot="public" static="no">
        <name>FF_INPUT_BUFFER_PADDING_SIZE</name>
        <initializer>16</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Required number of additionally allocated bytes at the end of the input bitstream for decoding. This is mainly needed because some optimized bitstream readers read 32 or 64 bit at once and could read over the end.<linebreak/>
 Note: If the first 23 bits of the additional bytes are not 0, then damaged MPEG bitstreams could cause overread and segfault. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="591" column="9" bodyfile="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" bodystart="591" bodyend="-1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
  </compounddef>
</doxygen>
