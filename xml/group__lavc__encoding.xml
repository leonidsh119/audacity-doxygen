<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.11">
  <compounddef id="group__lavc__encoding" kind="group">
    <compoundname>lavc_encoding</compoundname>
    <title>Encoding</title>
    <innerclass refid="struct_rc_override" prot="public">RcOverride</innerclass>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="group__lavc__encoding_1ga09b261f1bce5161af3485cb3302edd27" prot="public" static="no">
        <name>Motion_Est_ID</name>
        <enumvalue id="group__lavc__encoding_1gga09b261f1bce5161af3485cb3302edd27a93dc3282c22808d298c81bfde3882c42" prot="public">
          <name>ME_ZERO</name>
          <initializer>= 1</initializer>
          <briefdescription>
<para>no search, that is use 0,0 vector whenever one is needed </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lavc__encoding_1gga09b261f1bce5161af3485cb3302edd27a84208f4e6c361aaf87ac0c0f71116431" prot="public">
          <name>ME_FULL</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lavc__encoding_1gga09b261f1bce5161af3485cb3302edd27a712da9e85272e6bc8d73d897e40e8ab8" prot="public">
          <name>ME_LOG</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lavc__encoding_1gga09b261f1bce5161af3485cb3302edd27ab9f980e93b9500d67b1308ad0e9ce72a" prot="public">
          <name>ME_PHODS</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lavc__encoding_1gga09b261f1bce5161af3485cb3302edd27a47a2cf1ba9719d733ff2c0c0fc6e3491" prot="public">
          <name>ME_EPZS</name>
          <briefdescription>
<para>enhanced predictive zonal search </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lavc__encoding_1gga09b261f1bce5161af3485cb3302edd27a97220d3da7ac127439d96e641b48ca5f" prot="public">
          <name>ME_X1</name>
          <briefdescription>
<para>reserved for experiments </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lavc__encoding_1gga09b261f1bce5161af3485cb3302edd27a842aadc9a6d4f1c9fa20a17c77521327" prot="public">
          <name>ME_HEX</name>
          <briefdescription>
<para>hexagon based search </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lavc__encoding_1gga09b261f1bce5161af3485cb3302edd27a933a98fe54bd38c7ba77ca9a917e3bc8" prot="public">
          <name>ME_UMH</name>
          <briefdescription>
<para>uneven multi-hexagon search </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lavc__encoding_1gga09b261f1bce5161af3485cb3302edd27ad0718ff68dd2d8f9642f5ca4aab1e181" prot="public">
          <name>ME_TESA</name>
          <briefdescription>
<para>transformed exhaustive search algorithm </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lavc__encoding_1gga09b261f1bce5161af3485cb3302edd27ab2b41a1b4640728bd95c1910b111270f" prot="public">
          <name>ME_ITER</name>
          <initializer>=50</initializer>
          <briefdescription>
<para>iterative search </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>motion estimation type. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="605" column="1" bodyfile="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" bodystart="605" bodyend="616"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="group__lavc__encoding_1gab1f6225af3457c88da7b862af9873046" prot="public" static="no">
        <type>struct <ref refid="struct_rc_override" kindref="compound">RcOverride</ref></type>
        <definition>typedef struct RcOverride  RcOverride</definition>
        <argsstring></argsstring>
        <name>RcOverride</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="699" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__lavc__encoding_1ga9f820c481615c3a02d0407bac0bdbf25" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_a_v_codec" kindref="compound">AVCodec</ref> *</type>
        <definition>AVCodec* avcodec_find_encoder</definition>
        <argsstring>(enum AVCodecID id)</argsstring>
        <name>avcodec_find_encoder</name>
        <param>
          <type>enum <ref refid="group__lavc__core_1gaadca229ad2c20e060a14fec08a5cc7ce" kindref="member">AVCodecID</ref></type>
          <declname>id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Find a registered encoder with a matching codec ID.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>AVCodecID of the requested encoder </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An encoder if one was found, NULL otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="4242" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavc__encoding_1gaa614ffc38511c104bdff4a3afa086d37" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_a_v_codec" kindref="compound">AVCodec</ref> *</type>
        <definition>AVCodec* avcodec_find_encoder_by_name</definition>
        <argsstring>(const char *name)</argsstring>
        <name>avcodec_find_encoder_by_name</name>
        <param>
          <type><ref refid="getopt1_8c_1a2c212835823e3c54a8ab6d95c652660e" kindref="member">const</ref> char *</type>
          <declname>name</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Find a registered encoder with the specified name.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>name of the requested encoder </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An encoder if one was found, NULL otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="4250" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavc__encoding_1gaf12a9da0d33f50ff406e03572fab4763" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref> <ref refid="attributes_8h_1aa6d076561d3a9eea4729ee632652de02" kindref="member">attribute_deprecated</ref></type>
        <definition>int attribute_deprecated avcodec_encode_audio</definition>
        <argsstring>(AVCodecContext *avctx, uint8_t *buf, int buf_size, const short *samples)</argsstring>
        <name>avcodec_encode_audio</name>
        <param>
          <type><ref refid="struct_a_v_codec_context" kindref="compound">AVCodecContext</ref> *</type>
          <declname>avctx</declname>
        </param>
        <param>
          <type><ref refid="lib-src_2ffmpeg_2win32_2stdint_8h_1a9a941819355e6f658991890ff66b4b0e" kindref="member">uint8_t</ref> *</type>
          <declname>buf</declname>
        </param>
        <param>
          <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
          <declname>buf_size</declname>
        </param>
        <param>
          <type><ref refid="getopt1_8c_1a2c212835823e3c54a8ab6d95c652660e" kindref="member">const</ref> short *</type>
          <declname>samples</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Encode an audio frame from samples into buf.</para><para><xrefsect id="deprecated_1_deprecated000008"><xreftitle>Deprecated</xreftitle><xrefdescription><para>Use avcodec_encode_audio2 instead.</para></xrefdescription></xrefsect></para><para><simplesect kind="note"><para>The output buffer should be at least FF_MIN_BUFFER_SIZE bytes large. However, for codecs with avctx-&gt;frame_size equal to 0 (e.g. PCM) the user will know how much space is needed because it depends on the value passed in buf_size as described below. In that case a lower value can be used.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>avctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the codec context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">buf</parametername>
</parameternamelist>
<parameterdescription>
<para>the output buffer </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">buf_size</parametername>
</parameternamelist>
<parameterdescription>
<para>the output buffer size </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">samples</parametername>
</parameternamelist>
<parameterdescription>
<para>the input buffer containing the samples The number of samples read from this buffer is frame_size*channels, both of which are defined in avctx. For codecs which have avctx-&gt;frame_size equal to 0 (e.g. PCM) the number of samples read from samples is equal to: buf_size * 8 / (avctx-&gt;channels * av_get_bits_per_sample(avctx-&gt;codec_id)) This also implies that <ref refid="group__lavc__misc_1ga0717e7440fdb123f708082f66cd9b41d" kindref="member">av_get_bits_per_sample()</ref> must not return 0 for these codecs. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>On error a negative value is returned, on success zero or the number of bytes used to encode the data read from the input buffer. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="4277" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavc__encoding_1ga93a49fbd0973b216dcb8a8c5dffe1d82" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
        <definition>int avcodec_encode_audio2</definition>
        <argsstring>(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame, int *got_packet_ptr)</argsstring>
        <name>avcodec_encode_audio2</name>
        <param>
          <type><ref refid="struct_a_v_codec_context" kindref="compound">AVCodecContext</ref> *</type>
          <declname>avctx</declname>
        </param>
        <param>
          <type><ref refid="struct_a_v_packet" kindref="compound">AVPacket</ref> *</type>
          <declname>avpkt</declname>
        </param>
        <param>
          <type><ref refid="getopt1_8c_1a2c212835823e3c54a8ab6d95c652660e" kindref="member">const</ref> <ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> *</type>
          <declname>frame</declname>
        </param>
        <param>
          <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref> *</type>
          <declname>got_packet_ptr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Encode a frame of audio.</para><para>Takes input samples from frame and writes the next output packet, if available, to avpkt. The output packet does not necessarily contain data for the most recent frame, as encoders can delay, split, and combine input frames internally as needed.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>avctx</parametername>
</parameternamelist>
<parameterdescription>
<para>codec context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>avpkt</parametername>
</parameternamelist>
<parameterdescription>
<para>output <ref refid="struct_a_v_packet" kindref="compound">AVPacket</ref>. The user can supply an output buffer by setting avpkt-&gt;data and avpkt-&gt;size prior to calling the function, but if the size of the user-provided data is not large enough, encoding will fail. If avpkt-&gt;data and avpkt-&gt;size are set, avpkt-&gt;destruct must also be set. All other <ref refid="struct_a_v_packet" kindref="compound">AVPacket</ref> fields will be reset by the encoder using <ref refid="group__lavc__packet_1gac9cb9756175b96e7441575803757fb73" kindref="member">av_init_packet()</ref>. If avpkt-&gt;data is NULL, the encoder will allocate it. The encoder will set avpkt-&gt;size to the size of the output packet.</para></parameterdescription>
</parameteritem>
</parameterlist>
If this function fails or produces no output, avpkt will be freed using <ref refid="group__lavc__packet_1gae65881462e78f98b268f34661d921ee0" kindref="member">av_free_packet()</ref> (i.e. avpkt-&gt;destruct will be called to free the user supplied buffer). <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">frame</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> containing the raw audio data to be encoded. May be NULL when flushing an encoder that has the CODEC_CAP_DELAY capability set. If CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame can have any number of samples. If it is not set, frame-&gt;nb_samples must be equal to avctx-&gt;frame_size for all frames except the last. The final frame may be smaller than avctx-&gt;frame_size. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">got_packet_ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>This field is set to 1 by libavcodec if the output packet is non-empty, and to 0 if it is empty. If the function returns an error, the packet can be assumed to be invalid, and the value of got_packet_ptr is undefined and should not be used. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success, negative error code on failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="4321" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavc__encoding_1ga22847c21918ee93a4d05f7ffb419f9a9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="attributes_8h_1aa6d076561d3a9eea4729ee632652de02" kindref="member">attribute_deprecated</ref> <ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
        <definition>attribute_deprecated int avcodec_encode_video</definition>
        <argsstring>(AVCodecContext *avctx, uint8_t *buf, int buf_size, const AVFrame *pict)</argsstring>
        <name>avcodec_encode_video</name>
        <param>
          <type><ref refid="struct_a_v_codec_context" kindref="compound">AVCodecContext</ref> *</type>
          <declname>avctx</declname>
        </param>
        <param>
          <type><ref refid="lib-src_2ffmpeg_2win32_2stdint_8h_1a9a941819355e6f658991890ff66b4b0e" kindref="member">uint8_t</ref> *</type>
          <declname>buf</declname>
        </param>
        <param>
          <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
          <declname>buf_size</declname>
        </param>
        <param>
          <type><ref refid="getopt1_8c_1a2c212835823e3c54a8ab6d95c652660e" kindref="member">const</ref> <ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> *</type>
          <declname>pict</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><xrefsect id="deprecated_1_deprecated000009"><xreftitle>Deprecated</xreftitle><xrefdescription><para>use <ref refid="group__lavc__encoding_1gaa2dc9e9ea2567ebb2801a08153c7306b" kindref="member">avcodec_encode_video2()</ref> instead.</para></xrefdescription></xrefsect></para><para>Encode a video frame from pict into buf. The input picture should be stored using a specific format, namely avctx.pix_fmt.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>avctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the codec context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">buf</parametername>
</parameternamelist>
<parameterdescription>
<para>the output buffer for the bitstream of encoded frame </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">buf_size</parametername>
</parameternamelist>
<parameterdescription>
<para>the size of the output buffer in bytes </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">pict</parametername>
</parameternamelist>
<parameterdescription>
<para>the input picture to encode </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>On error a negative value is returned, on success zero or the number of bytes used from the output buffer. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="4340" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavc__encoding_1gaa2dc9e9ea2567ebb2801a08153c7306b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
        <definition>int avcodec_encode_video2</definition>
        <argsstring>(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame, int *got_packet_ptr)</argsstring>
        <name>avcodec_encode_video2</name>
        <param>
          <type><ref refid="struct_a_v_codec_context" kindref="compound">AVCodecContext</ref> *</type>
          <declname>avctx</declname>
        </param>
        <param>
          <type><ref refid="struct_a_v_packet" kindref="compound">AVPacket</ref> *</type>
          <declname>avpkt</declname>
        </param>
        <param>
          <type><ref refid="getopt1_8c_1a2c212835823e3c54a8ab6d95c652660e" kindref="member">const</ref> <ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> *</type>
          <declname>frame</declname>
        </param>
        <param>
          <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref> *</type>
          <declname>got_packet_ptr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Encode a frame of video.</para><para>Takes input raw video data from frame and writes the next output packet, if available, to avpkt. The output packet does not necessarily contain data for the most recent frame, as encoders can delay and reorder input frames internally as needed.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>avctx</parametername>
</parameternamelist>
<parameterdescription>
<para>codec context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>avpkt</parametername>
</parameternamelist>
<parameterdescription>
<para>output <ref refid="struct_a_v_packet" kindref="compound">AVPacket</ref>. The user can supply an output buffer by setting avpkt-&gt;data and avpkt-&gt;size prior to calling the function, but if the size of the user-provided data is not large enough, encoding will fail. All other <ref refid="struct_a_v_packet" kindref="compound">AVPacket</ref> fields will be reset by the encoder using <ref refid="group__lavc__packet_1gac9cb9756175b96e7441575803757fb73" kindref="member">av_init_packet()</ref>. If avpkt-&gt;data is NULL, the encoder will allocate it. The encoder will set avpkt-&gt;size to the size of the output packet. The returned data (if any) belongs to the caller, he is responsible for freeing it.</para></parameterdescription>
</parameteritem>
</parameterlist>
If this function fails or produces no output, avpkt will be freed using <ref refid="group__lavc__packet_1gae65881462e78f98b268f34661d921ee0" kindref="member">av_free_packet()</ref> (i.e. avpkt-&gt;destruct will be called to free the user supplied buffer). <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">frame</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> containing the raw video data to be encoded. May be NULL when flushing an encoder that has the CODEC_CAP_DELAY capability set. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">got_packet_ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>This field is set to 1 by libavcodec if the output packet is non-empty, and to 0 if it is empty. If the function returns an error, the packet can be assumed to be invalid, and the value of got_packet_ptr is undefined and should not be used. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success, negative error code on failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="4378" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavc__encoding_1ga37be256d85d78f665df27ad6c8f1d65b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
        <definition>int avcodec_encode_subtitle</definition>
        <argsstring>(AVCodecContext *avctx, uint8_t *buf, int buf_size, const AVSubtitle *sub)</argsstring>
        <name>avcodec_encode_subtitle</name>
        <param>
          <type><ref refid="struct_a_v_codec_context" kindref="compound">AVCodecContext</ref> *</type>
          <declname>avctx</declname>
        </param>
        <param>
          <type><ref refid="lib-src_2ffmpeg_2win32_2stdint_8h_1a9a941819355e6f658991890ff66b4b0e" kindref="member">uint8_t</ref> *</type>
          <declname>buf</declname>
        </param>
        <param>
          <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
          <declname>buf_size</declname>
        </param>
        <param>
          <type><ref refid="getopt1_8c_1a2c212835823e3c54a8ab6d95c652660e" kindref="member">const</ref> <ref refid="struct_a_v_subtitle" kindref="compound">AVSubtitle</ref> *</type>
          <declname>sub</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="4381" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="define">
      <memberdef kind="define" id="group__lavc__encoding_1gacf94eb890b3b77383ec7fd728db8509c" prot="public" static="no">
        <name>FF_MIN_BUFFER_SIZE</name>
        <initializer>16384</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>minimum encoding buffer size Used to avoid some checks during header writing. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" line="598" column="9" bodyfile="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h" bodystart="598" bodyend="-1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
  </compounddef>
</doxygen>
