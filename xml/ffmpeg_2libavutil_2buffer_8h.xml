<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.11">
  <compounddef id="ffmpeg_2libavutil_2buffer_8h" kind="file" language="C++">
    <compoundname>buffer.h</compoundname>
    <includes local="no">stdint.h</includes>
    <includedby refid="avcodec_8h" local="yes">C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h</includedby>
    <includedby refid="ffmpeg_2libavutil_2frame_8h" local="yes">C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/frame.h</includedby>
    <incdepgraph>
      <node id="3420">
        <label>stdint.h</label>
      </node>
      <node id="3419">
        <label>C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/buffer.h</label>
        <link refid="ffmpeg/libavutil/buffer.h"/>
        <childnode refid="3420" relation="include">
        </childnode>
      </node>
    </incdepgraph>
    <invincdepgraph>
      <node id="3427">
        <label>C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/downmix_info.h</label>
        <link refid="downmix__info_8h"/>
      </node>
      <node id="3426">
        <label>C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/frame.h</label>
        <link refid="ffmpeg_2libavutil_2frame_8h"/>
        <childnode refid="3422" relation="include">
        </childnode>
        <childnode refid="3427" relation="include">
        </childnode>
        <childnode refid="3428" relation="include">
        </childnode>
      </node>
      <node id="3424">
        <label>C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/xvmc.h</label>
        <link refid="xvmc_8h"/>
      </node>
      <node id="3423">
        <label>C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/vdpau.h</label>
        <link refid="vdpau_8h"/>
      </node>
      <node id="3421">
        <label>C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/buffer.h</label>
        <link refid="ffmpeg/libavutil/buffer.h"/>
        <childnode refid="3422" relation="include">
        </childnode>
        <childnode refid="3426" relation="include">
        </childnode>
      </node>
      <node id="3425">
        <label>C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavformat/avformat.h</label>
        <link refid="avformat_8h"/>
      </node>
      <node id="3428">
        <label>C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/stereo3d.h</label>
        <link refid="stereo3d_8h"/>
      </node>
      <node id="3422">
        <label>C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavcodec/avcodec.h</label>
        <link refid="avcodec_8h"/>
        <childnode refid="3423" relation="include">
        </childnode>
        <childnode refid="3424" relation="include">
        </childnode>
        <childnode refid="3425" relation="include">
        </childnode>
      </node>
    </invincdepgraph>
    <innerclass refid="struct_a_v_buffer_ref" prot="public">AVBufferRef</innerclass>
      <sectiondef kind="define">
      <memberdef kind="define" id="group__lavu__buffer_1gaa818f8f1011d69acc50c1f29cb85e576" prot="public" static="no">
        <name>AV_BUFFER_FLAG_READONLY</name>
        <initializer>(1 &lt;&lt; 0)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Always treat the buffer as read-only, even when it has only one reference. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/buffer.h" line="113" column="9" bodyfile="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/buffer.h" bodystart="113" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="group__lavu__buffer_1ga501d49df442180d584f255aa97b2549d" prot="public" static="no">
        <type>struct <ref refid="group__lavu__buffer_1ga501d49df442180d584f255aa97b2549d" kindref="member">AVBuffer</ref></type>
        <definition>typedef struct AVBuffer AVBuffer</definition>
        <argsstring></argsstring>
        <name>AVBuffer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A reference counted buffer type. It is opaque and is meant to be used through references (<ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref>). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/buffer.h" line="75" column="1" bodyfile="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/buffer.h" bodystart="73" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__lavu__buffer_1ga433e680d11ad786bd1bc20f5616c7d19" prot="public" static="no">
        <type>struct <ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref></type>
        <definition>typedef struct AVBufferRef  AVBufferRef</definition>
        <argsstring></argsstring>
        <name>AVBufferRef</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A reference to a data buffer.</para><para>The size of this struct is not a part of the public ABI and it is not meant to be allocated directly. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/buffer.h" line="94" column="1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__lavu__bufferpool_1ga13bc8038952b61bae4d591f30c7421f6" prot="public" static="no">
        <type>struct <ref refid="group__lavu__bufferpool_1ga13bc8038952b61bae4d591f30c7421f6" kindref="member">AVBufferPool</ref></type>
        <definition>typedef struct AVBufferPool AVBufferPool</definition>
        <argsstring></argsstring>
        <name>AVBufferPool</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The buffer pool. This structure is opaque and not meant to be accessed directly. It is allocated with <ref refid="group__lavu__bufferpool_1ga26af9b07c08bc7fd2cfc62767e490b93" kindref="member">av_buffer_pool_init()</ref> and freed with <ref refid="group__lavu__bufferpool_1ga7b76781c5944b3bb59b2e3b1a8994e4a" kindref="member">av_buffer_pool_uninit()</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/buffer.h" line="198" column="1" bodyfile="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/buffer.h" bodystart="238" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__lavu__buffer_1ga5ae84ac902283dea1a660ede06c1cdac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref> *</type>
        <definition>AVBufferRef* av_buffer_alloc</definition>
        <argsstring>(int size)</argsstring>
        <name>av_buffer_alloc</name>
        <param>
          <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
          <declname>size</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Allocate an AVBuffer of the given size using <ref refid="group__lavu__mem_1gacbca30ebc510a7e4156d66e7aceb2dc8" kindref="member">av_malloc()</ref>.</para><para><simplesect kind="return"><para>an <ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref> of given size or NULL when out of memory </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/buffer.h" line="101" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavu__buffer_1ga27f37cc004f768b00442b6cb08091686" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref> *</type>
        <definition>AVBufferRef* av_buffer_allocz</definition>
        <argsstring>(int size)</argsstring>
        <name>av_buffer_allocz</name>
        <param>
          <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
          <declname>size</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Same as <ref refid="group__lavu__buffer_1ga5ae84ac902283dea1a660ede06c1cdac" kindref="member">av_buffer_alloc()</ref>, except the returned buffer will be initialized to zero. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/buffer.h" line="107" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavu__buffer_1ga3e7f4c92db85ccba0b2a16dd0069842a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref> *</type>
        <definition>AVBufferRef* av_buffer_create</definition>
        <argsstring>(uint8_t *data, int size, void(*free)(void *opaque, uint8_t *data), void *opaque, int flags)</argsstring>
        <name>av_buffer_create</name>
        <param>
          <type><ref refid="lib-src_2ffmpeg_2win32_2stdint_8h_1a9a941819355e6f658991890ff66b4b0e" kindref="member">uint8_t</ref> *</type>
          <declname>data</declname>
        </param>
        <param>
          <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
          <declname>size</declname>
        </param>
        <param>
          <type><ref refid="sound_8c_1ae35f5844602719cf66324f4de2a658b3" kindref="member">void</ref>(*)(<ref refid="sound_8c_1ae35f5844602719cf66324f4de2a658b3" kindref="member">void</ref> *opaque, <ref refid="lib-src_2ffmpeg_2win32_2stdint_8h_1a9a941819355e6f658991890ff66b4b0e" kindref="member">uint8_t</ref> *<ref refid="lib_2expat_8h_1ac39e72a1de1cb50dbdc54b08d0432a24" kindref="member">data</ref>)</type>
          <declname>free</declname>
        </param>
        <param>
          <type><ref refid="sound_8c_1ae35f5844602719cf66324f4de2a658b3" kindref="member">void</ref> *</type>
          <declname>opaque</declname>
        </param>
        <param>
          <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
          <declname>flags</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create an AVBuffer from an existing array.</para><para>If this function is successful, data is owned by the AVBuffer. The caller may only access data through the returned <ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref> and references derived from it. If this function fails, data is left untouched. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>data array </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>size of data in bytes </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>free</parametername>
</parameternamelist>
<parameterdescription>
<para>a callback for freeing this buffer&apos;s data </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>opaque</parametername>
</parameternamelist>
<parameterdescription>
<para>parameter to be got for processing or passed to free </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>flags</parametername>
</parameternamelist>
<parameterdescription>
<para>a combination of AV_BUFFER_FLAG_*</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>an <ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref> referring to data on success, NULL on failure. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/buffer.h" line="130" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavu__buffer_1ga37d620e8cfc9f2f3261c2b4c5d4adfe0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="sound_8c_1ae35f5844602719cf66324f4de2a658b3" kindref="member">void</ref></type>
        <definition>void av_buffer_default_free</definition>
        <argsstring>(void *opaque, uint8_t *data)</argsstring>
        <name>av_buffer_default_free</name>
        <param>
          <type><ref refid="sound_8c_1ae35f5844602719cf66324f4de2a658b3" kindref="member">void</ref> *</type>
          <declname>opaque</declname>
        </param>
        <param>
          <type><ref refid="lib-src_2ffmpeg_2win32_2stdint_8h_1a9a941819355e6f658991890ff66b4b0e" kindref="member">uint8_t</ref> *</type>
          <declname>data</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Default free callback, which calls <ref refid="group__lavu__mem_1ga0c9096f498624c525aa2315b8a20c411" kindref="member">av_free()</ref> on the buffer data. This function is meant to be passed to <ref refid="group__lavu__buffer_1ga3e7f4c92db85ccba0b2a16dd0069842a" kindref="member">av_buffer_create()</ref>, not called directly. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/buffer.h" line="139" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavu__buffer_1gaa40ce7d3ede946a89d03323bbd7268c1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref> *</type>
        <definition>AVBufferRef* av_buffer_ref</definition>
        <argsstring>(AVBufferRef *buf)</argsstring>
        <name>av_buffer_ref</name>
        <param>
          <type><ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref> *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a new reference to an AVBuffer.</para><para><simplesect kind="return"><para>a new <ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref> referring to the same AVBuffer as buf or NULL on failure. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/buffer.h" line="147" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavu__buffer_1ga135e9e929b5033bb8f68322497b2effc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="sound_8c_1ae35f5844602719cf66324f4de2a658b3" kindref="member">void</ref></type>
        <definition>void av_buffer_unref</definition>
        <argsstring>(AVBufferRef **buf)</argsstring>
        <name>av_buffer_unref</name>
        <param>
          <type><ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref> **</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Free a given reference and automatically free the buffer if there are no more references to it.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>the reference to be freed. The pointer is set to NULL on return. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/buffer.h" line="155" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavu__buffer_1ga060be34ace567ae378fd0a786e847053" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
        <definition>int av_buffer_is_writable</definition>
        <argsstring>(const AVBufferRef *buf)</argsstring>
        <name>av_buffer_is_writable</name>
        <param>
          <type><ref refid="getopt1_8c_1a2c212835823e3c54a8ab6d95c652660e" kindref="member">const</ref> <ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref> *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>1 if the caller may write to the data referred to by buf (which is true if and only if buf is the only reference to the underlying AVBuffer). Return 0 otherwise. A positive answer is valid until <ref refid="group__lavu__buffer_1gaa40ce7d3ede946a89d03323bbd7268c1" kindref="member">av_buffer_ref()</ref> is called on buf. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/buffer.h" line="163" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavu__buffer_1gac1c38f469fc9933885cfffafd8cbf0d6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="sound_8c_1ae35f5844602719cf66324f4de2a658b3" kindref="member">void</ref> *</type>
        <definition>void* av_buffer_get_opaque</definition>
        <argsstring>(const AVBufferRef *buf)</argsstring>
        <name>av_buffer_get_opaque</name>
        <param>
          <type><ref refid="getopt1_8c_1a2c212835823e3c54a8ab6d95c652660e" kindref="member">const</ref> <ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref> *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>the opaque parameter set by av_buffer_create. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/buffer.h" line="168" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavu__buffer_1ga7b16c3976dc555f71d0843bbd023dfcd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
        <definition>int av_buffer_get_ref_count</definition>
        <argsstring>(const AVBufferRef *buf)</argsstring>
        <name>av_buffer_get_ref_count</name>
        <param>
          <type><ref refid="getopt1_8c_1a2c212835823e3c54a8ab6d95c652660e" kindref="member">const</ref> <ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref> *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/buffer.h" line="170" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavu__buffer_1ga9c2a1be1b7bb80eec8613fdb62a19074" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
        <definition>int av_buffer_make_writable</definition>
        <argsstring>(AVBufferRef **buf)</argsstring>
        <name>av_buffer_make_writable</name>
        <param>
          <type><ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref> **</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a writable reference from a given buffer reference, avoiding data copy if possible.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>buffer reference to make writable. On success, buf is either left untouched, or it is unreferenced and a new writable <ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref> is written in its place. On failure, buf is left untouched. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success, a negative AVERROR on failure. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/buffer.h" line="181" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavu__buffer_1gac7c228f9ed54e246dcd270503bed7291" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
        <definition>int av_buffer_realloc</definition>
        <argsstring>(AVBufferRef **buf, int size)</argsstring>
        <name>av_buffer_realloc</name>
        <param>
          <type><ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref> **</type>
          <declname>buf</declname>
        </param>
        <param>
          <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
          <declname>size</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Reallocate a given buffer.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>a buffer reference to reallocate. On success, buf will be unreferenced and a new reference with the required size will be written in its place. On failure buf will be left untouched. *buf may be NULL, then a new buffer is allocated. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>required new buffer size. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success, a negative AVERROR on failure.</para></simplesect>
<simplesect kind="note"><para>the buffer is actually reallocated with <ref refid="group__lavu__mem_1ga74bb2298daa9cd0b5f1d0b2c1c3e26bb" kindref="member">av_realloc()</ref> only if it was initially allocated through av_buffer_realloc(NULL) and there is only one reference to it (i.e. the one passed to this function). In all other cases a new buffer is allocated and the data is copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/buffer.h" line="198" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavu__bufferpool_1ga26af9b07c08bc7fd2cfc62767e490b93" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__lavu__bufferpool_1ga13bc8038952b61bae4d591f30c7421f6" kindref="member">AVBufferPool</ref> *</type>
        <definition>AVBufferPool* av_buffer_pool_init</definition>
        <argsstring>(int size, AVBufferRef *(*alloc)(int size))</argsstring>
        <name>av_buffer_pool_init</name>
        <param>
          <type><ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref></type>
          <declname>size</declname>
        </param>
        <param>
          <type><ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref> *(*)(<ref refid="xmltok_8h_1a5a0d4a5641ce434f1d23533f2b2e6653" kindref="member">int</ref> <ref refid="group__lavu__mem_1ga854352f53b148adc24983a58a1866d66" kindref="member">size</ref>)</type>
          <declname>alloc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Allocate and initialize a buffer pool.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>size of each buffer in this pool </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>alloc</parametername>
</parameternamelist>
<parameterdescription>
<para>a function that will be used to allocate new buffers when the pool is empty. May be NULL, then the default allocator will be used (<ref refid="group__lavu__buffer_1ga5ae84ac902283dea1a660ede06c1cdac" kindref="member">av_buffer_alloc()</ref>). </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>newly created buffer pool on success, NULL on error. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/buffer.h" line="249" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavu__bufferpool_1ga7b76781c5944b3bb59b2e3b1a8994e4a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="sound_8c_1ae35f5844602719cf66324f4de2a658b3" kindref="member">void</ref></type>
        <definition>void av_buffer_pool_uninit</definition>
        <argsstring>(AVBufferPool **pool)</argsstring>
        <name>av_buffer_pool_uninit</name>
        <param>
          <type><ref refid="group__lavu__bufferpool_1ga13bc8038952b61bae4d591f30c7421f6" kindref="member">AVBufferPool</ref> **</type>
          <declname>pool</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Mark the pool as being available for freeing. It will actually be freed only once all the allocated buffers associated with the pool are released. Thus it is safe to call this function while some of the allocated buffers are still in use.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pool</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the pool to be freed. It will be set to NULL. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>av_buffer_pool_can_uninit() </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/buffer.h" line="260" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__lavu__bufferpool_1ga2c745ecb4001452423e775b06b20fb7c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref> *</type>
        <definition>AVBufferRef* av_buffer_pool_get</definition>
        <argsstring>(AVBufferPool *pool)</argsstring>
        <name>av_buffer_pool_get</name>
        <param>
          <type><ref refid="group__lavu__bufferpool_1ga13bc8038952b61bae4d591f30c7421f6" kindref="member">AVBufferPool</ref> *</type>
          <declname>pool</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Allocate a new AVBuffer, reusing an old buffer from the pool when available. This function may be called simultaneously from multiple threads.</para><para><simplesect kind="return"><para>a reference to the new buffer on success, NULL on error. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/buffer.h" line="268" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>refcounted data buffer API </para>    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">/*</highlight></codeline>
<codeline lineno="2"><highlight class="comment"><sp/>*<sp/>This<sp/>file<sp/>is<sp/>part<sp/>of<sp/>FFmpeg.</highlight></codeline>
<codeline lineno="3"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="4"><highlight class="comment"><sp/>*<sp/>FFmpeg<sp/>is<sp/>free<sp/>software;<sp/>you<sp/>can<sp/>redistribute<sp/>it<sp/>and/or</highlight></codeline>
<codeline lineno="5"><highlight class="comment"><sp/>*<sp/>modify<sp/>it<sp/>under<sp/>the<sp/>terms<sp/>of<sp/>the<sp/>GNU<sp/>Lesser<sp/>General<sp/>Public</highlight></codeline>
<codeline lineno="6"><highlight class="comment"><sp/>*<sp/>License<sp/>as<sp/>published<sp/>by<sp/>the<sp/>Free<sp/>Software<sp/>Foundation;<sp/>either</highlight></codeline>
<codeline lineno="7"><highlight class="comment"><sp/>*<sp/>version<sp/>2.1<sp/>of<sp/>the<sp/>License,<sp/>or<sp/>(at<sp/>your<sp/>option)<sp/>any<sp/>later<sp/>version.</highlight></codeline>
<codeline lineno="8"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="9"><highlight class="comment"><sp/>*<sp/>FFmpeg<sp/>is<sp/>distributed<sp/>in<sp/>the<sp/>hope<sp/>that<sp/>it<sp/>will<sp/>be<sp/>useful,</highlight></codeline>
<codeline lineno="10"><highlight class="comment"><sp/>*<sp/>but<sp/>WITHOUT<sp/>ANY<sp/>WARRANTY;<sp/>without<sp/>even<sp/>the<sp/>implied<sp/>warranty<sp/>of</highlight></codeline>
<codeline lineno="11"><highlight class="comment"><sp/>*<sp/>MERCHANTABILITY<sp/>or<sp/>FITNESS<sp/>FOR<sp/>A<sp/>PARTICULAR<sp/>PURPOSE.<sp/><sp/>See<sp/>the<sp/>GNU</highlight></codeline>
<codeline lineno="12"><highlight class="comment"><sp/>*<sp/>Lesser<sp/>General<sp/>Public<sp/>License<sp/>for<sp/>more<sp/>details.</highlight></codeline>
<codeline lineno="13"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="14"><highlight class="comment"><sp/>*<sp/>You<sp/>should<sp/>have<sp/>received<sp/>a<sp/>copy<sp/>of<sp/>the<sp/>GNU<sp/>Lesser<sp/>General<sp/>Public</highlight></codeline>
<codeline lineno="15"><highlight class="comment"><sp/>*<sp/>License<sp/>along<sp/>with<sp/>FFmpeg;<sp/>if<sp/>not,<sp/>write<sp/>to<sp/>the<sp/>Free<sp/>Software</highlight></codeline>
<codeline lineno="16"><highlight class="comment"><sp/>*<sp/>Foundation,<sp/>Inc.,<sp/>51<sp/>Franklin<sp/>Street,<sp/>Fifth<sp/>Floor,<sp/>Boston,<sp/>MA<sp/>02110-1301<sp/>USA</highlight></codeline>
<codeline lineno="17"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="18"><highlight class="normal"></highlight></codeline>
<codeline lineno="25"><highlight class="preprocessor">#ifndef<sp/>AVUTIL_BUFFER_H</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="26"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>AVUTIL_BUFFER_H</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="27"><highlight class="normal"></highlight></codeline>
<codeline lineno="28"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdint.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="29"><highlight class="normal"></highlight></codeline>
<codeline lineno="73" refid="group__lavu__buffer_1ga501d49df442180d584f255aa97b2549d" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="group__lavu__buffer_1ga501d49df442180d584f255aa97b2549d" kindref="member">AVBuffer</ref><sp/><ref refid="group__lavu__buffer_1ga501d49df442180d584f255aa97b2549d" kindref="member">AVBuffer</ref>;</highlight></codeline>
<codeline lineno="74"><highlight class="normal"></highlight></codeline>
<codeline lineno="81" refid="struct_a_v_buffer_ref" refkind="compound"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref><sp/>{</highlight></codeline>
<codeline lineno="82" refid="struct_a_v_buffer_ref_1a3c692274c56720d7903bbd35bcaec3a2" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__lavu__buffer_1ga501d49df442180d584f255aa97b2549d" kindref="member">AVBuffer</ref><sp/>*<ref refid="struct_a_v_buffer_ref_1a3c692274c56720d7903bbd35bcaec3a2" kindref="member">buffer</ref>;</highlight></codeline>
<codeline lineno="83"><highlight class="normal"></highlight></codeline>
<codeline lineno="89" refid="struct_a_v_buffer_ref_1acb8452e99cd75074b93800b532c6ea4b" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="lib-src_2ffmpeg_2win32_2stdint_8h_1a9a941819355e6f658991890ff66b4b0e" kindref="member">uint8_t</ref><sp/>*<ref refid="struct_a_v_buffer_ref_1acb8452e99cd75074b93800b532c6ea4b" kindref="member">data</ref>;</highlight></codeline>
<codeline lineno="93" refid="struct_a_v_buffer_ref_1a55f17b82a5af97259a5e8a3fd9647a08" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_a_v_buffer_ref_1a55f17b82a5af97259a5e8a3fd9647a08" kindref="member">size</ref>;</highlight></codeline>
<codeline lineno="94"><highlight class="normal">}<sp/><ref refid="group__lavu__buffer_1ga433e680d11ad786bd1bc20f5616c7d19" kindref="member">AVBufferRef</ref>;</highlight></codeline>
<codeline lineno="95"><highlight class="normal"></highlight></codeline>
<codeline lineno="101"><highlight class="normal"><ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref><sp/>*<ref refid="group__lavu__buffer_1ga5ae84ac902283dea1a660ede06c1cdac" kindref="member">av_buffer_alloc</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="struct_a_v_buffer_ref_1a55f17b82a5af97259a5e8a3fd9647a08" kindref="member">size</ref>);</highlight></codeline>
<codeline lineno="102"><highlight class="normal"></highlight></codeline>
<codeline lineno="107"><highlight class="normal"><ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref><sp/>*<ref refid="group__lavu__buffer_1ga27f37cc004f768b00442b6cb08091686" kindref="member">av_buffer_allocz</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="struct_a_v_buffer_ref_1a55f17b82a5af97259a5e8a3fd9647a08" kindref="member">size</ref>);</highlight></codeline>
<codeline lineno="108"><highlight class="normal"></highlight></codeline>
<codeline lineno="113" refid="group__lavu__buffer_1gaa818f8f1011d69acc50c1f29cb85e576" refkind="member"><highlight class="preprocessor">#define<sp/>AV_BUFFER_FLAG_READONLY<sp/>(1<sp/>&lt;&lt;<sp/>0)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="114"><highlight class="normal"></highlight></codeline>
<codeline lineno="130"><highlight class="normal"><ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref><sp/>*<ref refid="group__lavu__buffer_1ga3e7f4c92db85ccba0b2a16dd0069842a" kindref="member">av_buffer_create</ref>(<ref refid="lib-src_2ffmpeg_2win32_2stdint_8h_1a9a941819355e6f658991890ff66b4b0e" kindref="member">uint8_t</ref><sp/>*<ref refid="lib_2expat_8h_1ac39e72a1de1cb50dbdc54b08d0432a24" kindref="member">data</ref>,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="struct_a_v_buffer_ref_1a55f17b82a5af97259a5e8a3fd9647a08" kindref="member">size</ref>,</highlight></codeline>
<codeline lineno="131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>(*free)(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*opaque,<sp/><ref refid="lib-src_2ffmpeg_2win32_2stdint_8h_1a9a941819355e6f658991890ff66b4b0e" kindref="member">uint8_t</ref><sp/>*data),</highlight></codeline>
<codeline lineno="132"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*opaque,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>flags);</highlight></codeline>
<codeline lineno="133"><highlight class="normal"></highlight></codeline>
<codeline lineno="139"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__lavu__buffer_1ga37d620e8cfc9f2f3261c2b4c5d4adfe0" kindref="member">av_buffer_default_free</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*opaque,<sp/><ref refid="lib-src_2ffmpeg_2win32_2stdint_8h_1a9a941819355e6f658991890ff66b4b0e" kindref="member">uint8_t</ref><sp/>*data);</highlight></codeline>
<codeline lineno="140"><highlight class="normal"></highlight></codeline>
<codeline lineno="147"><highlight class="normal"><ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref><sp/>*<ref refid="group__lavu__buffer_1gaa40ce7d3ede946a89d03323bbd7268c1" kindref="member">av_buffer_ref</ref>(<ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref><sp/>*<ref refid="xlglob_8c_1a6d3f7f126151ca554ba001d63c9721f9" kindref="member">buf</ref>);</highlight></codeline>
<codeline lineno="148"><highlight class="normal"></highlight></codeline>
<codeline lineno="155"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__lavu__buffer_1ga135e9e929b5033bb8f68322497b2effc" kindref="member">av_buffer_unref</ref>(<ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref><sp/>**<ref refid="xlglob_8c_1a6d3f7f126151ca554ba001d63c9721f9" kindref="member">buf</ref>);</highlight></codeline>
<codeline lineno="156"><highlight class="normal"></highlight></codeline>
<codeline lineno="163"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="group__lavu__buffer_1ga060be34ace567ae378fd0a786e847053" kindref="member">av_buffer_is_writable</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref><sp/>*<ref refid="xlglob_8c_1a6d3f7f126151ca554ba001d63c9721f9" kindref="member">buf</ref>);</highlight></codeline>
<codeline lineno="164"><highlight class="normal"></highlight></codeline>
<codeline lineno="168"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*<ref refid="group__lavu__buffer_1gac1c38f469fc9933885cfffafd8cbf0d6" kindref="member">av_buffer_get_opaque</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref><sp/>*<ref refid="xlglob_8c_1a6d3f7f126151ca554ba001d63c9721f9" kindref="member">buf</ref>);</highlight></codeline>
<codeline lineno="169"><highlight class="normal"></highlight></codeline>
<codeline lineno="170"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="group__lavu__buffer_1ga7b16c3976dc555f71d0843bbd023dfcd" kindref="member">av_buffer_get_ref_count</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref><sp/>*<ref refid="xlglob_8c_1a6d3f7f126151ca554ba001d63c9721f9" kindref="member">buf</ref>);</highlight></codeline>
<codeline lineno="171"><highlight class="normal"></highlight></codeline>
<codeline lineno="181"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="group__lavu__buffer_1ga9c2a1be1b7bb80eec8613fdb62a19074" kindref="member">av_buffer_make_writable</ref>(<ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref><sp/>**<ref refid="xlglob_8c_1a6d3f7f126151ca554ba001d63c9721f9" kindref="member">buf</ref>);</highlight></codeline>
<codeline lineno="182"><highlight class="normal"></highlight></codeline>
<codeline lineno="198"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="group__lavu__buffer_1gac7c228f9ed54e246dcd270503bed7291" kindref="member">av_buffer_realloc</ref>(<ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref><sp/>**<ref refid="xlglob_8c_1a6d3f7f126151ca554ba001d63c9721f9" kindref="member">buf</ref>,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>size);</highlight></codeline>
<codeline lineno="199"><highlight class="normal"></highlight></codeline>
<codeline lineno="238" refid="group__lavu__bufferpool_1ga13bc8038952b61bae4d591f30c7421f6" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="group__lavu__bufferpool_1ga13bc8038952b61bae4d591f30c7421f6" kindref="member">AVBufferPool</ref><sp/><ref refid="group__lavu__bufferpool_1ga13bc8038952b61bae4d591f30c7421f6" kindref="member">AVBufferPool</ref>;</highlight></codeline>
<codeline lineno="239"><highlight class="normal"></highlight></codeline>
<codeline lineno="249"><highlight class="normal"><ref refid="group__lavu__bufferpool_1ga13bc8038952b61bae4d591f30c7421f6" kindref="member">AVBufferPool</ref><sp/>*<ref refid="group__lavu__bufferpool_1ga26af9b07c08bc7fd2cfc62767e490b93" kindref="member">av_buffer_pool_init</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>size,<sp/><ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref>*<sp/>(*alloc)(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>size));</highlight></codeline>
<codeline lineno="250"><highlight class="normal"></highlight></codeline>
<codeline lineno="260"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__lavu__bufferpool_1ga7b76781c5944b3bb59b2e3b1a8994e4a" kindref="member">av_buffer_pool_uninit</ref>(<ref refid="group__lavu__bufferpool_1ga13bc8038952b61bae4d591f30c7421f6" kindref="member">AVBufferPool</ref><sp/>**pool);</highlight></codeline>
<codeline lineno="261"><highlight class="normal"></highlight></codeline>
<codeline lineno="268"><highlight class="normal"><ref refid="struct_a_v_buffer_ref" kindref="compound">AVBufferRef</ref><sp/>*<ref refid="group__lavu__bufferpool_1ga2c745ecb4001452423e775b06b20fb7c" kindref="member">av_buffer_pool_get</ref>(<ref refid="group__lavu__bufferpool_1ga13bc8038952b61bae4d591f30c7421f6" kindref="member">AVBufferPool</ref><sp/>*pool);</highlight></codeline>
<codeline lineno="269"><highlight class="normal"></highlight></codeline>
<codeline lineno="274"><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">/*<sp/>AVUTIL_BUFFER_H<sp/>*/</highlight><highlight class="preprocessor"></highlight></codeline>
    </programlisting>
    <location file="C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/buffer.h"/>
  </compounddef>
</doxygen>
