\hypertarget{group__lavu__mem}{}\section{Memory Management}
\label{group__lavu__mem}\index{Memory Management@{Memory Management}}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{group__lavu__mem_gacd808cbec01f20997018da3e564fdd01}{D\+E\+C\+L\+A\+R\+E\+\_\+\+A\+L\+I\+G\+N\+ED}(n,  \hyperlink{octave__test_8m_aaccc9105df5383111407fd5b41255e23}{t},  v)        ~\hyperlink{octave__test_8m_aaccc9105df5383111407fd5b41255e23}{t} v
\item 
\#define \hyperlink{group__lavu__mem_gad6a6bcb1a93c42bdc22e544c23f5cdb9}{D\+E\+C\+L\+A\+R\+E\+\_\+\+A\+S\+M\+\_\+\+C\+O\+N\+ST}(n,  \hyperlink{octave__test_8m_aaccc9105df5383111407fd5b41255e23}{t},  v)    ~static \hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} \hyperlink{octave__test_8m_aaccc9105df5383111407fd5b41255e23}{t} v
\item 
\#define \hyperlink{group__lavu__mem_gad48ff724186ef4e602ae7a2547e4287c}{av\+\_\+malloc\+\_\+attrib}
\item 
\#define \hyperlink{group__lavu__mem_gad7ff928d462d1a61b37baa70bf13e0e3}{av\+\_\+alloc\+\_\+size}(...)
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$ \hyperlink{group__lavu__mem_gacbca30ebc510a7e4156d66e7aceb2dc8}{av\+\_\+malloc} (size\+\_\+t \hyperlink{group__lavu__mem_ga854352f53b148adc24983a58a1866d66}{size}) \hyperlink{group__lavu__mem_gad48ff724186ef4e602ae7a2547e4287c}{av\+\_\+malloc\+\_\+attrib} \hyperlink{group__lavu__mem_gaf3f08c4449fbe1ad6489ad59c625ac9d}{av\+\_\+alloc\+\_\+size}(1)
\item 
\hyperlink{group__lavu__mem_ga2def36a11cc8ae1d9829c26bd7c8e988}{av\+\_\+alloc\+\_\+size} (1, 2) static \hyperlink{win_2_l_a_d_s_p_a__plugins-win_2config_8h_a00d24c7231be28dbaf71f5408f30e44c}{inline} \hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$av\+\_\+malloc\+\_\+array(size\+\_\+t \hyperlink{group__lavu__mem_ga79fd723df92f68cf8a6207a1d98b4c01}{nmemb}
\item 
\hyperlink{hashrout_8h_a9842e92184417c07866419916b2b3ce3}{return} \hyperlink{group__lavu__mem_ga6a21bd3a369264e61ab7a00499621fdd}{av\+\_\+malloc} (\hyperlink{group__lavu__mem_ga79fd723df92f68cf8a6207a1d98b4c01}{nmemb} $\ast$\hyperlink{group__lavu__mem_ga854352f53b148adc24983a58a1866d66}{size})
\item 
\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$ \hyperlink{group__lavu__mem_ga74bb2298daa9cd0b5f1d0b2c1c3e26bb}{av\+\_\+realloc} (\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$ptr, size\+\_\+t \hyperlink{group__lavu__mem_ga854352f53b148adc24983a58a1866d66}{size}) \hyperlink{group__lavu__mem_gaf3f08c4449fbe1ad6489ad59c625ac9d}{av\+\_\+alloc\+\_\+size}(2)
\item 
\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$ \hyperlink{group__lavu__mem_gae5ca394e7536fcd2689008b011a211ad}{av\+\_\+realloc\+\_\+f} (\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$ptr, size\+\_\+t nelem, size\+\_\+t elsize)
\item 
\hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} \hyperlink{group__lavu__mem_ga162ac7cb3ff79ae050ccc25e57adfc46}{av\+\_\+reallocp} (\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$ptr, size\+\_\+t \hyperlink{group__lavu__mem_ga854352f53b148adc24983a58a1866d66}{size})
\item 
\hyperlink{group__lavu__mem_gaf3f08c4449fbe1ad6489ad59c625ac9d}{av\+\_\+alloc\+\_\+size} (2, 3) \hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$av\+\_\+realloc\+\_\+array(\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$ptr
\item 
\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} \hyperlink{group__lavu__mem_ga0c9096f498624c525aa2315b8a20c411}{av\+\_\+free} (\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$ptr)
\item 
\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$ \hyperlink{group__lavu__mem_gaf143ecab33a3868b57345466c39de7c1}{av\+\_\+mallocz} (size\+\_\+t \hyperlink{group__lavu__mem_ga854352f53b148adc24983a58a1866d66}{size}) \hyperlink{group__lavu__mem_gad48ff724186ef4e602ae7a2547e4287c}{av\+\_\+malloc\+\_\+attrib} \hyperlink{group__lavu__mem_gaf3f08c4449fbe1ad6489ad59c625ac9d}{av\+\_\+alloc\+\_\+size}(1)
\item 
\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$ \hyperlink{group__lavu__mem_gaaf38f6d994f5a85854ef47fd98fa6e9a}{av\+\_\+calloc} (size\+\_\+t \hyperlink{group__lavu__mem_ga79fd723df92f68cf8a6207a1d98b4c01}{nmemb}, size\+\_\+t \hyperlink{group__lavu__mem_ga854352f53b148adc24983a58a1866d66}{size}) \hyperlink{group__lavu__mem_gad48ff724186ef4e602ae7a2547e4287c}{av\+\_\+malloc\+\_\+attrib}
\item 
\hyperlink{hashrout_8h_a9842e92184417c07866419916b2b3ce3}{return} \hyperlink{group__lavu__mem_ga767be734f758e783ffb3083d88cfc612}{av\+\_\+mallocz} (\hyperlink{group__lavu__mem_ga79fd723df92f68cf8a6207a1d98b4c01}{nmemb} $\ast$\hyperlink{group__lavu__mem_ga854352f53b148adc24983a58a1866d66}{size})
\item 
char $\ast$ \hyperlink{group__lavu__mem_ga7c352f4cff02184f005323691375fea9}{av\+\_\+strdup} (\hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} char $\ast$\hyperlink{lib_2expat_8h_a755339d27872b13735c2cab829e47157}{s}) \hyperlink{group__lavu__mem_gad48ff724186ef4e602ae7a2547e4287c}{av\+\_\+malloc\+\_\+attrib}
\item 
\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$ \hyperlink{group__lavu__mem_ga4ad5e6363f4a6b6eddfdb427e21166f2}{av\+\_\+memdup} (\hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} \hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$\hyperlink{xmltok_8h_a94b60f3beb36ae85555d36dc9816769c}{p}, size\+\_\+t \hyperlink{group__lavu__mem_ga854352f53b148adc24983a58a1866d66}{size})
\item 
\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} \hyperlink{group__lavu__mem_ga0cc84043ea2167ad005c86e11d0bcdba}{av\+\_\+freep} (\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$ptr)
\item 
\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} \hyperlink{group__lavu__mem_ga385b582522cedf5a88ce2cf158c396c9}{av\+\_\+dynarray\+\_\+add} (\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$tab\+\_\+ptr, \hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} $\ast$nb\+\_\+ptr, \hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$\hyperlink{hashrout_8h_a27e2f8e58a978945d1c31db742899f21}{elem})
\item 
\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$ \hyperlink{group__lavu__mem_ga9f60ff848186092d6705276a52ea0bb9}{av\+\_\+dynarray2\+\_\+add} (\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$$\ast$tab\+\_\+ptr, \hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} $\ast$nb\+\_\+ptr, size\+\_\+t elem\+\_\+size, \hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} \hyperlink{lib-src_2ffmpeg_2win32_2stdint_8h_a9a941819355e6f658991890ff66b4b0e}{uint8\+\_\+t} $\ast$elem\+\_\+data)
\item 
\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} \hyperlink{group__lavu__mem_ga2204fc859b4a3ca2d5bfd1bf4e8c4dfb}{av\+\_\+max\+\_\+alloc} (size\+\_\+t \hyperlink{_t_d_stretch_8cpp_ac39d9cef6a5e030ba8d9e11121054268}{max})
\item 
\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} \hyperlink{group__lavu__mem_ga3ea4736dcceab4ba033b8abd2c2a180e}{av\+\_\+memcpy\+\_\+backptr} (\hyperlink{lib-src_2ffmpeg_2win32_2stdint_8h_a9a941819355e6f658991890ff66b4b0e}{uint8\+\_\+t} $\ast$dst, \hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} back, \hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} cnt)
\item 
\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$ \hyperlink{group__lavu__mem_ga869fd8884d8d29a7a4910d879926d94a}{av\+\_\+fast\+\_\+realloc} (\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$ptr, unsigned \hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} $\ast$\hyperlink{group__lavu__mem_ga854352f53b148adc24983a58a1866d66}{size}, size\+\_\+t min\+\_\+size)
\item 
\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} \hyperlink{group__lavu__mem_ga29d0252b981f157e713a68ffca52f003}{av\+\_\+fast\+\_\+malloc} (\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$ptr, unsigned \hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} $\ast$\hyperlink{group__lavu__mem_ga854352f53b148adc24983a58a1866d66}{size}, size\+\_\+t min\+\_\+size)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
size\+\_\+t \hyperlink{group__lavu__mem_ga854352f53b148adc24983a58a1866d66}{size}
\item 
size\+\_\+t \hyperlink{group__lavu__mem_ga79fd723df92f68cf8a6207a1d98b4c01}{nmemb}
\end{DoxyCompactItemize}


\subsection{Detailed Description}


\subsection{Macro Definition Documentation}
\index{Memory Management@{Memory Management}!av\+\_\+alloc\+\_\+size@{av\+\_\+alloc\+\_\+size}}
\index{av\+\_\+alloc\+\_\+size@{av\+\_\+alloc\+\_\+size}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{av\+\_\+alloc\+\_\+size}{av_alloc_size}}]{\setlength{\rightskip}{0pt plus 5cm}\#define av\+\_\+alloc\+\_\+size(
\begin{DoxyParamCaption}
\item[{}]{...}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__mem_gad7ff928d462d1a61b37baa70bf13e0e3}{}\label{group__lavu__mem_gad7ff928d462d1a61b37baa70bf13e0e3}


Definition at line 72 of file mem.\+h.

\index{Memory Management@{Memory Management}!av\+\_\+malloc\+\_\+attrib@{av\+\_\+malloc\+\_\+attrib}}
\index{av\+\_\+malloc\+\_\+attrib@{av\+\_\+malloc\+\_\+attrib}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{av\+\_\+malloc\+\_\+attrib}{av_malloc_attrib}}]{\setlength{\rightskip}{0pt plus 5cm}\#define av\+\_\+malloc\+\_\+attrib}\hypertarget{group__lavu__mem_gad48ff724186ef4e602ae7a2547e4287c}{}\label{group__lavu__mem_gad48ff724186ef4e602ae7a2547e4287c}


Definition at line 66 of file mem.\+h.

\index{Memory Management@{Memory Management}!D\+E\+C\+L\+A\+R\+E\+\_\+\+A\+L\+I\+G\+N\+ED@{D\+E\+C\+L\+A\+R\+E\+\_\+\+A\+L\+I\+G\+N\+ED}}
\index{D\+E\+C\+L\+A\+R\+E\+\_\+\+A\+L\+I\+G\+N\+ED@{D\+E\+C\+L\+A\+R\+E\+\_\+\+A\+L\+I\+G\+N\+ED}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{D\+E\+C\+L\+A\+R\+E\+\_\+\+A\+L\+I\+G\+N\+ED}{DECLARE_ALIGNED}}]{\setlength{\rightskip}{0pt plus 5cm}\#define D\+E\+C\+L\+A\+R\+E\+\_\+\+A\+L\+I\+G\+N\+ED(
\begin{DoxyParamCaption}
\item[{}]{n, }
\item[{}]{{\bf t}, }
\item[{}]{v}
\end{DoxyParamCaption}
)~{\bf t} v}\hypertarget{group__lavu__mem_gacd808cbec01f20997018da3e564fdd01}{}\label{group__lavu__mem_gacd808cbec01f20997018da3e564fdd01}


Definition at line 59 of file mem.\+h.

\index{Memory Management@{Memory Management}!D\+E\+C\+L\+A\+R\+E\+\_\+\+A\+S\+M\+\_\+\+C\+O\+N\+ST@{D\+E\+C\+L\+A\+R\+E\+\_\+\+A\+S\+M\+\_\+\+C\+O\+N\+ST}}
\index{D\+E\+C\+L\+A\+R\+E\+\_\+\+A\+S\+M\+\_\+\+C\+O\+N\+ST@{D\+E\+C\+L\+A\+R\+E\+\_\+\+A\+S\+M\+\_\+\+C\+O\+N\+ST}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{D\+E\+C\+L\+A\+R\+E\+\_\+\+A\+S\+M\+\_\+\+C\+O\+N\+ST}{DECLARE_ASM_CONST}}]{\setlength{\rightskip}{0pt plus 5cm}\#define D\+E\+C\+L\+A\+R\+E\+\_\+\+A\+S\+M\+\_\+\+C\+O\+N\+ST(
\begin{DoxyParamCaption}
\item[{}]{n, }
\item[{}]{{\bf t}, }
\item[{}]{v}
\end{DoxyParamCaption}
)~static {\bf const} {\bf t} v}\hypertarget{group__lavu__mem_gad6a6bcb1a93c42bdc22e544c23f5cdb9}{}\label{group__lavu__mem_gad6a6bcb1a93c42bdc22e544c23f5cdb9}


Definition at line 60 of file mem.\+h.



\subsection{Function Documentation}
\index{Memory Management@{Memory Management}!av\+\_\+alloc\+\_\+size@{av\+\_\+alloc\+\_\+size}}
\index{av\+\_\+alloc\+\_\+size@{av\+\_\+alloc\+\_\+size}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{av\+\_\+alloc\+\_\+size(1, 2) static inline void $\ast$av\+\_\+malloc\+\_\+array(size\+\_\+t nmemb}{av_alloc_size(1, 2) static inline void *av_malloc_array(size_t nmemb}}]{\setlength{\rightskip}{0pt plus 5cm}av\+\_\+alloc\+\_\+size (
\begin{DoxyParamCaption}
\item[{1}]{, }
\item[{2}]{}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__mem_ga2def36a11cc8ae1d9829c26bd7c8e988}{}\label{group__lavu__mem_ga2def36a11cc8ae1d9829c26bd7c8e988}
Allocate a block of size $\ast$ nmemb bytes with \hyperlink{group__lavu__mem_gacbca30ebc510a7e4156d66e7aceb2dc8}{av\+\_\+malloc()}. 
\begin{DoxyParams}{Parameters}
{\em nmemb} & Number of elements \\
\hline
{\em size} & Size of the single element \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the allocated block, N\+U\+LL if the block cannot be allocated. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__lavu__mem_gacbca30ebc510a7e4156d66e7aceb2dc8}{av\+\_\+malloc()}
\end{DoxySeeAlso}
Allocate a block of size $\ast$ nmemb bytes with \hyperlink{group__lavu__mem_gaf143ecab33a3868b57345466c39de7c1}{av\+\_\+mallocz()}. 
\begin{DoxyParams}{Parameters}
{\em nmemb} & Number of elements \\
\hline
{\em size} & Size of the single element \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the allocated block, N\+U\+LL if the block cannot be allocated. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__lavu__mem_gaf143ecab33a3868b57345466c39de7c1}{av\+\_\+mallocz()} 

av\+\_\+malloc\+\_\+array() 
\end{DoxySeeAlso}
\index{Memory Management@{Memory Management}!av\+\_\+alloc\+\_\+size@{av\+\_\+alloc\+\_\+size}}
\index{av\+\_\+alloc\+\_\+size@{av\+\_\+alloc\+\_\+size}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{av\+\_\+alloc\+\_\+size(2, 3) void $\ast$av\+\_\+realloc\+\_\+array(void $\ast$ptr}{av_alloc_size(2, 3) void *av_realloc_array(void *ptr}}]{\setlength{\rightskip}{0pt plus 5cm}av\+\_\+alloc\+\_\+size (
\begin{DoxyParamCaption}
\item[{2}]{, }
\item[{3}]{}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__mem_gaf3f08c4449fbe1ad6489ad59c625ac9d}{}\label{group__lavu__mem_gaf3f08c4449fbe1ad6489ad59c625ac9d}
Allocate or reallocate an array. If ptr is N\+U\+LL and nmemb $>$ 0, allocate a new block. If nmemb is zero, free the memory block pointed to by ptr. 
\begin{DoxyParams}{Parameters}
{\em ptr} & Pointer to a memory block already allocated with \hyperlink{group__lavu__mem_ga74bb2298daa9cd0b5f1d0b2c1c3e26bb}{av\+\_\+realloc()} or N\+U\+LL. \\
\hline
{\em nmemb} & Number of elements \\
\hline
{\em size} & Size of the single element \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to a newly-\/reallocated block or N\+U\+LL if the block cannot be reallocated or the function is used to free the memory block. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Pointers originating from the \hyperlink{group__lavu__mem_gacbca30ebc510a7e4156d66e7aceb2dc8}{av\+\_\+malloc()} family of functions must not be passed to \hyperlink{group__lavu__mem_ga74bb2298daa9cd0b5f1d0b2c1c3e26bb}{av\+\_\+realloc()}. The former can be implemented using memalign() (or other functions), and there is no guarantee that pointers from such functions can be passed to realloc() at all. The situation is undefined according to P\+O\+S\+IX and may crash with some libc implementations.
\end{DoxyWarning}
Allocate or reallocate an array through a pointer to a pointer. If $\ast$ptr is N\+U\+LL and nmemb $>$ 0, allocate a new block. If nmemb is zero, free the memory block pointed to by ptr. 
\begin{DoxyParams}{Parameters}
{\em ptr} & Pointer to a pointer to a memory block already allocated with \hyperlink{group__lavu__mem_ga74bb2298daa9cd0b5f1d0b2c1c3e26bb}{av\+\_\+realloc()}, or pointer to a pointer to N\+U\+LL. The pointer is updated on success, or freed on failure. \\
\hline
{\em nmemb} & Number of elements \\
\hline
{\em size} & Size of the single element \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Zero on success, an A\+V\+E\+R\+R\+OR error code on failure. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Pointers originating from the \hyperlink{group__lavu__mem_gacbca30ebc510a7e4156d66e7aceb2dc8}{av\+\_\+malloc()} family of functions must not be passed to \hyperlink{group__lavu__mem_ga74bb2298daa9cd0b5f1d0b2c1c3e26bb}{av\+\_\+realloc()}. The former can be implemented using memalign() (or other functions), and there is no guarantee that pointers from such functions can be passed to realloc() at all. The situation is undefined according to P\+O\+S\+IX and may crash with some libc implementations. 
\end{DoxyWarning}
\index{Memory Management@{Memory Management}!av\+\_\+calloc@{av\+\_\+calloc}}
\index{av\+\_\+calloc@{av\+\_\+calloc}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{av\+\_\+calloc(size\+\_\+t nmemb, size\+\_\+t size) av\+\_\+malloc\+\_\+attrib}{av_calloc(size_t nmemb, size_t size) av_malloc_attrib}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void}$\ast$ av\+\_\+calloc (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{nmemb, }
\item[{size\+\_\+t}]{size}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__mem_gaaf38f6d994f5a85854ef47fd98fa6e9a}{}\label{group__lavu__mem_gaaf38f6d994f5a85854ef47fd98fa6e9a}
Allocate a block of nmemb $\ast$ size bytes with alignment suitable for all memory accesses (including vectors if available on the C\+PU) and zero all the bytes of the block. The allocation will fail if nmemb $\ast$ size is greater than or equal to I\+N\+T\+\_\+\+M\+AX. 
\begin{DoxyParams}{Parameters}
{\em nmemb} & \\
\hline
{\em size} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the allocated block, N\+U\+LL if it cannot be allocated. 
\end{DoxyReturn}
\index{Memory Management@{Memory Management}!av\+\_\+dynarray2\+\_\+add@{av\+\_\+dynarray2\+\_\+add}}
\index{av\+\_\+dynarray2\+\_\+add@{av\+\_\+dynarray2\+\_\+add}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{av\+\_\+dynarray2\+\_\+add(void $\ast$$\ast$tab\+\_\+ptr, int $\ast$nb\+\_\+ptr, size\+\_\+t elem\+\_\+size, const uint8\+\_\+t $\ast$elem\+\_\+data)}{av_dynarray2_add(void **tab_ptr, int *nb_ptr, size_t elem_size, const uint8_t *elem_data)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void}$\ast$ av\+\_\+dynarray2\+\_\+add (
\begin{DoxyParamCaption}
\item[{{\bf void} $\ast$$\ast$}]{tab\+\_\+ptr, }
\item[{{\bf int} $\ast$}]{nb\+\_\+ptr, }
\item[{size\+\_\+t}]{elem\+\_\+size, }
\item[{{\bf const} {\bf uint8\+\_\+t} $\ast$}]{elem\+\_\+data}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__mem_ga9f60ff848186092d6705276a52ea0bb9}{}\label{group__lavu__mem_ga9f60ff848186092d6705276a52ea0bb9}
Add an element of size elem\+\_\+size to a dynamic array.

The array is reallocated when its number of elements reaches powers of 2. Therefore, the amortized cost of adding an element is constant.

In case of success, the pointer to the array is updated in order to point to the new grown array, and the number pointed to by nb\+\_\+ptr is incremented. In case of failure, the array is freed, $\ast$tab\+\_\+ptr is set to N\+U\+LL and $\ast$nb\+\_\+ptr is set to 0.


\begin{DoxyParams}{Parameters}
{\em tab\+\_\+ptr} & pointer to the array to grow \\
\hline
{\em nb\+\_\+ptr} & pointer to the number of elements in the array \\
\hline
{\em elem\+\_\+size} & size in bytes of the elements in the array \\
\hline
{\em elem\+\_\+data} & pointer to the data of the element to add. If N\+U\+LL, the space of the new added element is not filled. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to the data of the element to copy in the new allocated space. If N\+U\+LL, the new allocated space is left uninitialized." 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__lavu__mem_ga385b582522cedf5a88ce2cf158c396c9}{av\+\_\+dynarray\+\_\+add()} 
\end{DoxySeeAlso}
\index{Memory Management@{Memory Management}!av\+\_\+dynarray\+\_\+add@{av\+\_\+dynarray\+\_\+add}}
\index{av\+\_\+dynarray\+\_\+add@{av\+\_\+dynarray\+\_\+add}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{av\+\_\+dynarray\+\_\+add(void $\ast$tab\+\_\+ptr, int $\ast$nb\+\_\+ptr, void $\ast$elem)}{av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} av\+\_\+dynarray\+\_\+add (
\begin{DoxyParamCaption}
\item[{{\bf void} $\ast$}]{tab\+\_\+ptr, }
\item[{{\bf int} $\ast$}]{nb\+\_\+ptr, }
\item[{{\bf void} $\ast$}]{elem}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__mem_ga385b582522cedf5a88ce2cf158c396c9}{}\label{group__lavu__mem_ga385b582522cedf5a88ce2cf158c396c9}
Add an element to a dynamic array.

The array to grow is supposed to be an array of pointers to structures, and the element to add must be a pointer to an already allocated structure.

The array is reallocated when its size reaches powers of 2. Therefore, the amortized cost of adding an element is constant.

In case of success, the pointer to the array is updated in order to point to the new grown array, and the number pointed to by nb\+\_\+ptr is incremented. In case of failure, the array is freed, $\ast$tab\+\_\+ptr is set to N\+U\+LL and $\ast$nb\+\_\+ptr is set to 0.


\begin{DoxyParams}{Parameters}
{\em tab\+\_\+ptr} & pointer to the array to grow \\
\hline
{\em nb\+\_\+ptr} & pointer to the number of elements in the array \\
\hline
{\em elem} & element to add \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__lavu__mem_ga9f60ff848186092d6705276a52ea0bb9}{av\+\_\+dynarray2\+\_\+add()} 
\end{DoxySeeAlso}
\index{Memory Management@{Memory Management}!av\+\_\+fast\+\_\+malloc@{av\+\_\+fast\+\_\+malloc}}
\index{av\+\_\+fast\+\_\+malloc@{av\+\_\+fast\+\_\+malloc}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{av\+\_\+fast\+\_\+malloc(void $\ast$ptr, unsigned int $\ast$size, size\+\_\+t min\+\_\+size)}{av_fast_malloc(void *ptr, unsigned int *size, size_t min_size)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} av\+\_\+fast\+\_\+malloc (
\begin{DoxyParamCaption}
\item[{{\bf void} $\ast$}]{ptr, }
\item[{unsigned {\bf int} $\ast$}]{size, }
\item[{size\+\_\+t}]{min\+\_\+size}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__mem_ga29d0252b981f157e713a68ffca52f003}{}\label{group__lavu__mem_ga29d0252b981f157e713a68ffca52f003}
Allocate a buffer, reusing the given one if large enough.

Contrary to av\+\_\+fast\+\_\+realloc the current buffer contents might not be preserved and on error the old buffer is freed, thus no special handling to avoid memleaks is necessary.


\begin{DoxyParams}{Parameters}
{\em ptr} & pointer to pointer to already allocated buffer, overwritten with pointer to new buffer \\
\hline
{\em size} & size of the buffer $\ast$ptr points to \\
\hline
{\em min\+\_\+size} & minimum size of $\ast$ptr buffer after returning, $\ast$ptr will be N\+U\+LL and $\ast$size 0 if an error occurred. \\
\hline
\end{DoxyParams}
\index{Memory Management@{Memory Management}!av\+\_\+fast\+\_\+realloc@{av\+\_\+fast\+\_\+realloc}}
\index{av\+\_\+fast\+\_\+realloc@{av\+\_\+fast\+\_\+realloc}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{av\+\_\+fast\+\_\+realloc(void $\ast$ptr, unsigned int $\ast$size, size\+\_\+t min\+\_\+size)}{av_fast_realloc(void *ptr, unsigned int *size, size_t min_size)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void}$\ast$ av\+\_\+fast\+\_\+realloc (
\begin{DoxyParamCaption}
\item[{{\bf void} $\ast$}]{ptr, }
\item[{unsigned {\bf int} $\ast$}]{size, }
\item[{size\+\_\+t}]{min\+\_\+size}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__mem_ga869fd8884d8d29a7a4910d879926d94a}{}\label{group__lavu__mem_ga869fd8884d8d29a7a4910d879926d94a}
Reallocate the given block if it is not large enough, otherwise do nothing.

\begin{DoxySeeAlso}{See also}
\hyperlink{group__lavu__mem_ga74bb2298daa9cd0b5f1d0b2c1c3e26bb}{av\+\_\+realloc} 
\end{DoxySeeAlso}
\index{Memory Management@{Memory Management}!av\+\_\+free@{av\+\_\+free}}
\index{av\+\_\+free@{av\+\_\+free}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{av\+\_\+free(void $\ast$ptr)}{av_free(void *ptr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} av\+\_\+free (
\begin{DoxyParamCaption}
\item[{{\bf void} $\ast$}]{ptr}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__mem_ga0c9096f498624c525aa2315b8a20c411}{}\label{group__lavu__mem_ga0c9096f498624c525aa2315b8a20c411}
Free a memory block which has been allocated with av\+\_\+malloc(z)() or \hyperlink{group__lavu__mem_ga74bb2298daa9cd0b5f1d0b2c1c3e26bb}{av\+\_\+realloc()}. 
\begin{DoxyParams}{Parameters}
{\em ptr} & Pointer to the memory block which should be freed. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
ptr = N\+U\+LL is explicitly allowed. 

It is recommended that you use \hyperlink{group__lavu__mem_ga0cc84043ea2167ad005c86e11d0bcdba}{av\+\_\+freep()} instead. 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__lavu__mem_ga0cc84043ea2167ad005c86e11d0bcdba}{av\+\_\+freep()} 
\end{DoxySeeAlso}
\index{Memory Management@{Memory Management}!av\+\_\+freep@{av\+\_\+freep}}
\index{av\+\_\+freep@{av\+\_\+freep}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{av\+\_\+freep(void $\ast$ptr)}{av_freep(void *ptr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} av\+\_\+freep (
\begin{DoxyParamCaption}
\item[{{\bf void} $\ast$}]{ptr}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__mem_ga0cc84043ea2167ad005c86e11d0bcdba}{}\label{group__lavu__mem_ga0cc84043ea2167ad005c86e11d0bcdba}
Free a memory block which has been allocated with av\+\_\+malloc(z)() or \hyperlink{group__lavu__mem_ga74bb2298daa9cd0b5f1d0b2c1c3e26bb}{av\+\_\+realloc()} and set the pointer pointing to it to N\+U\+LL. 
\begin{DoxyParams}{Parameters}
{\em ptr} & Pointer to the pointer to the memory block which should be freed. \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__lavu__mem_ga0c9096f498624c525aa2315b8a20c411}{av\+\_\+free()} 
\end{DoxySeeAlso}
\index{Memory Management@{Memory Management}!av\+\_\+malloc@{av\+\_\+malloc}}
\index{av\+\_\+malloc@{av\+\_\+malloc}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{av\+\_\+malloc(size\+\_\+t size) av\+\_\+malloc\+\_\+attrib av\+\_\+alloc\+\_\+size(1)}{av_malloc(size_t size) av_malloc_attrib av_alloc_size(1)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void}$\ast$ av\+\_\+malloc (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{size}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__mem_gacbca30ebc510a7e4156d66e7aceb2dc8}{}\label{group__lavu__mem_gacbca30ebc510a7e4156d66e7aceb2dc8}
Allocate a block of size bytes with alignment suitable for all memory accesses (including vectors if available on the C\+PU). 
\begin{DoxyParams}{Parameters}
{\em size} & Size in bytes for the memory block to be allocated. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the allocated block, N\+U\+LL if the block cannot be allocated. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__lavu__mem_gaf143ecab33a3868b57345466c39de7c1}{av\+\_\+mallocz()} 
\end{DoxySeeAlso}
\index{Memory Management@{Memory Management}!av\+\_\+malloc@{av\+\_\+malloc}}
\index{av\+\_\+malloc@{av\+\_\+malloc}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{av\+\_\+malloc(nmemb $\ast$size)}{av_malloc(nmemb *size)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf return} av\+\_\+malloc (
\begin{DoxyParamCaption}
\item[{{\bf nmemb} $\ast$}]{size}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__mem_ga6a21bd3a369264e61ab7a00499621fdd}{}\label{group__lavu__mem_ga6a21bd3a369264e61ab7a00499621fdd}
\index{Memory Management@{Memory Management}!av\+\_\+mallocz@{av\+\_\+mallocz}}
\index{av\+\_\+mallocz@{av\+\_\+mallocz}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{av\+\_\+mallocz(size\+\_\+t size) av\+\_\+malloc\+\_\+attrib av\+\_\+alloc\+\_\+size(1)}{av_mallocz(size_t size) av_malloc_attrib av_alloc_size(1)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void}$\ast$ av\+\_\+mallocz (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{size}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__mem_gaf143ecab33a3868b57345466c39de7c1}{}\label{group__lavu__mem_gaf143ecab33a3868b57345466c39de7c1}
Allocate a block of size bytes with alignment suitable for all memory accesses (including vectors if available on the C\+PU) and zero all the bytes of the block. 
\begin{DoxyParams}{Parameters}
{\em size} & Size in bytes for the memory block to be allocated. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the allocated block, N\+U\+LL if it cannot be allocated. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__lavu__mem_gacbca30ebc510a7e4156d66e7aceb2dc8}{av\+\_\+malloc()} 
\end{DoxySeeAlso}
\index{Memory Management@{Memory Management}!av\+\_\+mallocz@{av\+\_\+mallocz}}
\index{av\+\_\+mallocz@{av\+\_\+mallocz}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{av\+\_\+mallocz(nmemb $\ast$size)}{av_mallocz(nmemb *size)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf return} av\+\_\+mallocz (
\begin{DoxyParamCaption}
\item[{{\bf nmemb} $\ast$}]{size}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__mem_ga767be734f758e783ffb3083d88cfc612}{}\label{group__lavu__mem_ga767be734f758e783ffb3083d88cfc612}
\index{Memory Management@{Memory Management}!av\+\_\+max\+\_\+alloc@{av\+\_\+max\+\_\+alloc}}
\index{av\+\_\+max\+\_\+alloc@{av\+\_\+max\+\_\+alloc}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{av\+\_\+max\+\_\+alloc(size\+\_\+t max)}{av_max_alloc(size_t max)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} av\+\_\+max\+\_\+alloc (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{max}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__mem_ga2204fc859b4a3ca2d5bfd1bf4e8c4dfb}{}\label{group__lavu__mem_ga2204fc859b4a3ca2d5bfd1bf4e8c4dfb}
Set the maximum size that may me allocated in one block. \index{Memory Management@{Memory Management}!av\+\_\+memcpy\+\_\+backptr@{av\+\_\+memcpy\+\_\+backptr}}
\index{av\+\_\+memcpy\+\_\+backptr@{av\+\_\+memcpy\+\_\+backptr}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{av\+\_\+memcpy\+\_\+backptr(uint8\+\_\+t $\ast$dst, int back, int cnt)}{av_memcpy_backptr(uint8_t *dst, int back, int cnt)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} av\+\_\+memcpy\+\_\+backptr (
\begin{DoxyParamCaption}
\item[{{\bf uint8\+\_\+t} $\ast$}]{dst, }
\item[{{\bf int}}]{back, }
\item[{{\bf int}}]{cnt}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__mem_ga3ea4736dcceab4ba033b8abd2c2a180e}{}\label{group__lavu__mem_ga3ea4736dcceab4ba033b8abd2c2a180e}
deliberately overlapping memcpy implementation 
\begin{DoxyParams}{Parameters}
{\em dst} & destination buffer \\
\hline
{\em back} & how many bytes back we start (the initial size of the overlapping window), must be $>$ 0 \\
\hline
{\em cnt} & number of bytes to copy, must be $>$= 0\\
\hline
\end{DoxyParams}
cnt $>$ back is valid, this will copy the bytes we just copied, thus creating a repeating pattern with a period length of back. \index{Memory Management@{Memory Management}!av\+\_\+memdup@{av\+\_\+memdup}}
\index{av\+\_\+memdup@{av\+\_\+memdup}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{av\+\_\+memdup(const void $\ast$p, size\+\_\+t size)}{av_memdup(const void *p, size_t size)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void}$\ast$ av\+\_\+memdup (
\begin{DoxyParamCaption}
\item[{{\bf const} {\bf void} $\ast$}]{p, }
\item[{size\+\_\+t}]{size}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__mem_ga4ad5e6363f4a6b6eddfdb427e21166f2}{}\label{group__lavu__mem_ga4ad5e6363f4a6b6eddfdb427e21166f2}
Duplicate the buffer p. 
\begin{DoxyParams}{Parameters}
{\em p} & buffer to be duplicated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to a newly allocated buffer containing a copy of p or N\+U\+LL if the buffer cannot be allocated. 
\end{DoxyReturn}
\index{Memory Management@{Memory Management}!av\+\_\+realloc@{av\+\_\+realloc}}
\index{av\+\_\+realloc@{av\+\_\+realloc}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{av\+\_\+realloc(void $\ast$ptr, size\+\_\+t size) av\+\_\+alloc\+\_\+size(2)}{av_realloc(void *ptr, size_t size) av_alloc_size(2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void}$\ast$ av\+\_\+realloc (
\begin{DoxyParamCaption}
\item[{{\bf void} $\ast$}]{ptr, }
\item[{size\+\_\+t}]{size}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__mem_ga74bb2298daa9cd0b5f1d0b2c1c3e26bb}{}\label{group__lavu__mem_ga74bb2298daa9cd0b5f1d0b2c1c3e26bb}
Allocate or reallocate a block of memory. If ptr is N\+U\+LL and size $>$ 0, allocate a new block. If size is zero, free the memory block pointed to by ptr. 
\begin{DoxyParams}{Parameters}
{\em ptr} & Pointer to a memory block already allocated with \hyperlink{group__lavu__mem_ga74bb2298daa9cd0b5f1d0b2c1c3e26bb}{av\+\_\+realloc()} or N\+U\+LL. \\
\hline
{\em size} & Size in bytes of the memory block to be allocated or reallocated. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to a newly-\/reallocated block or N\+U\+LL if the block cannot be reallocated or the function is used to free the memory block. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Pointers originating from the \hyperlink{group__lavu__mem_gacbca30ebc510a7e4156d66e7aceb2dc8}{av\+\_\+malloc()} family of functions must not be passed to \hyperlink{group__lavu__mem_ga74bb2298daa9cd0b5f1d0b2c1c3e26bb}{av\+\_\+realloc()}. The former can be implemented using memalign() (or other functions), and there is no guarantee that pointers from such functions can be passed to realloc() at all. The situation is undefined according to P\+O\+S\+IX and may crash with some libc implementations. 
\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__lavu__mem_ga869fd8884d8d29a7a4910d879926d94a}{av\+\_\+fast\+\_\+realloc()} 
\end{DoxySeeAlso}
\index{Memory Management@{Memory Management}!av\+\_\+realloc\+\_\+f@{av\+\_\+realloc\+\_\+f}}
\index{av\+\_\+realloc\+\_\+f@{av\+\_\+realloc\+\_\+f}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{av\+\_\+realloc\+\_\+f(void $\ast$ptr, size\+\_\+t nelem, size\+\_\+t elsize)}{av_realloc_f(void *ptr, size_t nelem, size_t elsize)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void}$\ast$ av\+\_\+realloc\+\_\+f (
\begin{DoxyParamCaption}
\item[{{\bf void} $\ast$}]{ptr, }
\item[{size\+\_\+t}]{nelem, }
\item[{size\+\_\+t}]{elsize}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__mem_gae5ca394e7536fcd2689008b011a211ad}{}\label{group__lavu__mem_gae5ca394e7536fcd2689008b011a211ad}
Allocate or reallocate a block of memory. This function does the same thing as av\+\_\+realloc, except\+:
\begin{DoxyItemize}
\item It takes two arguments and checks the result of the multiplication for integer overflow.
\item It frees the input block in case of failure, thus avoiding the memory leak with the classic \char`\"{}buf = realloc(buf); if (!buf) return -\/1;\char`\"{}. 
\end{DoxyItemize}\index{Memory Management@{Memory Management}!av\+\_\+reallocp@{av\+\_\+reallocp}}
\index{av\+\_\+reallocp@{av\+\_\+reallocp}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{av\+\_\+reallocp(void $\ast$ptr, size\+\_\+t size)}{av_reallocp(void *ptr, size_t size)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf int} av\+\_\+reallocp (
\begin{DoxyParamCaption}
\item[{{\bf void} $\ast$}]{ptr, }
\item[{size\+\_\+t}]{size}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__mem_ga162ac7cb3ff79ae050ccc25e57adfc46}{}\label{group__lavu__mem_ga162ac7cb3ff79ae050ccc25e57adfc46}
Allocate or reallocate a block of memory. If $\ast$ptr is N\+U\+LL and size $>$ 0, allocate a new block. If size is zero, free the memory block pointed to by ptr. 
\begin{DoxyParams}{Parameters}
{\em ptr} & Pointer to a pointer to a memory block already allocated with \hyperlink{group__lavu__mem_ga74bb2298daa9cd0b5f1d0b2c1c3e26bb}{av\+\_\+realloc()}, or pointer to a pointer to N\+U\+LL. The pointer is updated on success, or freed on failure. \\
\hline
{\em size} & Size in bytes for the memory block to be allocated or reallocated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Zero on success, an A\+V\+E\+R\+R\+OR error code on failure. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Pointers originating from the \hyperlink{group__lavu__mem_gacbca30ebc510a7e4156d66e7aceb2dc8}{av\+\_\+malloc()} family of functions must not be passed to \hyperlink{group__lavu__mem_ga162ac7cb3ff79ae050ccc25e57adfc46}{av\+\_\+reallocp()}. The former can be implemented using memalign() (or other functions), and there is no guarantee that pointers from such functions can be passed to realloc() at all. The situation is undefined according to P\+O\+S\+IX and may crash with some libc implementations. 
\end{DoxyWarning}
\index{Memory Management@{Memory Management}!av\+\_\+strdup@{av\+\_\+strdup}}
\index{av\+\_\+strdup@{av\+\_\+strdup}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{av\+\_\+strdup(const char $\ast$s) av\+\_\+malloc\+\_\+attrib}{av_strdup(const char *s) av_malloc_attrib}}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ av\+\_\+strdup (
\begin{DoxyParamCaption}
\item[{{\bf const} char $\ast$}]{s}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__mem_ga7c352f4cff02184f005323691375fea9}{}\label{group__lavu__mem_ga7c352f4cff02184f005323691375fea9}
Duplicate the string s. 
\begin{DoxyParams}{Parameters}
{\em s} & string to be duplicated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to a newly-\/allocated string containing a copy of s or N\+U\+LL if the string cannot be allocated. 
\end{DoxyReturn}


\subsection{Variable Documentation}
\index{Memory Management@{Memory Management}!nmemb@{nmemb}}
\index{nmemb@{nmemb}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{nmemb}{nmemb}}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t nmemb}\hypertarget{group__lavu__mem_ga79fd723df92f68cf8a6207a1d98b4c01}{}\label{group__lavu__mem_ga79fd723df92f68cf8a6207a1d98b4c01}


Definition at line 166 of file mem.\+h.

\index{Memory Management@{Memory Management}!size@{size}}
\index{size@{size}!Memory Management@{Memory Management}}
\subsubsection[{\texorpdfstring{size}{size}}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t size}\hypertarget{group__lavu__mem_ga854352f53b148adc24983a58a1866d66}{}\label{group__lavu__mem_ga854352f53b148adc24983a58a1866d66}
{\bfseries Initial value\+:}
\begin{DoxyCode}
\{
    \textcolor{keywordflow}{if} (!\hyperlink{group__lavu__mem_ga854352f53b148adc24983a58a1866d66}{size} || \hyperlink{group__lavu__mem_ga79fd723df92f68cf8a6207a1d98b4c01}{nmemb} >= \hyperlink{macint_8h_a9ec306f36d50c7375e74f0d1c55a3a67}{INT\_MAX} / \hyperlink{group__lavu__mem_ga854352f53b148adc24983a58a1866d66}{size})
        \textcolor{keywordflow}{return} \hyperlink{getopt1_8c_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}
\end{DoxyCode}


Definition at line 94 of file mem.\+h.

