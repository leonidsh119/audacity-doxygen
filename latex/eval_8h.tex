\hypertarget{eval_8h}{}\section{C\+:/\+\_\+dev/\+Open\+U/\+Audacity/audacity/lib-\/src/ffmpeg/libavutil/eval.h File Reference}
\label{eval_8h}\index{C\+:/\+\_\+dev/\+Open\+U/\+Audacity/audacity/lib-\/src/ffmpeg/libavutil/eval.\+h@{C\+:/\+\_\+dev/\+Open\+U/\+Audacity/audacity/lib-\/src/ffmpeg/libavutil/eval.\+h}}
{\ttfamily \#include \char`\"{}avutil.\+h\char`\"{}}\\*
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \hyperlink{eval_8h_ac09a495d176de152a38347ca8ba069a8}{A\+V\+Expr} \hyperlink{eval_8h_ac09a495d176de152a38347ca8ba069a8}{A\+V\+Expr}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} \hyperlink{eval_8h_a2d19271d518d49f3cb2df8c347856b18}{av\+\_\+expr\+\_\+parse\+\_\+and\+\_\+eval} (double $\ast$res, \hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} char $\ast$\hyperlink{lib_2expat_8h_a755339d27872b13735c2cab829e47157}{s}, \hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} char $\ast$\hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} $\ast$const\+\_\+names, \hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} double $\ast$const\+\_\+values, \hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} char $\ast$\hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} $\ast$func1\+\_\+names, double($\ast$\hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} $\ast$funcs1)(\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$, double), \hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} char $\ast$\hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} $\ast$func2\+\_\+names, double($\ast$\hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} $\ast$funcs2)(\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$, double, double), \hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$opaque, \hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} log\+\_\+offset, \hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$log\+\_\+ctx)
\item 
\hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} \hyperlink{eval_8h_ad3bf8f3330d1fd139de2ca156c313f34}{av\+\_\+expr\+\_\+parse} (\hyperlink{eval_8h_ac09a495d176de152a38347ca8ba069a8}{A\+V\+Expr} $\ast$$\ast$expr, \hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} char $\ast$\hyperlink{lib_2expat_8h_a755339d27872b13735c2cab829e47157}{s}, \hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} char $\ast$\hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} $\ast$const\+\_\+names, \hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} char $\ast$\hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} $\ast$func1\+\_\+names, double($\ast$\hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} $\ast$funcs1)(\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$, double), \hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} char $\ast$\hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} $\ast$func2\+\_\+names, double($\ast$\hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} $\ast$funcs2)(\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$, double, double), \hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} log\+\_\+offset, \hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$log\+\_\+ctx)
\item 
double \hyperlink{eval_8h_a569b6171b99e02f899d9ba8b5545cc27}{av\+\_\+expr\+\_\+eval} (\hyperlink{eval_8h_ac09a495d176de152a38347ca8ba069a8}{A\+V\+Expr} $\ast$e, \hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} double $\ast$const\+\_\+values, \hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$opaque)
\item 
\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} \hyperlink{eval_8h_a01c05d7049a9208c2b22147a3f16c58c}{av\+\_\+expr\+\_\+free} (\hyperlink{eval_8h_ac09a495d176de152a38347ca8ba069a8}{A\+V\+Expr} $\ast$e)
\item 
double \hyperlink{eval_8h_a7d21905c92ee5af0bb529d2daf8cb7c3}{av\+\_\+strtod} (\hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} char $\ast$numstr, char $\ast$$\ast$tail)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
simple arithmetic expression evaluator 

\subsection{Typedef Documentation}
\index{eval.\+h@{eval.\+h}!A\+V\+Expr@{A\+V\+Expr}}
\index{A\+V\+Expr@{A\+V\+Expr}!eval.\+h@{eval.\+h}}
\subsubsection[{\texorpdfstring{A\+V\+Expr}{AVExpr}}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf A\+V\+Expr} {\bf A\+V\+Expr}}\hypertarget{eval_8h_ac09a495d176de152a38347ca8ba069a8}{}\label{eval_8h_ac09a495d176de152a38347ca8ba069a8}


Definition at line 31 of file eval.\+h.



\subsection{Function Documentation}
\index{eval.\+h@{eval.\+h}!av\+\_\+expr\+\_\+eval@{av\+\_\+expr\+\_\+eval}}
\index{av\+\_\+expr\+\_\+eval@{av\+\_\+expr\+\_\+eval}!eval.\+h@{eval.\+h}}
\subsubsection[{\texorpdfstring{av\+\_\+expr\+\_\+eval(\+A\+V\+Expr $\ast$e, const double $\ast$const\+\_\+values, void $\ast$opaque)}{av_expr_eval(AVExpr *e, const double *const_values, void *opaque)}}]{\setlength{\rightskip}{0pt plus 5cm}double av\+\_\+expr\+\_\+eval (
\begin{DoxyParamCaption}
\item[{{\bf A\+V\+Expr} $\ast$}]{e, }
\item[{{\bf const} double $\ast$}]{const\+\_\+values, }
\item[{{\bf void} $\ast$}]{opaque}
\end{DoxyParamCaption}
)}\hypertarget{eval_8h_a569b6171b99e02f899d9ba8b5545cc27}{}\label{eval_8h_a569b6171b99e02f899d9ba8b5545cc27}
Evaluate a previously parsed expression.


\begin{DoxyParams}{Parameters}
{\em const\+\_\+values} & a zero terminated array of values for the identifiers from \hyperlink{eval_8h_ad3bf8f3330d1fd139de2ca156c313f34}{av\+\_\+expr\+\_\+parse()} const\+\_\+names \\
\hline
{\em opaque} & a pointer which will be passed to all functions from funcs1 and funcs2 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the value of the expression 
\end{DoxyReturn}
\index{eval.\+h@{eval.\+h}!av\+\_\+expr\+\_\+free@{av\+\_\+expr\+\_\+free}}
\index{av\+\_\+expr\+\_\+free@{av\+\_\+expr\+\_\+free}!eval.\+h@{eval.\+h}}
\subsubsection[{\texorpdfstring{av\+\_\+expr\+\_\+free(\+A\+V\+Expr $\ast$e)}{av_expr_free(AVExpr *e)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} av\+\_\+expr\+\_\+free (
\begin{DoxyParamCaption}
\item[{{\bf A\+V\+Expr} $\ast$}]{e}
\end{DoxyParamCaption}
)}\hypertarget{eval_8h_a01c05d7049a9208c2b22147a3f16c58c}{}\label{eval_8h_a01c05d7049a9208c2b22147a3f16c58c}
Free a parsed expression previously created with \hyperlink{eval_8h_ad3bf8f3330d1fd139de2ca156c313f34}{av\+\_\+expr\+\_\+parse()}. \index{eval.\+h@{eval.\+h}!av\+\_\+expr\+\_\+parse@{av\+\_\+expr\+\_\+parse}}
\index{av\+\_\+expr\+\_\+parse@{av\+\_\+expr\+\_\+parse}!eval.\+h@{eval.\+h}}
\subsubsection[{\texorpdfstring{av\+\_\+expr\+\_\+parse(\+A\+V\+Expr $\ast$$\ast$expr, const char $\ast$s, const char $\ast$const $\ast$const\+\_\+names, const char $\ast$const $\ast$func1\+\_\+names, double($\ast$const $\ast$funcs1)(void $\ast$, double), const char $\ast$const $\ast$func2\+\_\+names, double($\ast$const $\ast$funcs2)(void $\ast$, double, double), int log\+\_\+offset, void $\ast$log\+\_\+ctx)}{av_expr_parse(AVExpr **expr, const char *s, const char *const *const_names, const char *const *func1_names, double(*const *funcs1)(void *, double), const char *const *func2_names, double(*const *funcs2)(void *, double, double), int log_offset, void *log_ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf int} av\+\_\+expr\+\_\+parse (
\begin{DoxyParamCaption}
\item[{{\bf A\+V\+Expr} $\ast$$\ast$}]{expr, }
\item[{{\bf const} char $\ast$}]{s, }
\item[{{\bf const} char $\ast${\bf const} $\ast$}]{const\+\_\+names, }
\item[{{\bf const} char $\ast${\bf const} $\ast$}]{func1\+\_\+names, }
\item[{double($\ast$$\ast$)({\bf void} $\ast$, double)}]{funcs1, }
\item[{{\bf const} char $\ast${\bf const} $\ast$}]{func2\+\_\+names, }
\item[{double($\ast$$\ast$)({\bf void} $\ast$, double, double)}]{funcs2, }
\item[{{\bf int}}]{log\+\_\+offset, }
\item[{{\bf void} $\ast$}]{log\+\_\+ctx}
\end{DoxyParamCaption}
)}\hypertarget{eval_8h_ad3bf8f3330d1fd139de2ca156c313f34}{}\label{eval_8h_ad3bf8f3330d1fd139de2ca156c313f34}
Parse an expression.


\begin{DoxyParams}{Parameters}
{\em expr} & a pointer where is put an A\+V\+Expr containing the parsed value in case of successful parsing, or N\+U\+LL otherwise. The pointed to A\+V\+Expr must be freed with \hyperlink{eval_8h_a01c05d7049a9208c2b22147a3f16c58c}{av\+\_\+expr\+\_\+free()} by the user when it is not needed anymore. \\
\hline
{\em s} & expression as a zero terminated string, for example \char`\"{}1+2$^\wedge$3+5$\ast$5+sin(2/3)\char`\"{} \\
\hline
{\em const\+\_\+names} & N\+U\+LL terminated array of zero terminated strings of constant identifiers, for example \{\char`\"{}\+P\+I\char`\"{}, \char`\"{}\+E\char`\"{}, 0\} \\
\hline
{\em func1\+\_\+names} & N\+U\+LL terminated array of zero terminated strings of funcs1 identifiers \\
\hline
{\em funcs1} & N\+U\+LL terminated array of function pointers for functions which take 1 argument \\
\hline
{\em func2\+\_\+names} & N\+U\+LL terminated array of zero terminated strings of funcs2 identifiers \\
\hline
{\em funcs2} & N\+U\+LL terminated array of function pointers for functions which take 2 arguments \\
\hline
{\em log\+\_\+ctx} & parent logging context \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
$>$= 0 in case of success, a negative value corresponding to an A\+V\+E\+R\+R\+OR code otherwise 
\end{DoxyReturn}
\index{eval.\+h@{eval.\+h}!av\+\_\+expr\+\_\+parse\+\_\+and\+\_\+eval@{av\+\_\+expr\+\_\+parse\+\_\+and\+\_\+eval}}
\index{av\+\_\+expr\+\_\+parse\+\_\+and\+\_\+eval@{av\+\_\+expr\+\_\+parse\+\_\+and\+\_\+eval}!eval.\+h@{eval.\+h}}
\subsubsection[{\texorpdfstring{av\+\_\+expr\+\_\+parse\+\_\+and\+\_\+eval(double $\ast$res, const char $\ast$s, const char $\ast$const $\ast$const\+\_\+names, const double $\ast$const\+\_\+values, const char $\ast$const $\ast$func1\+\_\+names, double($\ast$const $\ast$funcs1)(void $\ast$, double), const char $\ast$const $\ast$func2\+\_\+names, double($\ast$const $\ast$funcs2)(void $\ast$, double, double), void $\ast$opaque, int log\+\_\+offset, void $\ast$log\+\_\+ctx)}{av_expr_parse_and_eval(double *res, const char *s, const char *const *const_names, const double *const_values, const char *const *func1_names, double(*const *funcs1)(void *, double), const char *const *func2_names, double(*const *funcs2)(void *, double, double), void *opaque, int log_offset, void *log_ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf int} av\+\_\+expr\+\_\+parse\+\_\+and\+\_\+eval (
\begin{DoxyParamCaption}
\item[{double $\ast$}]{res, }
\item[{{\bf const} char $\ast$}]{s, }
\item[{{\bf const} char $\ast${\bf const} $\ast$}]{const\+\_\+names, }
\item[{{\bf const} double $\ast$}]{const\+\_\+values, }
\item[{{\bf const} char $\ast${\bf const} $\ast$}]{func1\+\_\+names, }
\item[{double($\ast$$\ast$)({\bf void} $\ast$, double)}]{funcs1, }
\item[{{\bf const} char $\ast${\bf const} $\ast$}]{func2\+\_\+names, }
\item[{double($\ast$$\ast$)({\bf void} $\ast$, double, double)}]{funcs2, }
\item[{{\bf void} $\ast$}]{opaque, }
\item[{{\bf int}}]{log\+\_\+offset, }
\item[{{\bf void} $\ast$}]{log\+\_\+ctx}
\end{DoxyParamCaption}
)}\hypertarget{eval_8h_a2d19271d518d49f3cb2df8c347856b18}{}\label{eval_8h_a2d19271d518d49f3cb2df8c347856b18}
Parse and evaluate an expression. Note, this is significantly slower than \hyperlink{eval_8h_a569b6171b99e02f899d9ba8b5545cc27}{av\+\_\+expr\+\_\+eval()}.


\begin{DoxyParams}{Parameters}
{\em res} & a pointer to a double where is put the result value of the expression, or N\+AN in case of error \\
\hline
{\em s} & expression as a zero terminated string, for example \char`\"{}1+2$^\wedge$3+5$\ast$5+sin(2/3)\char`\"{} \\
\hline
{\em const\+\_\+names} & N\+U\+LL terminated array of zero terminated strings of constant identifiers, for example \{\char`\"{}\+P\+I\char`\"{}, \char`\"{}\+E\char`\"{}, 0\} \\
\hline
{\em const\+\_\+values} & a zero terminated array of values for the identifiers from const\+\_\+names \\
\hline
{\em func1\+\_\+names} & N\+U\+LL terminated array of zero terminated strings of funcs1 identifiers \\
\hline
{\em funcs1} & N\+U\+LL terminated array of function pointers for functions which take 1 argument \\
\hline
{\em func2\+\_\+names} & N\+U\+LL terminated array of zero terminated strings of funcs2 identifiers \\
\hline
{\em funcs2} & N\+U\+LL terminated array of function pointers for functions which take 2 arguments \\
\hline
{\em opaque} & a pointer which will be passed to all functions from funcs1 and funcs2 \\
\hline
{\em log\+\_\+ctx} & parent logging context \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
$>$= 0 in case of success, a negative value corresponding to an A\+V\+E\+R\+R\+OR code otherwise 
\end{DoxyReturn}
\index{eval.\+h@{eval.\+h}!av\+\_\+strtod@{av\+\_\+strtod}}
\index{av\+\_\+strtod@{av\+\_\+strtod}!eval.\+h@{eval.\+h}}
\subsubsection[{\texorpdfstring{av\+\_\+strtod(const char $\ast$numstr, char $\ast$$\ast$tail)}{av_strtod(const char *numstr, char **tail)}}]{\setlength{\rightskip}{0pt plus 5cm}double av\+\_\+strtod (
\begin{DoxyParamCaption}
\item[{{\bf const} char $\ast$}]{numstr, }
\item[{char $\ast$$\ast$}]{tail}
\end{DoxyParamCaption}
)}\hypertarget{eval_8h_a7d21905c92ee5af0bb529d2daf8cb7c3}{}\label{eval_8h_a7d21905c92ee5af0bb529d2daf8cb7c3}
Parse the string in numstr and return its value as a double. If the string is empty, contains only whitespaces, or does not contain an initial substring that has the expected syntax for a floating-\/point number, no conversion is performed. In this case, returns a value of zero and the value returned in tail is the value of numstr.


\begin{DoxyParams}{Parameters}
{\em numstr} & a string representing a number, may contain one of the International System number postfixes, for example \textquotesingle{}K\textquotesingle{}, \textquotesingle{}M\textquotesingle{}, \textquotesingle{}G\textquotesingle{}. If \textquotesingle{}i\textquotesingle{} is appended after the postfix, powers of 2 are used instead of powers of 10. The \textquotesingle{}B\textquotesingle{} postfix multiplies the value for 8, and can be appended after another postfix or used alone. This allows using for example \textquotesingle{}KB\textquotesingle{}, \textquotesingle{}MiB\textquotesingle{}, \textquotesingle{}G\textquotesingle{} and \textquotesingle{}B\textquotesingle{} as postfix. \\
\hline
{\em tail} & if non-\/\+N\+U\+LL puts here the pointer to the char next after the last parsed character \\
\hline
\end{DoxyParams}
