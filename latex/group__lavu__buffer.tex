\hypertarget{group__lavu__buffer}{}\section{A\+V\+Buffer}
\label{group__lavu__buffer}\index{A\+V\+Buffer@{A\+V\+Buffer}}
\subsection*{Files}
\begin{DoxyCompactItemize}
\item 
file \hyperlink{ffmpeg_2libavutil_2buffer_8h}{buffer.\+h}
\end{DoxyCompactItemize}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{struct_a_v_buffer_ref}{A\+V\+Buffer\+Ref}
\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{group__lavu__buffer_gaa818f8f1011d69acc50c1f29cb85e576}{A\+V\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+F\+L\+A\+G\+\_\+\+R\+E\+A\+D\+O\+N\+LY}~(1 $<$$<$ 0)
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \hyperlink{group__lavu__buffer_ga501d49df442180d584f255aa97b2549d}{A\+V\+Buffer} \hyperlink{group__lavu__buffer_ga501d49df442180d584f255aa97b2549d}{A\+V\+Buffer}
\item 
typedef struct \hyperlink{struct_a_v_buffer_ref}{A\+V\+Buffer\+Ref} \hyperlink{group__lavu__buffer_ga433e680d11ad786bd1bc20f5616c7d19}{A\+V\+Buffer\+Ref}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{struct_a_v_buffer_ref}{A\+V\+Buffer\+Ref} $\ast$ \hyperlink{group__lavu__buffer_ga5ae84ac902283dea1a660ede06c1cdac}{av\+\_\+buffer\+\_\+alloc} (\hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} \hyperlink{group__lavu__mem_ga854352f53b148adc24983a58a1866d66}{size})
\item 
\hyperlink{struct_a_v_buffer_ref}{A\+V\+Buffer\+Ref} $\ast$ \hyperlink{group__lavu__buffer_ga27f37cc004f768b00442b6cb08091686}{av\+\_\+buffer\+\_\+allocz} (\hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} \hyperlink{group__lavu__mem_ga854352f53b148adc24983a58a1866d66}{size})
\item 
\hyperlink{struct_a_v_buffer_ref}{A\+V\+Buffer\+Ref} $\ast$ \hyperlink{group__lavu__buffer_ga3e7f4c92db85ccba0b2a16dd0069842a}{av\+\_\+buffer\+\_\+create} (\hyperlink{lib-src_2ffmpeg_2win32_2stdint_8h_a9a941819355e6f658991890ff66b4b0e}{uint8\+\_\+t} $\ast$\hyperlink{lib_2expat_8h_ac39e72a1de1cb50dbdc54b08d0432a24}{data}, \hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} \hyperlink{group__lavu__mem_ga854352f53b148adc24983a58a1866d66}{size}, \hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void}($\ast$free)(\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$opaque, \hyperlink{lib-src_2ffmpeg_2win32_2stdint_8h_a9a941819355e6f658991890ff66b4b0e}{uint8\+\_\+t} $\ast$\hyperlink{lib_2expat_8h_ac39e72a1de1cb50dbdc54b08d0432a24}{data}), \hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$opaque, \hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} flags)
\item 
\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} \hyperlink{group__lavu__buffer_ga37d620e8cfc9f2f3261c2b4c5d4adfe0}{av\+\_\+buffer\+\_\+default\+\_\+free} (\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$opaque, \hyperlink{lib-src_2ffmpeg_2win32_2stdint_8h_a9a941819355e6f658991890ff66b4b0e}{uint8\+\_\+t} $\ast$\hyperlink{lib_2expat_8h_ac39e72a1de1cb50dbdc54b08d0432a24}{data})
\item 
\hyperlink{struct_a_v_buffer_ref}{A\+V\+Buffer\+Ref} $\ast$ \hyperlink{group__lavu__buffer_gaa40ce7d3ede946a89d03323bbd7268c1}{av\+\_\+buffer\+\_\+ref} (\hyperlink{struct_a_v_buffer_ref}{A\+V\+Buffer\+Ref} $\ast$\hyperlink{xlstr_8c_a781718f5b53a876fe91c424c4607fa8f}{buf})
\item 
\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} \hyperlink{group__lavu__buffer_ga135e9e929b5033bb8f68322497b2effc}{av\+\_\+buffer\+\_\+unref} (\hyperlink{struct_a_v_buffer_ref}{A\+V\+Buffer\+Ref} $\ast$$\ast$\hyperlink{xlstr_8c_a781718f5b53a876fe91c424c4607fa8f}{buf})
\item 
\hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} \hyperlink{group__lavu__buffer_ga060be34ace567ae378fd0a786e847053}{av\+\_\+buffer\+\_\+is\+\_\+writable} (\hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} \hyperlink{struct_a_v_buffer_ref}{A\+V\+Buffer\+Ref} $\ast$\hyperlink{xlstr_8c_a781718f5b53a876fe91c424c4607fa8f}{buf})
\item 
\hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$ \hyperlink{group__lavu__buffer_gac1c38f469fc9933885cfffafd8cbf0d6}{av\+\_\+buffer\+\_\+get\+\_\+opaque} (\hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} \hyperlink{struct_a_v_buffer_ref}{A\+V\+Buffer\+Ref} $\ast$\hyperlink{xlstr_8c_a781718f5b53a876fe91c424c4607fa8f}{buf})
\item 
\hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} \hyperlink{group__lavu__buffer_ga7b16c3976dc555f71d0843bbd023dfcd}{av\+\_\+buffer\+\_\+get\+\_\+ref\+\_\+count} (\hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} \hyperlink{struct_a_v_buffer_ref}{A\+V\+Buffer\+Ref} $\ast$\hyperlink{xlstr_8c_a781718f5b53a876fe91c424c4607fa8f}{buf})
\item 
\hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} \hyperlink{group__lavu__buffer_ga9c2a1be1b7bb80eec8613fdb62a19074}{av\+\_\+buffer\+\_\+make\+\_\+writable} (\hyperlink{struct_a_v_buffer_ref}{A\+V\+Buffer\+Ref} $\ast$$\ast$\hyperlink{xlstr_8c_a781718f5b53a876fe91c424c4607fa8f}{buf})
\item 
\hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} \hyperlink{group__lavu__buffer_gac7c228f9ed54e246dcd270503bed7291}{av\+\_\+buffer\+\_\+realloc} (\hyperlink{struct_a_v_buffer_ref}{A\+V\+Buffer\+Ref} $\ast$$\ast$\hyperlink{xlstr_8c_a781718f5b53a876fe91c424c4607fa8f}{buf}, \hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} \hyperlink{group__lavu__mem_ga854352f53b148adc24983a58a1866d66}{size})
\end{DoxyCompactItemize}


\subsection{Detailed Description}
A\+V\+Buffer is an A\+PI for reference-\/counted data buffers.

There are two core objects in this A\+PI -- A\+V\+Buffer and \hyperlink{struct_a_v_buffer_ref}{A\+V\+Buffer\+Ref}. A\+V\+Buffer represents the data buffer itself; it is opaque and not meant to be accessed by the caller directly, but only through \hyperlink{struct_a_v_buffer_ref}{A\+V\+Buffer\+Ref}. However, the caller may e.\+g. compare two A\+V\+Buffer pointers to check whether two different references are describing the same data buffer. \hyperlink{struct_a_v_buffer_ref}{A\+V\+Buffer\+Ref} represents a single reference to an A\+V\+Buffer and it is the object that may be manipulated by the caller directly.

There are two functions provided for creating a new A\+V\+Buffer with a single reference -- \hyperlink{group__lavu__buffer_ga5ae84ac902283dea1a660ede06c1cdac}{av\+\_\+buffer\+\_\+alloc()} to just allocate a new buffer, and \hyperlink{group__lavu__buffer_ga3e7f4c92db85ccba0b2a16dd0069842a}{av\+\_\+buffer\+\_\+create()} to wrap an existing array in an A\+V\+Buffer. From an existing reference, additional references may be created with \hyperlink{group__lavu__buffer_gaa40ce7d3ede946a89d03323bbd7268c1}{av\+\_\+buffer\+\_\+ref()}. Use \hyperlink{group__lavu__buffer_ga135e9e929b5033bb8f68322497b2effc}{av\+\_\+buffer\+\_\+unref()} to free a reference (this will automatically free the data once all the references are freed).

The convention throughout this A\+PI and the rest of F\+Fmpeg is such that the buffer is considered writable if there exists only one reference to it (and it has not been marked as read-\/only). The \hyperlink{group__lavu__buffer_ga060be34ace567ae378fd0a786e847053}{av\+\_\+buffer\+\_\+is\+\_\+writable()} function is provided to check whether this is true and \hyperlink{group__lavu__buffer_ga9c2a1be1b7bb80eec8613fdb62a19074}{av\+\_\+buffer\+\_\+make\+\_\+writable()} will automatically create a new writable buffer when necessary. Of course nothing prevents the calling code from violating this convention, however that is safe only when all the existing references are under its control.

\begin{DoxyNote}{Note}
Referencing and unreferencing the buffers is thread-\/safe and thus may be done from multiple threads simultaneously without any need for additional locking.

Two different references to the same buffer can point to different parts of the buffer (i.\+e. their \hyperlink{struct_a_v_buffer_ref_acb8452e99cd75074b93800b532c6ea4b}{A\+V\+Buffer\+Ref.\+data} will not be equal). 
\end{DoxyNote}


\subsection{Macro Definition Documentation}
\index{A\+V\+Buffer@{A\+V\+Buffer}!A\+V\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+F\+L\+A\+G\+\_\+\+R\+E\+A\+D\+O\+N\+LY@{A\+V\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+F\+L\+A\+G\+\_\+\+R\+E\+A\+D\+O\+N\+LY}}
\index{A\+V\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+F\+L\+A\+G\+\_\+\+R\+E\+A\+D\+O\+N\+LY@{A\+V\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+F\+L\+A\+G\+\_\+\+R\+E\+A\+D\+O\+N\+LY}!A\+V\+Buffer@{A\+V\+Buffer}}
\subsubsection[{\texorpdfstring{A\+V\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+F\+L\+A\+G\+\_\+\+R\+E\+A\+D\+O\+N\+LY}{AV_BUFFER_FLAG_READONLY}}]{\setlength{\rightskip}{0pt plus 5cm}\#define A\+V\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+F\+L\+A\+G\+\_\+\+R\+E\+A\+D\+O\+N\+LY~(1 $<$$<$ 0)}\hypertarget{group__lavu__buffer_gaa818f8f1011d69acc50c1f29cb85e576}{}\label{group__lavu__buffer_gaa818f8f1011d69acc50c1f29cb85e576}
Always treat the buffer as read-\/only, even when it has only one reference. 

Definition at line 113 of file buffer.\+h.



\subsection{Typedef Documentation}
\index{A\+V\+Buffer@{A\+V\+Buffer}!A\+V\+Buffer@{A\+V\+Buffer}}
\index{A\+V\+Buffer@{A\+V\+Buffer}!A\+V\+Buffer@{A\+V\+Buffer}}
\subsubsection[{\texorpdfstring{A\+V\+Buffer}{AVBuffer}}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf A\+V\+Buffer} {\bf A\+V\+Buffer}}\hypertarget{group__lavu__buffer_ga501d49df442180d584f255aa97b2549d}{}\label{group__lavu__buffer_ga501d49df442180d584f255aa97b2549d}
A reference counted buffer type. It is opaque and is meant to be used through references (\hyperlink{struct_a_v_buffer_ref}{A\+V\+Buffer\+Ref}). 

Definition at line 73 of file buffer.\+h.

\index{A\+V\+Buffer@{A\+V\+Buffer}!A\+V\+Buffer\+Ref@{A\+V\+Buffer\+Ref}}
\index{A\+V\+Buffer\+Ref@{A\+V\+Buffer\+Ref}!A\+V\+Buffer@{A\+V\+Buffer}}
\subsubsection[{\texorpdfstring{A\+V\+Buffer\+Ref}{AVBufferRef}}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf A\+V\+Buffer\+Ref}  {\bf A\+V\+Buffer\+Ref}}\hypertarget{group__lavu__buffer_ga433e680d11ad786bd1bc20f5616c7d19}{}\label{group__lavu__buffer_ga433e680d11ad786bd1bc20f5616c7d19}
A reference to a data buffer.

The size of this struct is not a part of the public A\+BI and it is not meant to be allocated directly. 

\subsection{Function Documentation}
\index{A\+V\+Buffer@{A\+V\+Buffer}!av\+\_\+buffer\+\_\+alloc@{av\+\_\+buffer\+\_\+alloc}}
\index{av\+\_\+buffer\+\_\+alloc@{av\+\_\+buffer\+\_\+alloc}!A\+V\+Buffer@{A\+V\+Buffer}}
\subsubsection[{\texorpdfstring{av\+\_\+buffer\+\_\+alloc(int size)}{av_buffer_alloc(int size)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf A\+V\+Buffer\+Ref}$\ast$ av\+\_\+buffer\+\_\+alloc (
\begin{DoxyParamCaption}
\item[{{\bf int}}]{size}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__buffer_ga5ae84ac902283dea1a660ede06c1cdac}{}\label{group__lavu__buffer_ga5ae84ac902283dea1a660ede06c1cdac}
Allocate an A\+V\+Buffer of the given size using \hyperlink{group__lavu__mem_gacbca30ebc510a7e4156d66e7aceb2dc8}{av\+\_\+malloc()}.

\begin{DoxyReturn}{Returns}
an \hyperlink{struct_a_v_buffer_ref}{A\+V\+Buffer\+Ref} of given size or N\+U\+LL when out of memory 
\end{DoxyReturn}
\index{A\+V\+Buffer@{A\+V\+Buffer}!av\+\_\+buffer\+\_\+allocz@{av\+\_\+buffer\+\_\+allocz}}
\index{av\+\_\+buffer\+\_\+allocz@{av\+\_\+buffer\+\_\+allocz}!A\+V\+Buffer@{A\+V\+Buffer}}
\subsubsection[{\texorpdfstring{av\+\_\+buffer\+\_\+allocz(int size)}{av_buffer_allocz(int size)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf A\+V\+Buffer\+Ref}$\ast$ av\+\_\+buffer\+\_\+allocz (
\begin{DoxyParamCaption}
\item[{{\bf int}}]{size}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__buffer_ga27f37cc004f768b00442b6cb08091686}{}\label{group__lavu__buffer_ga27f37cc004f768b00442b6cb08091686}
Same as \hyperlink{group__lavu__buffer_ga5ae84ac902283dea1a660ede06c1cdac}{av\+\_\+buffer\+\_\+alloc()}, except the returned buffer will be initialized to zero. \index{A\+V\+Buffer@{A\+V\+Buffer}!av\+\_\+buffer\+\_\+create@{av\+\_\+buffer\+\_\+create}}
\index{av\+\_\+buffer\+\_\+create@{av\+\_\+buffer\+\_\+create}!A\+V\+Buffer@{A\+V\+Buffer}}
\subsubsection[{\texorpdfstring{av\+\_\+buffer\+\_\+create(uint8\+\_\+t $\ast$data, int size, void($\ast$free)(void $\ast$opaque, uint8\+\_\+t $\ast$data), void $\ast$opaque, int flags)}{av_buffer_create(uint8_t *data, int size, void(*free)(void *opaque, uint8_t *data), void *opaque, int flags)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf A\+V\+Buffer\+Ref}$\ast$ av\+\_\+buffer\+\_\+create (
\begin{DoxyParamCaption}
\item[{{\bf uint8\+\_\+t} $\ast$}]{data, }
\item[{{\bf int}}]{size, }
\item[{{\bf void}($\ast$)({\bf void} $\ast$opaque, {\bf uint8\+\_\+t} $\ast${\bf data})}]{free, }
\item[{{\bf void} $\ast$}]{opaque, }
\item[{{\bf int}}]{flags}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__buffer_ga3e7f4c92db85ccba0b2a16dd0069842a}{}\label{group__lavu__buffer_ga3e7f4c92db85ccba0b2a16dd0069842a}
Create an A\+V\+Buffer from an existing array.

If this function is successful, data is owned by the A\+V\+Buffer. The caller may only access data through the returned \hyperlink{struct_a_v_buffer_ref}{A\+V\+Buffer\+Ref} and references derived from it. If this function fails, data is left untouched. 
\begin{DoxyParams}{Parameters}
{\em data} & data array \\
\hline
{\em size} & size of data in bytes \\
\hline
{\em free} & a callback for freeing this buffer\textquotesingle{}s data \\
\hline
{\em opaque} & parameter to be got for processing or passed to free \\
\hline
{\em flags} & a combination of A\+V\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+F\+L\+A\+G\+\_\+$\ast$\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an \hyperlink{struct_a_v_buffer_ref}{A\+V\+Buffer\+Ref} referring to data on success, N\+U\+LL on failure. 
\end{DoxyReturn}
\index{A\+V\+Buffer@{A\+V\+Buffer}!av\+\_\+buffer\+\_\+default\+\_\+free@{av\+\_\+buffer\+\_\+default\+\_\+free}}
\index{av\+\_\+buffer\+\_\+default\+\_\+free@{av\+\_\+buffer\+\_\+default\+\_\+free}!A\+V\+Buffer@{A\+V\+Buffer}}
\subsubsection[{\texorpdfstring{av\+\_\+buffer\+\_\+default\+\_\+free(void $\ast$opaque, uint8\+\_\+t $\ast$data)}{av_buffer_default_free(void *opaque, uint8_t *data)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} av\+\_\+buffer\+\_\+default\+\_\+free (
\begin{DoxyParamCaption}
\item[{{\bf void} $\ast$}]{opaque, }
\item[{{\bf uint8\+\_\+t} $\ast$}]{data}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__buffer_ga37d620e8cfc9f2f3261c2b4c5d4adfe0}{}\label{group__lavu__buffer_ga37d620e8cfc9f2f3261c2b4c5d4adfe0}
Default free callback, which calls \hyperlink{group__lavu__mem_ga0c9096f498624c525aa2315b8a20c411}{av\+\_\+free()} on the buffer data. This function is meant to be passed to \hyperlink{group__lavu__buffer_ga3e7f4c92db85ccba0b2a16dd0069842a}{av\+\_\+buffer\+\_\+create()}, not called directly. \index{A\+V\+Buffer@{A\+V\+Buffer}!av\+\_\+buffer\+\_\+get\+\_\+opaque@{av\+\_\+buffer\+\_\+get\+\_\+opaque}}
\index{av\+\_\+buffer\+\_\+get\+\_\+opaque@{av\+\_\+buffer\+\_\+get\+\_\+opaque}!A\+V\+Buffer@{A\+V\+Buffer}}
\subsubsection[{\texorpdfstring{av\+\_\+buffer\+\_\+get\+\_\+opaque(const A\+V\+Buffer\+Ref $\ast$buf)}{av_buffer_get_opaque(const AVBufferRef *buf)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void}$\ast$ av\+\_\+buffer\+\_\+get\+\_\+opaque (
\begin{DoxyParamCaption}
\item[{{\bf const} {\bf A\+V\+Buffer\+Ref} $\ast$}]{buf}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__buffer_gac1c38f469fc9933885cfffafd8cbf0d6}{}\label{group__lavu__buffer_gac1c38f469fc9933885cfffafd8cbf0d6}
\begin{DoxyReturn}{Returns}
the opaque parameter set by av\+\_\+buffer\+\_\+create. 
\end{DoxyReturn}
\index{A\+V\+Buffer@{A\+V\+Buffer}!av\+\_\+buffer\+\_\+get\+\_\+ref\+\_\+count@{av\+\_\+buffer\+\_\+get\+\_\+ref\+\_\+count}}
\index{av\+\_\+buffer\+\_\+get\+\_\+ref\+\_\+count@{av\+\_\+buffer\+\_\+get\+\_\+ref\+\_\+count}!A\+V\+Buffer@{A\+V\+Buffer}}
\subsubsection[{\texorpdfstring{av\+\_\+buffer\+\_\+get\+\_\+ref\+\_\+count(const A\+V\+Buffer\+Ref $\ast$buf)}{av_buffer_get_ref_count(const AVBufferRef *buf)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf int} av\+\_\+buffer\+\_\+get\+\_\+ref\+\_\+count (
\begin{DoxyParamCaption}
\item[{{\bf const} {\bf A\+V\+Buffer\+Ref} $\ast$}]{buf}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__buffer_ga7b16c3976dc555f71d0843bbd023dfcd}{}\label{group__lavu__buffer_ga7b16c3976dc555f71d0843bbd023dfcd}
\index{A\+V\+Buffer@{A\+V\+Buffer}!av\+\_\+buffer\+\_\+is\+\_\+writable@{av\+\_\+buffer\+\_\+is\+\_\+writable}}
\index{av\+\_\+buffer\+\_\+is\+\_\+writable@{av\+\_\+buffer\+\_\+is\+\_\+writable}!A\+V\+Buffer@{A\+V\+Buffer}}
\subsubsection[{\texorpdfstring{av\+\_\+buffer\+\_\+is\+\_\+writable(const A\+V\+Buffer\+Ref $\ast$buf)}{av_buffer_is_writable(const AVBufferRef *buf)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf int} av\+\_\+buffer\+\_\+is\+\_\+writable (
\begin{DoxyParamCaption}
\item[{{\bf const} {\bf A\+V\+Buffer\+Ref} $\ast$}]{buf}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__buffer_ga060be34ace567ae378fd0a786e847053}{}\label{group__lavu__buffer_ga060be34ace567ae378fd0a786e847053}
\begin{DoxyReturn}{Returns}
1 if the caller may write to the data referred to by buf (which is true if and only if buf is the only reference to the underlying A\+V\+Buffer). Return 0 otherwise. A positive answer is valid until \hyperlink{group__lavu__buffer_gaa40ce7d3ede946a89d03323bbd7268c1}{av\+\_\+buffer\+\_\+ref()} is called on buf. 
\end{DoxyReturn}
\index{A\+V\+Buffer@{A\+V\+Buffer}!av\+\_\+buffer\+\_\+make\+\_\+writable@{av\+\_\+buffer\+\_\+make\+\_\+writable}}
\index{av\+\_\+buffer\+\_\+make\+\_\+writable@{av\+\_\+buffer\+\_\+make\+\_\+writable}!A\+V\+Buffer@{A\+V\+Buffer}}
\subsubsection[{\texorpdfstring{av\+\_\+buffer\+\_\+make\+\_\+writable(\+A\+V\+Buffer\+Ref $\ast$$\ast$buf)}{av_buffer_make_writable(AVBufferRef **buf)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf int} av\+\_\+buffer\+\_\+make\+\_\+writable (
\begin{DoxyParamCaption}
\item[{{\bf A\+V\+Buffer\+Ref} $\ast$$\ast$}]{buf}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__buffer_ga9c2a1be1b7bb80eec8613fdb62a19074}{}\label{group__lavu__buffer_ga9c2a1be1b7bb80eec8613fdb62a19074}
Create a writable reference from a given buffer reference, avoiding data copy if possible.


\begin{DoxyParams}{Parameters}
{\em buf} & buffer reference to make writable. On success, buf is either left untouched, or it is unreferenced and a new writable \hyperlink{struct_a_v_buffer_ref}{A\+V\+Buffer\+Ref} is written in its place. On failure, buf is left untouched. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, a negative A\+V\+E\+R\+R\+OR on failure. 
\end{DoxyReturn}
\index{A\+V\+Buffer@{A\+V\+Buffer}!av\+\_\+buffer\+\_\+realloc@{av\+\_\+buffer\+\_\+realloc}}
\index{av\+\_\+buffer\+\_\+realloc@{av\+\_\+buffer\+\_\+realloc}!A\+V\+Buffer@{A\+V\+Buffer}}
\subsubsection[{\texorpdfstring{av\+\_\+buffer\+\_\+realloc(\+A\+V\+Buffer\+Ref $\ast$$\ast$buf, int size)}{av_buffer_realloc(AVBufferRef **buf, int size)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf int} av\+\_\+buffer\+\_\+realloc (
\begin{DoxyParamCaption}
\item[{{\bf A\+V\+Buffer\+Ref} $\ast$$\ast$}]{buf, }
\item[{{\bf int}}]{size}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__buffer_gac7c228f9ed54e246dcd270503bed7291}{}\label{group__lavu__buffer_gac7c228f9ed54e246dcd270503bed7291}
Reallocate a given buffer.


\begin{DoxyParams}{Parameters}
{\em buf} & a buffer reference to reallocate. On success, buf will be unreferenced and a new reference with the required size will be written in its place. On failure buf will be left untouched. $\ast$buf may be N\+U\+LL, then a new buffer is allocated. \\
\hline
{\em size} & required new buffer size. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, a negative A\+V\+E\+R\+R\+OR on failure.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
the buffer is actually reallocated with \hyperlink{group__lavu__mem_ga74bb2298daa9cd0b5f1d0b2c1c3e26bb}{av\+\_\+realloc()} only if it was initially allocated through av\+\_\+buffer\+\_\+realloc(\+N\+U\+L\+L) and there is only one reference to it (i.\+e. the one passed to this function). In all other cases a new buffer is allocated and the data is copied. 
\end{DoxyNote}
\index{A\+V\+Buffer@{A\+V\+Buffer}!av\+\_\+buffer\+\_\+ref@{av\+\_\+buffer\+\_\+ref}}
\index{av\+\_\+buffer\+\_\+ref@{av\+\_\+buffer\+\_\+ref}!A\+V\+Buffer@{A\+V\+Buffer}}
\subsubsection[{\texorpdfstring{av\+\_\+buffer\+\_\+ref(\+A\+V\+Buffer\+Ref $\ast$buf)}{av_buffer_ref(AVBufferRef *buf)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf A\+V\+Buffer\+Ref}$\ast$ av\+\_\+buffer\+\_\+ref (
\begin{DoxyParamCaption}
\item[{{\bf A\+V\+Buffer\+Ref} $\ast$}]{buf}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__buffer_gaa40ce7d3ede946a89d03323bbd7268c1}{}\label{group__lavu__buffer_gaa40ce7d3ede946a89d03323bbd7268c1}
Create a new reference to an A\+V\+Buffer.

\begin{DoxyReturn}{Returns}
a new \hyperlink{struct_a_v_buffer_ref}{A\+V\+Buffer\+Ref} referring to the same A\+V\+Buffer as buf or N\+U\+LL on failure. 
\end{DoxyReturn}
\index{A\+V\+Buffer@{A\+V\+Buffer}!av\+\_\+buffer\+\_\+unref@{av\+\_\+buffer\+\_\+unref}}
\index{av\+\_\+buffer\+\_\+unref@{av\+\_\+buffer\+\_\+unref}!A\+V\+Buffer@{A\+V\+Buffer}}
\subsubsection[{\texorpdfstring{av\+\_\+buffer\+\_\+unref(\+A\+V\+Buffer\+Ref $\ast$$\ast$buf)}{av_buffer_unref(AVBufferRef **buf)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} av\+\_\+buffer\+\_\+unref (
\begin{DoxyParamCaption}
\item[{{\bf A\+V\+Buffer\+Ref} $\ast$$\ast$}]{buf}
\end{DoxyParamCaption}
)}\hypertarget{group__lavu__buffer_ga135e9e929b5033bb8f68322497b2effc}{}\label{group__lavu__buffer_ga135e9e929b5033bb8f68322497b2effc}
Free a given reference and automatically free the buffer if there are no more references to it.


\begin{DoxyParams}{Parameters}
{\em buf} & the reference to be freed. The pointer is set to N\+U\+LL on return. \\
\hline
\end{DoxyParams}
