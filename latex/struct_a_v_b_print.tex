\hypertarget{struct_a_v_b_print}{}\section{A\+V\+B\+Print Struct Reference}
\label{struct_a_v_b_print}\index{A\+V\+B\+Print@{A\+V\+B\+Print}}


{\ttfamily \#include $<$bprint.\+h$>$}



\subsection{Detailed Description}
Buffer to print data progressively

The string buffer grows as necessary and is always 0-\/terminated. The content of the string is never accessed, and thus is encoding-\/agnostic and can even hold binary data.

Small buffers are kept in the structure itself, and thus require no memory allocation at all (unless the contents of the buffer is needed after the structure goes out of scope). This is almost as lightweight as declaring a local \char`\"{}char buf\mbox{[}512\mbox{]}\char`\"{}.

The length of the string can go beyond the allocated size\+: the buffer is then truncated, but the functions still keep account of the actual total length.

In other words, buf-\/$>$len can be greater than buf-\/$>$size and records the total length of what would have been to the buffer if there had been enough memory.

Append operations do not need to be tested for failure\+: if a memory allocation fails, data stop being appended to the buffer, but the length is still updated. This situation can be tested with av\+\_\+bprint\+\_\+is\+\_\+complete().

The size\+\_\+max field determines several possible behaviours\+:

size\+\_\+max = -\/1 (= U\+I\+N\+T\+\_\+\+M\+AX) or any large value will let the buffer be reallocated as necessary, with an amortized linear cost.

size\+\_\+max = 0 prevents writing anything to the buffer\+: only the total length is computed. The write operations can then possibly be repeated in a buffer with exactly the necessary size (using size\+\_\+init = size\+\_\+max = len + 1).

size\+\_\+max = 1 is automatically replaced by the exact size available in the structure itself, thus ensuring no dynamic memory allocation. The internal buffer is large enough to hold a reasonable paragraph of text, such as the current paragraph. 

Definition at line 77 of file bprint.\+h.



The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+\_\+dev/\+Open\+U/\+Audacity/audacity/lib-\/src/ffmpeg/libavutil/\hyperlink{bprint_8h}{bprint.\+h}\end{DoxyCompactItemize}
