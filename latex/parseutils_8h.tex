\hypertarget{parseutils_8h}{}\section{C\+:/\+\_\+dev/\+Open\+U/\+Audacity/audacity/lib-\/src/ffmpeg/libavutil/parseutils.h File Reference}
\label{parseutils_8h}\index{C\+:/\+\_\+dev/\+Open\+U/\+Audacity/audacity/lib-\/src/ffmpeg/libavutil/parseutils.\+h@{C\+:/\+\_\+dev/\+Open\+U/\+Audacity/audacity/lib-\/src/ffmpeg/libavutil/parseutils.\+h}}
{\ttfamily \#include $<$time.\+h$>$}\\*
{\ttfamily \#include \char`\"{}rational.\+h\char`\"{}}\\*
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{parseutils_8h_a8ac8244d56fd4eeb9557038f80d60560}{av\+\_\+parse\+\_\+ratio\+\_\+quiet}(\hyperlink{seqread_8c_ad89d3fac2deab7a9cf6cfc8d15341b85}{rate},  \hyperlink{sndfile__save_8m_a4b99ff73a8a869319570237b5c57ab03}{str},  \hyperlink{_t_d_stretch_8cpp_ac39d9cef6a5e030ba8d9e11121054268}{max})~\hyperlink{parseutils_8h_a8535b8693aa5a188cfb1356133c0e94e}{av\+\_\+parse\+\_\+ratio}(\hyperlink{seqread_8c_ad89d3fac2deab7a9cf6cfc8d15341b85}{rate}, \hyperlink{sndfile__save_8m_a4b99ff73a8a869319570237b5c57ab03}{str}, \hyperlink{_t_d_stretch_8cpp_ac39d9cef6a5e030ba8d9e11121054268}{max}, \hyperlink{group__lavu__log__constants_gad87b54332d00f280bf5db0fd2f56f340}{A\+V\+\_\+\+L\+O\+G\+\_\+\+M\+A\+X\+\_\+\+O\+F\+F\+S\+ET}, \hyperlink{px__mixer_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{N\+U\+LL})
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} \hyperlink{parseutils_8h_a8535b8693aa5a188cfb1356133c0e94e}{av\+\_\+parse\+\_\+ratio} (\hyperlink{struct_a_v_rational}{A\+V\+Rational} $\ast$\hyperlink{vqext_8h_aed566b4fd5f50587a3ee550f7cd010ae}{q}, \hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} char $\ast$\hyperlink{sndfile__save_8m_a4b99ff73a8a869319570237b5c57ab03}{str}, \hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} \hyperlink{_t_d_stretch_8cpp_ac39d9cef6a5e030ba8d9e11121054268}{max}, \hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} log\+\_\+offset, \hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$log\+\_\+ctx)
\item 
\hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} \hyperlink{parseutils_8h_a4dcdb8a2792f2074ca4a1e1f4ddce2bf}{av\+\_\+parse\+\_\+video\+\_\+size} (\hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} $\ast$width\+\_\+ptr, \hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} $\ast$height\+\_\+ptr, \hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} char $\ast$\hyperlink{sndfile__save_8m_a4b99ff73a8a869319570237b5c57ab03}{str})
\item 
\hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} \hyperlink{parseutils_8h_abbc4de8c071538f5bbde8e5b7466b676}{av\+\_\+parse\+\_\+video\+\_\+rate} (\hyperlink{struct_a_v_rational}{A\+V\+Rational} $\ast$\hyperlink{seqread_8c_ad89d3fac2deab7a9cf6cfc8d15341b85}{rate}, \hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} char $\ast$\hyperlink{sndfile__save_8m_a4b99ff73a8a869319570237b5c57ab03}{str})
\item 
\hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} \hyperlink{parseutils_8h_a4be8779c7c2afd9c57c8b962bea76d03}{av\+\_\+parse\+\_\+color} (\hyperlink{lib-src_2ffmpeg_2win32_2stdint_8h_a9a941819355e6f658991890ff66b4b0e}{uint8\+\_\+t} $\ast$rgba\+\_\+color, \hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} char $\ast$color\+\_\+string, \hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} slen, \hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$log\+\_\+ctx)
\item 
\hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} char $\ast$ \hyperlink{parseutils_8h_a138ca9f3643dfffbf9737b1f44ad27e3}{av\+\_\+get\+\_\+known\+\_\+color\+\_\+name} (\hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} color\+\_\+idx, \hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} \hyperlink{lib-src_2ffmpeg_2win32_2stdint_8h_a9a941819355e6f658991890ff66b4b0e}{uint8\+\_\+t} $\ast$$\ast$rgb)
\item 
\hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} \hyperlink{parseutils_8h_a98590feafe82e074f61f38c8faaa4cef}{av\+\_\+parse\+\_\+time} (\hyperlink{lib-src_2ffmpeg_2win32_2stdint_8h_a67a9885ef4908cb72ce26d75b694386c}{int64\+\_\+t} $\ast$timeval, \hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} char $\ast$timestr, \hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} duration)
\item 
char $\ast$ \hyperlink{parseutils_8h_acd5cd7c7ffea52ca3697864253384ffe}{av\+\_\+small\+\_\+strptime} (\hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} char $\ast$\hyperlink{xmltok_8h_a94b60f3beb36ae85555d36dc9816769c}{p}, \hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} char $\ast$fmt, struct tm $\ast$dt)
\item 
\hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} \hyperlink{parseutils_8h_ad97f06e907c14c253c2bf3e775f51ccb}{av\+\_\+find\+\_\+info\+\_\+tag} (char $\ast$arg, \hyperlink{xmltok_8h_a5a0d4a5641ce434f1d23533f2b2e6653}{int} arg\+\_\+size, \hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} char $\ast$tag1, \hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} char $\ast$\hyperlink{lib_2expat_8h_a20806b446e455c50dc5653b7d43e3de2}{info})
\item 
time\+\_\+t \hyperlink{parseutils_8h_ae9bf34b50b9762f3c733721d5210b52d}{av\+\_\+timegm} (struct tm $\ast$tm)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
misc parsing utilities 

\subsection{Macro Definition Documentation}
\index{parseutils.\+h@{parseutils.\+h}!av\+\_\+parse\+\_\+ratio\+\_\+quiet@{av\+\_\+parse\+\_\+ratio\+\_\+quiet}}
\index{av\+\_\+parse\+\_\+ratio\+\_\+quiet@{av\+\_\+parse\+\_\+ratio\+\_\+quiet}!parseutils.\+h@{parseutils.\+h}}
\subsubsection[{\texorpdfstring{av\+\_\+parse\+\_\+ratio\+\_\+quiet}{av_parse_ratio_quiet}}]{\setlength{\rightskip}{0pt plus 5cm}\#define av\+\_\+parse\+\_\+ratio\+\_\+quiet(
\begin{DoxyParamCaption}
\item[{}]{{\bf rate}, }
\item[{}]{{\bf str}, }
\item[{}]{{\bf max}}
\end{DoxyParamCaption}
)~{\bf av\+\_\+parse\+\_\+ratio}({\bf rate}, {\bf str}, {\bf max}, {\bf A\+V\+\_\+\+L\+O\+G\+\_\+\+M\+A\+X\+\_\+\+O\+F\+F\+S\+ET}, {\bf N\+U\+LL})}\hypertarget{parseutils_8h_a8ac8244d56fd4eeb9557038f80d60560}{}\label{parseutils_8h_a8ac8244d56fd4eeb9557038f80d60560}


Definition at line 52 of file parseutils.\+h.



\subsection{Function Documentation}
\index{parseutils.\+h@{parseutils.\+h}!av\+\_\+find\+\_\+info\+\_\+tag@{av\+\_\+find\+\_\+info\+\_\+tag}}
\index{av\+\_\+find\+\_\+info\+\_\+tag@{av\+\_\+find\+\_\+info\+\_\+tag}!parseutils.\+h@{parseutils.\+h}}
\subsubsection[{\texorpdfstring{av\+\_\+find\+\_\+info\+\_\+tag(char $\ast$arg, int arg\+\_\+size, const char $\ast$tag1, const char $\ast$info)}{av_find_info_tag(char *arg, int arg_size, const char *tag1, const char *info)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf int} av\+\_\+find\+\_\+info\+\_\+tag (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{arg, }
\item[{{\bf int}}]{arg\+\_\+size, }
\item[{{\bf const} char $\ast$}]{tag1, }
\item[{{\bf const} char $\ast$}]{info}
\end{DoxyParamCaption}
)}\hypertarget{parseutils_8h_ad97f06e907c14c253c2bf3e775f51ccb}{}\label{parseutils_8h_ad97f06e907c14c253c2bf3e775f51ccb}
Attempt to find a specific tag in a U\+RL.

syntax\+: \textquotesingle{}?tag1=val1\&tag2=val2...\textquotesingle{}. Little U\+RL decoding is done. Return 1 if found. \index{parseutils.\+h@{parseutils.\+h}!av\+\_\+get\+\_\+known\+\_\+color\+\_\+name@{av\+\_\+get\+\_\+known\+\_\+color\+\_\+name}}
\index{av\+\_\+get\+\_\+known\+\_\+color\+\_\+name@{av\+\_\+get\+\_\+known\+\_\+color\+\_\+name}!parseutils.\+h@{parseutils.\+h}}
\subsubsection[{\texorpdfstring{av\+\_\+get\+\_\+known\+\_\+color\+\_\+name(int color\+\_\+idx, const uint8\+\_\+t $\ast$$\ast$rgb)}{av_get_known_color_name(int color_idx, const uint8_t **rgb)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf const} char$\ast$ av\+\_\+get\+\_\+known\+\_\+color\+\_\+name (
\begin{DoxyParamCaption}
\item[{{\bf int}}]{color\+\_\+idx, }
\item[{{\bf const} {\bf uint8\+\_\+t} $\ast$$\ast$}]{rgb}
\end{DoxyParamCaption}
)}\hypertarget{parseutils_8h_a138ca9f3643dfffbf9737b1f44ad27e3}{}\label{parseutils_8h_a138ca9f3643dfffbf9737b1f44ad27e3}
Get the name of a color from the internal table of hard-\/coded named colors.

This function is meant to enumerate the color names recognized by \hyperlink{parseutils_8h_a4be8779c7c2afd9c57c8b962bea76d03}{av\+\_\+parse\+\_\+color()}.


\begin{DoxyParams}{Parameters}
{\em color\+\_\+idx} & index of the requested color, starting from 0 \\
\hline
{\em rgbp} & if not N\+U\+LL, will point to a 3-\/elements array with the color value in R\+GB \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the color name string or N\+U\+LL if color\+\_\+idx is not in the array 
\end{DoxyReturn}
\index{parseutils.\+h@{parseutils.\+h}!av\+\_\+parse\+\_\+color@{av\+\_\+parse\+\_\+color}}
\index{av\+\_\+parse\+\_\+color@{av\+\_\+parse\+\_\+color}!parseutils.\+h@{parseutils.\+h}}
\subsubsection[{\texorpdfstring{av\+\_\+parse\+\_\+color(uint8\+\_\+t $\ast$rgba\+\_\+color, const char $\ast$color\+\_\+string, int slen, void $\ast$log\+\_\+ctx)}{av_parse_color(uint8_t *rgba_color, const char *color_string, int slen, void *log_ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf int} av\+\_\+parse\+\_\+color (
\begin{DoxyParamCaption}
\item[{{\bf uint8\+\_\+t} $\ast$}]{rgba\+\_\+color, }
\item[{{\bf const} char $\ast$}]{color\+\_\+string, }
\item[{{\bf int}}]{slen, }
\item[{{\bf void} $\ast$}]{log\+\_\+ctx}
\end{DoxyParamCaption}
)}\hypertarget{parseutils_8h_a4be8779c7c2afd9c57c8b962bea76d03}{}\label{parseutils_8h_a4be8779c7c2afd9c57c8b962bea76d03}
Put the R\+G\+BA values that correspond to color\+\_\+string in rgba\+\_\+color.


\begin{DoxyParams}{Parameters}
{\em color\+\_\+string} & a string specifying a color. It can be the name of a color (case insensitive match) or a \mbox{[}0x$\vert$\#\mbox{]}R\+R\+G\+G\+BB\mbox{[}AA\mbox{]} sequence, possibly followed by \char`\"{}@\char`\"{} and a string representing the alpha component. The alpha component may be a string composed by \char`\"{}0x\char`\"{} followed by an hexadecimal number or a decimal number between 0.\+0 and 1.\+0, which represents the opacity value (0x00/0.\+0 means completely transparent, 0xff/1.\+0 completely opaque). If the alpha component is not specified then 0xff is assumed. The string \char`\"{}random\char`\"{} will result in a random color. \\
\hline
{\em slen} & length of the initial part of color\+\_\+string containing the color. It can be set to -\/1 if color\+\_\+string is a null terminated string containing nothing else than the color. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
$>$= 0 in case of success, a negative value in case of failure (for example if color\+\_\+string cannot be parsed). 
\end{DoxyReturn}
\index{parseutils.\+h@{parseutils.\+h}!av\+\_\+parse\+\_\+ratio@{av\+\_\+parse\+\_\+ratio}}
\index{av\+\_\+parse\+\_\+ratio@{av\+\_\+parse\+\_\+ratio}!parseutils.\+h@{parseutils.\+h}}
\subsubsection[{\texorpdfstring{av\+\_\+parse\+\_\+ratio(\+A\+V\+Rational $\ast$q, const char $\ast$str, int max, int log\+\_\+offset, void $\ast$log\+\_\+ctx)}{av_parse_ratio(AVRational *q, const char *str, int max, int log_offset, void *log_ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf int} av\+\_\+parse\+\_\+ratio (
\begin{DoxyParamCaption}
\item[{{\bf A\+V\+Rational} $\ast$}]{q, }
\item[{{\bf const} char $\ast$}]{str, }
\item[{{\bf int}}]{max, }
\item[{{\bf int}}]{log\+\_\+offset, }
\item[{{\bf void} $\ast$}]{log\+\_\+ctx}
\end{DoxyParamCaption}
)}\hypertarget{parseutils_8h_a8535b8693aa5a188cfb1356133c0e94e}{}\label{parseutils_8h_a8535b8693aa5a188cfb1356133c0e94e}
Parse str and store the parsed ratio in q.

Note that a ratio with infinite (1/0) or negative value is considered valid, so you should check on the returned value if you want to exclude those values.

The undefined value can be expressed using the \char`\"{}0\+:0\char`\"{} string.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em q} & pointer to the \hyperlink{struct_a_v_rational}{A\+V\+Rational} which will contain the ratio \\
\hline
\mbox{\tt in}  & {\em str} & the string to parse\+: it has to be a string in the format num\+:den, a float number or an expression \\
\hline
\mbox{\tt in}  & {\em max} & the maximum allowed numerator and denominator \\
\hline
\mbox{\tt in}  & {\em log\+\_\+offset} & log level offset which is applied to the log level of log\+\_\+ctx \\
\hline
\mbox{\tt in}  & {\em log\+\_\+ctx} & parent logging context \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
$>$= 0 on success, a negative error code otherwise 
\end{DoxyReturn}
\index{parseutils.\+h@{parseutils.\+h}!av\+\_\+parse\+\_\+time@{av\+\_\+parse\+\_\+time}}
\index{av\+\_\+parse\+\_\+time@{av\+\_\+parse\+\_\+time}!parseutils.\+h@{parseutils.\+h}}
\subsubsection[{\texorpdfstring{av\+\_\+parse\+\_\+time(int64\+\_\+t $\ast$timeval, const char $\ast$timestr, int duration)}{av_parse_time(int64_t *timeval, const char *timestr, int duration)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf int} av\+\_\+parse\+\_\+time (
\begin{DoxyParamCaption}
\item[{{\bf int64\+\_\+t} $\ast$}]{timeval, }
\item[{{\bf const} char $\ast$}]{timestr, }
\item[{{\bf int}}]{duration}
\end{DoxyParamCaption}
)}\hypertarget{parseutils_8h_a98590feafe82e074f61f38c8faaa4cef}{}\label{parseutils_8h_a98590feafe82e074f61f38c8faaa4cef}
Parse timestr and return in $\ast$time a corresponding number of microseconds.


\begin{DoxyParams}{Parameters}
{\em timeval} & puts here the number of microseconds corresponding to the string in timestr. If the string represents a duration, it is the number of microseconds contained in the time interval. If the string is a date, is the number of microseconds since 1st of January, 1970 up to the time of the parsed date. If timestr cannot be successfully parsed, set $\ast$time to I\+N\+T64\+\_\+\+M\+IN.\\
\hline
{\em timestr} & a string representing a date or a duration.
\begin{DoxyItemize}
\item If a date the syntax is\+: 
\begin{DoxyCode}
1 [\{YYYY-MM-DD|YYYYMMDD\}[T|t| ]]\{\{HH:MM:SS[.m...]]]\}|\{HHMMSS[.m...]]]\}\}[Z]
2 now
\end{DoxyCode}
 If the value is \char`\"{}now\char`\"{} it takes the current time. Time is local time unless Z is appended, in which case it is interpreted as U\+TC. If the year-\/month-\/day part is not specified it takes the current year-\/month-\/day.
\item If a duration the syntax is\+: 
\begin{DoxyCode}
1 [-][HH:]MM:SS[.m...]
2 [-]S+[.m...]
\end{DoxyCode}
 
\end{DoxyItemize}\\
\hline
{\em duration} & flag which tells how to interpret timestr, if not zero timestr is interpreted as a duration, otherwise as a date \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
$>$= 0 in case of success, a negative value corresponding to an A\+V\+E\+R\+R\+OR code otherwise 
\end{DoxyReturn}
\index{parseutils.\+h@{parseutils.\+h}!av\+\_\+parse\+\_\+video\+\_\+rate@{av\+\_\+parse\+\_\+video\+\_\+rate}}
\index{av\+\_\+parse\+\_\+video\+\_\+rate@{av\+\_\+parse\+\_\+video\+\_\+rate}!parseutils.\+h@{parseutils.\+h}}
\subsubsection[{\texorpdfstring{av\+\_\+parse\+\_\+video\+\_\+rate(\+A\+V\+Rational $\ast$rate, const char $\ast$str)}{av_parse_video_rate(AVRational *rate, const char *str)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf int} av\+\_\+parse\+\_\+video\+\_\+rate (
\begin{DoxyParamCaption}
\item[{{\bf A\+V\+Rational} $\ast$}]{rate, }
\item[{{\bf const} char $\ast$}]{str}
\end{DoxyParamCaption}
)}\hypertarget{parseutils_8h_abbc4de8c071538f5bbde8e5b7466b676}{}\label{parseutils_8h_abbc4de8c071538f5bbde8e5b7466b676}
Parse str and store the detected values in $\ast$rate.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em rate} & pointer to the \hyperlink{struct_a_v_rational}{A\+V\+Rational} which will contain the detected frame rate \\
\hline
\mbox{\tt in}  & {\em str} & the string to parse\+: it has to be a string in the format rate\+\_\+num / rate\+\_\+den, a float number or a valid video rate abbreviation \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
$>$= 0 on success, a negative error code otherwise 
\end{DoxyReturn}
\index{parseutils.\+h@{parseutils.\+h}!av\+\_\+parse\+\_\+video\+\_\+size@{av\+\_\+parse\+\_\+video\+\_\+size}}
\index{av\+\_\+parse\+\_\+video\+\_\+size@{av\+\_\+parse\+\_\+video\+\_\+size}!parseutils.\+h@{parseutils.\+h}}
\subsubsection[{\texorpdfstring{av\+\_\+parse\+\_\+video\+\_\+size(int $\ast$width\+\_\+ptr, int $\ast$height\+\_\+ptr, const char $\ast$str)}{av_parse_video_size(int *width_ptr, int *height_ptr, const char *str)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf int} av\+\_\+parse\+\_\+video\+\_\+size (
\begin{DoxyParamCaption}
\item[{{\bf int} $\ast$}]{width\+\_\+ptr, }
\item[{{\bf int} $\ast$}]{height\+\_\+ptr, }
\item[{{\bf const} char $\ast$}]{str}
\end{DoxyParamCaption}
)}\hypertarget{parseutils_8h_a4dcdb8a2792f2074ca4a1e1f4ddce2bf}{}\label{parseutils_8h_a4dcdb8a2792f2074ca4a1e1f4ddce2bf}
Parse str and put in width\+\_\+ptr and height\+\_\+ptr the detected values.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em width\+\_\+ptr} & pointer to the variable which will contain the detected width value \\
\hline
\mbox{\tt in,out}  & {\em height\+\_\+ptr} & pointer to the variable which will contain the detected height value \\
\hline
\mbox{\tt in}  & {\em str} & the string to parse\+: it has to be a string in the format width x height or a valid video size abbreviation. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
$>$= 0 on success, a negative error code otherwise 
\end{DoxyReturn}
\index{parseutils.\+h@{parseutils.\+h}!av\+\_\+small\+\_\+strptime@{av\+\_\+small\+\_\+strptime}}
\index{av\+\_\+small\+\_\+strptime@{av\+\_\+small\+\_\+strptime}!parseutils.\+h@{parseutils.\+h}}
\subsubsection[{\texorpdfstring{av\+\_\+small\+\_\+strptime(const char $\ast$p, const char $\ast$fmt, struct tm $\ast$dt)}{av_small_strptime(const char *p, const char *fmt, struct tm *dt)}}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ av\+\_\+small\+\_\+strptime (
\begin{DoxyParamCaption}
\item[{{\bf const} char $\ast$}]{p, }
\item[{{\bf const} char $\ast$}]{fmt, }
\item[{struct tm $\ast$}]{dt}
\end{DoxyParamCaption}
)}\hypertarget{parseutils_8h_acd5cd7c7ffea52ca3697864253384ffe}{}\label{parseutils_8h_acd5cd7c7ffea52ca3697864253384ffe}
Parse the input string p according to the format string fmt and store its results in the structure dt. This implementation supports only a subset of the formats supported by the standard strptime().

In particular it actually supports the parameters\+:
\begin{DoxyItemize}
\item H\+: the hour as a decimal number, using a 24-\/hour clock, in the range \textquotesingle{}00\textquotesingle{} through \textquotesingle{}23\textquotesingle{}
\item J\+: hours as a decimal number, in the range \textquotesingle{}0\textquotesingle{} through I\+N\+T\+\_\+\+M\+AX
\item M\+: the minute as a decimal number, using a 24-\/hour clock, in the range \textquotesingle{}00\textquotesingle{} through \textquotesingle{}59\textquotesingle{}
\item S\+: the second as a decimal number, using a 24-\/hour clock, in the range \textquotesingle{}00\textquotesingle{} through \textquotesingle{}59\textquotesingle{}
\item Y\+: the year as a decimal number, using the Gregorian calendar
\item m\+: the month as a decimal number, in the range \textquotesingle{}1\textquotesingle{} through \textquotesingle{}12\textquotesingle{}
\item d\+: the day of the month as a decimal number, in the range \textquotesingle{}1\textquotesingle{} through \textquotesingle{}31\textquotesingle{}
\item \%\%\+: a literal \textquotesingle{}\textquotesingle{}
\end{DoxyItemize}

\begin{DoxyReturn}{Returns}
a pointer to the first character not processed in this function call, or N\+U\+LL in case the function fails to match all of the fmt string and therefore an error occurred 
\end{DoxyReturn}
\index{parseutils.\+h@{parseutils.\+h}!av\+\_\+timegm@{av\+\_\+timegm}}
\index{av\+\_\+timegm@{av\+\_\+timegm}!parseutils.\+h@{parseutils.\+h}}
\subsubsection[{\texorpdfstring{av\+\_\+timegm(struct tm $\ast$tm)}{av_timegm(struct tm *tm)}}]{\setlength{\rightskip}{0pt plus 5cm}time\+\_\+t av\+\_\+timegm (
\begin{DoxyParamCaption}
\item[{struct tm $\ast$}]{tm}
\end{DoxyParamCaption}
)}\hypertarget{parseutils_8h_ae9bf34b50b9762f3c733721d5210b52d}{}\label{parseutils_8h_ae9bf34b50b9762f3c733721d5210b52d}
Convert the decomposed U\+TC time in tm to a time\+\_\+t value. 