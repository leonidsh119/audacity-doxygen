\hypertarget{group__grp__device}{}\section{Input/\+Output Devices Handling}
\label{group__grp__device}\index{Input/\+Output Devices Handling@{Input/\+Output Devices Handling}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{porttime_8h_ad478fb637833fb6b1a4bdb25a03f4662}{P\+M\+E\+X\+P\+O\+RT} \hyperlink{getopt1_8c_a2c212835823e3c54a8ab6d95c652660e}{const} \hyperlink{struct_pm_device_info}{Pm\+Device\+Info} $\ast$ \hyperlink{group__grp__device_ga2ff3676bcff6077e64ef6f3eb57fb37e}{Pm\+\_\+\+Get\+Device\+Info} (\hyperlink{portmidi_8h_a696cc4d4360bb8513f13df4bb134098a}{Pm\+Device\+ID} id)
\item 
\hyperlink{porttime_8h_ad478fb637833fb6b1a4bdb25a03f4662}{P\+M\+E\+X\+P\+O\+RT} \hyperlink{portmidi_8h_a5fd46ccd2e320e17a840886731e8c6b9}{Pm\+Error} \hyperlink{group__grp__device_gabd50a31baaa494ad8b405f9ad54c966e}{Pm\+\_\+\+Open\+Input} (\hyperlink{portmidi_8h_af4949219ee1bb0afc857cb242d123914}{Port\+Midi\+Stream} $\ast$$\ast$stream, \hyperlink{portmidi_8h_a696cc4d4360bb8513f13df4bb134098a}{Pm\+Device\+ID} input\+Device, \hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$input\+Driver\+Info, \hyperlink{lib-src_2ffmpeg_2win32_2stdint_8h_a37994e3b11c72957c6f454c6ec96d43d}{int32\+\_\+t} buffer\+Size, \hyperlink{portmidi_8h_a86cdcb85cfa72e067bc2fd1b96fca05d}{Pm\+Time\+Proc\+Ptr} time\+\_\+proc, \hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$time\+\_\+info)
\item 
\hyperlink{porttime_8h_ad478fb637833fb6b1a4bdb25a03f4662}{P\+M\+E\+X\+P\+O\+RT} \hyperlink{portmidi_8h_a5fd46ccd2e320e17a840886731e8c6b9}{Pm\+Error} \hyperlink{group__grp__device_ga134924cfa8badeecff3c5e1f22aee178}{Pm\+\_\+\+Open\+Output} (\hyperlink{portmidi_8h_af4949219ee1bb0afc857cb242d123914}{Port\+Midi\+Stream} $\ast$$\ast$stream, \hyperlink{portmidi_8h_a696cc4d4360bb8513f13df4bb134098a}{Pm\+Device\+ID} output\+Device, \hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$output\+Driver\+Info, \hyperlink{lib-src_2ffmpeg_2win32_2stdint_8h_a37994e3b11c72957c6f454c6ec96d43d}{int32\+\_\+t} buffer\+Size, \hyperlink{portmidi_8h_a86cdcb85cfa72e067bc2fd1b96fca05d}{Pm\+Time\+Proc\+Ptr} time\+\_\+proc, \hyperlink{sound_8c_ae35f5844602719cf66324f4de2a658b3}{void} $\ast$time\+\_\+info, \hyperlink{lib-src_2ffmpeg_2win32_2stdint_8h_a37994e3b11c72957c6f454c6ec96d43d}{int32\+\_\+t} \hyperlink{portmidi_2pm__test_2test_8c_abe13b7efd223bb5d20e2f3710b43bcd2}{latency})
\end{DoxyCompactItemize}


\subsection{Detailed Description}


\subsection{Function Documentation}
\index{Input/\+Output Devices Handling@{Input/\+Output Devices Handling}!Pm\+\_\+\+Get\+Device\+Info@{Pm\+\_\+\+Get\+Device\+Info}}
\index{Pm\+\_\+\+Get\+Device\+Info@{Pm\+\_\+\+Get\+Device\+Info}!Input/\+Output Devices Handling@{Input/\+Output Devices Handling}}
\subsubsection[{\texorpdfstring{Pm\+\_\+\+Get\+Device\+Info(\+Pm\+Device\+I\+D id)}{Pm_GetDeviceInfo(PmDeviceID id)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf P\+M\+E\+X\+P\+O\+RT} {\bf const} {\bf Pm\+Device\+Info}$\ast$ Pm\+\_\+\+Get\+Device\+Info (
\begin{DoxyParamCaption}
\item[{{\bf Pm\+Device\+ID}}]{id}
\end{DoxyParamCaption}
)}\hypertarget{group__grp__device_ga2ff3676bcff6077e64ef6f3eb57fb37e}{}\label{group__grp__device_ga2ff3676bcff6077e64ef6f3eb57fb37e}
\hyperlink{group__grp__device_ga2ff3676bcff6077e64ef6f3eb57fb37e}{Pm\+\_\+\+Get\+Device\+Info()} returns a pointer to a \hyperlink{struct_pm_device_info}{Pm\+Device\+Info} structure referring to the device specified by id. If id is out of range the function returns N\+U\+LL.

The returned structure is owned by the Port\+Midi implementation and must not be manipulated or freed. The pointer is guaranteed to be valid between calls to \hyperlink{portmidi_8h_a5e9d0c116061f0cc25fb789fc393b417}{Pm\+\_\+\+Initialize()} and \hyperlink{portmidi_8h_a6c5dd5cd3657ac1cdab6bc5f3063193e}{Pm\+\_\+\+Terminate()}. 

Definition at line 183 of file portmidi.\+c.

\index{Input/\+Output Devices Handling@{Input/\+Output Devices Handling}!Pm\+\_\+\+Open\+Input@{Pm\+\_\+\+Open\+Input}}
\index{Pm\+\_\+\+Open\+Input@{Pm\+\_\+\+Open\+Input}!Input/\+Output Devices Handling@{Input/\+Output Devices Handling}}
\subsubsection[{\texorpdfstring{Pm\+\_\+\+Open\+Input(\+Port\+Midi\+Stream $\ast$$\ast$stream, Pm\+Device\+I\+D input\+Device, void $\ast$input\+Driver\+Info, int32\+\_\+t buffer\+Size, Pm\+Time\+Proc\+Ptr time\+\_\+proc, void $\ast$time\+\_\+info)}{Pm_OpenInput(PortMidiStream **stream, PmDeviceID inputDevice, void *inputDriverInfo, int32_t bufferSize, PmTimeProcPtr time_proc, void *time_info)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf P\+M\+E\+X\+P\+O\+RT} {\bf Pm\+Error} Pm\+\_\+\+Open\+Input (
\begin{DoxyParamCaption}
\item[{{\bf Port\+Midi\+Stream} $\ast$$\ast$}]{stream, }
\item[{{\bf Pm\+Device\+ID}}]{input\+Device, }
\item[{{\bf void} $\ast$}]{input\+Driver\+Info, }
\item[{{\bf int32\+\_\+t}}]{buffer\+Size, }
\item[{{\bf Pm\+Time\+Proc\+Ptr}}]{time\+\_\+proc, }
\item[{{\bf void} $\ast$}]{time\+\_\+info}
\end{DoxyParamCaption}
)}\hypertarget{group__grp__device_gabd50a31baaa494ad8b405f9ad54c966e}{}\label{group__grp__device_gabd50a31baaa494ad8b405f9ad54c966e}
\hyperlink{group__grp__device_gabd50a31baaa494ad8b405f9ad54c966e}{Pm\+\_\+\+Open\+Input()} and \hyperlink{group__grp__device_ga134924cfa8badeecff3c5e1f22aee178}{Pm\+\_\+\+Open\+Output()} open devices.

stream is the address of a Port\+Midi\+Stream pointer which will receive a pointer to the newly opened stream.

input\+Device is the id of the device used for input (see Pm\+Device\+ID above).

input\+Driver\+Info is a pointer to an optional driver specific data structure containing additional information for device setup or handle processing. input\+Driver\+Info is never required for correct operation. If not used input\+Driver\+Info should be N\+U\+LL.

output\+Device is the id of the device used for output (see Pm\+Device\+ID above.)

output\+Driver\+Info is a pointer to an optional driver specific data structure containing additional information for device setup or handle processing. output\+Driver\+Info is never required for correct operation. If not used output\+Driver\+Info should be N\+U\+LL.

For input, the buffersize specifies the number of input events to be buffered waiting to be read using \hyperlink{group__grp__io_ga3d59225bc890ede974f245ada3de6456}{Pm\+\_\+\+Read()}. For output, buffersize specifies the number of output events to be buffered waiting for output. (In some cases -- see below -- Port\+Midi does not buffer output at all and merely passes data to a lower-\/level A\+PI, in which case buffersize is ignored.)

latency is the delay in milliseconds applied to timestamps to determine when the output should actually occur. (If latency is $<$ 0, 0 is assumed.) If latency is zero, timestamps are ignored and all output is delivered immediately. If latency is greater than zero, output is delayed until the message timestamp plus the latency. (N\+O\+TE\+: the time is measured relative to the time source indicated by time\+\_\+proc. Timestamps are absolute, not relative delays or offsets.) In some cases, Port\+Midi can obtain better timing than your application by passing timestamps along to the device driver or hardware. Latency may also help you to synchronize midi data to audio data by matching midi latency to the audio buffer latency.

time\+\_\+proc is a pointer to a procedure that returns time in milliseconds. It may be N\+U\+LL, in which case a default millisecond timebase (Port\+Time) is used. If the application wants to use Port\+Time, it should start the timer (call Pt\+\_\+\+Start) before calling Pm\+\_\+\+Open\+Input or Pm\+\_\+\+Open\+Output. If the application tries to start the timer {\itshape after} Pm\+\_\+\+Open\+Input or Pm\+\_\+\+Open\+Output, it may get a pt\+Already\+Started error from Pt\+\_\+\+Start, and the application\textquotesingle{}s preferred time resolution and callback function will be ignored. time\+\_\+proc result values are appended to incoming M\+I\+DI data, and time\+\_\+proc times are used to schedule outgoing M\+I\+DI data (when latency is non-\/zero).

time\+\_\+info is a pointer passed to time\+\_\+proc.

Example\+: If I provide a timestamp of 5000, latency is 1, and time\+\_\+proc returns 4990, then the desired output time will be when time\+\_\+proc returns timestamp+latency = 5001. This will be 5001-\/4990 = 11ms from now.

return value\+: Upon success Pm\+\_\+\+Open() returns Pm\+No\+Error and places a pointer to a valid Port\+Midi\+Stream in the stream argument. If a call to Pm\+\_\+\+Open() fails a nonzero error code is returned (see P\+M\+Error above) and the value of port is invalid.

Any stream that is successfully opened should eventually be closed by calling \hyperlink{group__grp__events__filters_ga6b26be2fbcf092c9625ade5303edd0ac}{Pm\+\_\+\+Close()}. 

Definition at line 669 of file portmidi.\+c.

\index{Input/\+Output Devices Handling@{Input/\+Output Devices Handling}!Pm\+\_\+\+Open\+Output@{Pm\+\_\+\+Open\+Output}}
\index{Pm\+\_\+\+Open\+Output@{Pm\+\_\+\+Open\+Output}!Input/\+Output Devices Handling@{Input/\+Output Devices Handling}}
\subsubsection[{\texorpdfstring{Pm\+\_\+\+Open\+Output(\+Port\+Midi\+Stream $\ast$$\ast$stream, Pm\+Device\+I\+D output\+Device, void $\ast$output\+Driver\+Info, int32\+\_\+t buffer\+Size, Pm\+Time\+Proc\+Ptr time\+\_\+proc, void $\ast$time\+\_\+info, int32\+\_\+t latency)}{Pm_OpenOutput(PortMidiStream **stream, PmDeviceID outputDevice, void *outputDriverInfo, int32_t bufferSize, PmTimeProcPtr time_proc, void *time_info, int32_t latency)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf P\+M\+E\+X\+P\+O\+RT} {\bf Pm\+Error} Pm\+\_\+\+Open\+Output (
\begin{DoxyParamCaption}
\item[{{\bf Port\+Midi\+Stream} $\ast$$\ast$}]{stream, }
\item[{{\bf Pm\+Device\+ID}}]{output\+Device, }
\item[{{\bf void} $\ast$}]{output\+Driver\+Info, }
\item[{{\bf int32\+\_\+t}}]{buffer\+Size, }
\item[{{\bf Pm\+Time\+Proc\+Ptr}}]{time\+\_\+proc, }
\item[{{\bf void} $\ast$}]{time\+\_\+info, }
\item[{{\bf int32\+\_\+t}}]{latency}
\end{DoxyParamCaption}
)}\hypertarget{group__grp__device_ga134924cfa8badeecff3c5e1f22aee178}{}\label{group__grp__device_ga134924cfa8badeecff3c5e1f22aee178}


Definition at line 752 of file portmidi.\+c.

