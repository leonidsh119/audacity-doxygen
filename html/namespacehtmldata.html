<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Audacity: htmldata Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Audacity
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">htmldata Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtmldata_1_1___h_t_m_l_tag.html">_HTMLTag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtmldata_1_1___text_tag.html">_TextTag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtmldata_1_1_u_r_l_match.html">URLMatch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3d5a0fd3ca07d74ca1fcd1d825102307"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehtmldata.html#a3d5a0fd3ca07d74ca1fcd1d825102307">tagextract</a> (doc)</td></tr>
<tr class="separator:a3d5a0fd3ca07d74ca1fcd1d825102307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea91d7c71df2f825ea2fd1ab11387cd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehtmldata.html#abea91d7c71df2f825ea2fd1ab11387cd">tagjoin</a> (L)</td></tr>
<tr class="separator:abea91d7c71df2f825ea2fd1ab11387cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849b6b90a5518672e5494c58e7bee65c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehtmldata.html#a849b6b90a5518672e5494c58e7bee65c">urlextract</a> (doc, siteurl=None, mimetype='text/html')</td></tr>
<tr class="separator:a849b6b90a5518672e5494c58e7bee65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281fd13bfba54efd22dfe1e901181648"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehtmldata.html#a281fd13bfba54efd22dfe1e901181648">urljoin</a> (<a class="el" href="lib_2expat_8h.html#a755339d27872b13735c2cab829e47157">s</a>, L)</td></tr>
<tr class="separator:a281fd13bfba54efd22dfe1e901181648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52faf44a3a2bcdf3bf87668c93cba00"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehtmldata.html#ab52faf44a3a2bcdf3bf87668c93cba00">examples</a> ()</td></tr>
<tr class="separator:ab52faf44a3a2bcdf3bf87668c93cba00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Manipulate HTML or XHTML documents.

Version 1.1.1.  This source code has been placed in the
public domain by Connelly Barnes.

Features:

 - Translate HTML back and forth to data structures.
 This allows you to read and write HTML documents
 programmably, with much flexibility.
 - Extract and modify URLs in an HTML document.
 - Compatible with Python 2.0 - 2.5.

See the L{examples} for a quick start.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ab52faf44a3a2bcdf3bf87668c93cba00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def htmldata.examples </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Examples of the C{htmldata} module.

Example 1:
Print all absolutized URLs from Google.

Here we use L{urlextract} to obtain all URLs in the document.

 &gt;&gt;&gt; import urllib2, htmldata
 &gt;&gt;&gt; url = 'http://www.google.com/'
 &gt;&gt;&gt; contents = urllib2.urlopen(url).read()
 &gt;&gt;&gt; for u in htmldata.urlextract(contents, url):
 ...   print u.url
 ...
 http://www.google.com/images/logo.gif
 http://www.google.com/search
 (More output)

Note that the second argument to L{urlextract} causes the
URLs to be made absolute with respect to that base URL.

Example 2:
Print all image URLs from Google in relative form.


 &gt;&gt;&gt; import urllib2, htmldata
 &gt;&gt;&gt; url = 'http://www.google.com/'
 &gt;&gt;&gt; contents = urllib2.urlopen(url).read()
 &gt;&gt;&gt; for u in htmldata.urlextract(contents):
 ...   if u.tag_name == 'img':
 ...     print u.url
 ...
 /images/logo.gif

Equivalently, one can use L{tagextract}, and look for occurrences
of C{&lt;img&gt;} tags. The L{urlextract} function is mostly a convenience
function for when one wants to extract and/or modify all URLs in a
document.

Example 3:
Replace all C{&lt;a href&gt;} links on Google with the Microsoft web page.

Here we use L{tagextract} to turn the HTML into a data structure,
and then loop over the in-order list of tags (items which are not
tuples are plain text, which is ignored).

 &gt;&gt;&gt; import urllib2, htmldata
 &gt;&gt;&gt; url = 'http://www.google.com/'
 &gt;&gt;&gt; contents = urllib2.urlopen(url).read()
 &gt;&gt;&gt; L = htmldata.tagextract(contents)
 &gt;&gt;&gt; for item in L:
 ...   if isinstance(item, tuple) and item[0] == 'a':
 ...     # It's an HTML &lt;a&gt; tag!  Give it an href=.
 ...     item[1]['href'] = 'http://www.microsoft.com/'
 ...
 &gt;&gt;&gt; htmldata.tagjoin(L)
 (Microsoftized version of Google)

Example 4:
Make all URLs on an HTML document be absolute.

 &gt;&gt;&gt; import urllib2, htmldata
 &gt;&gt;&gt; url = 'http://www.google.com/'
 &gt;&gt;&gt; contents = urllib2.urlopen(url).read()
 &gt;&gt;&gt; htmldata.urljoin(htmldata.urlextract(contents, url))
 (Google HTML page with absolute URLs)

Example 5:
Properly quote all HTML tag values for pedants.

 &gt;&gt;&gt; import urllib2, htmldata
 &gt;&gt;&gt; url = 'http://www.google.com/'
 &gt;&gt;&gt; contents = urllib2.urlopen(url).read()
 &gt;&gt;&gt; htmldata.tagjoin(htmldata.tagextract(contents))
 (Properly quoted version of the original HTML)

Example 6:
Modify all URLs in a document so that they are appended
to our proxy CGI script C{http://mysite.com/proxy.cgi}.

 &gt;&gt;&gt; import urllib2, htmldata
 &gt;&gt;&gt; url = 'http://www.google.com/'
 &gt;&gt;&gt; contents = urllib2.urlopen(url).read()
 &gt;&gt;&gt; proxy_url = 'http://mysite.com/proxy.cgi?url='
 &gt;&gt;&gt; L = htmldata.urlextract(contents)
 &gt;&gt;&gt; for u in L:
 ...   u.url = proxy_url + u.url
 ...
 &gt;&gt;&gt; htmldata.urljoin(L)
 (Document with all URLs wrapped in our proxy script)

Example 7:
Download all images from a website.

 &gt;&gt;&gt; import urllib, htmldata, time
 &gt;&gt;&gt; url = 'http://www.google.com/'
 &gt;&gt;&gt; contents = urllib.urlopen(url).read()
 &gt;&gt;&gt; for u in htmldata.urlextract(contents, url):
 ...   if u.tag_name == 'img':
 ...     filename = urllib.quote_plus(u.url)
 ...     urllib.urlretrieve(u.url, filename)
 ...     time.sleep(0.5)
 ...
 (Images are downloaded to the current directory)

Many sites will protect against bandwidth-draining robots by
checking the HTTP C{Referer} [sic] and C{User-Agent} fields.
To circumvent this, one can create a C{urllib2.Request} object
with a legitimate C{Referer} and a C{User-Agent} such as
C{"Mozilla/4.0 (compatible; MSIE 5.5)"}.  Then use
C{urllib2.urlopen} to download the content.  Be warned that some
website operators will respond to rapid robot requests by banning
the offending IP address.</pre> 
<p>Definition at line <a class="el" href="htmldata_8py_source.html#l00977">977</a> of file <a class="el" href="htmldata_8py_source.html">htmldata.py</a>.</p>

</div>
</div>
<a class="anchor" id="a3d5a0fd3ca07d74ca1fcd1d825102307"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def htmldata.tagextract </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>doc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert HTML to data structure.

Returns a list.  HTML tags become C{(name, keyword_dict)} tuples
within the list, while plain text becomes strings within the
list.  All tag names are lowercased and stripped of whitespace.
Tags which end with forward slashes have a single forward slash
placed at the end of their name, to indicate that they are XML
unclosed tags.

Example:

 &gt;&gt;&gt; tagextract('&lt;img src=hi.gif alt="hi"&gt;foo&lt;br&gt;&lt;br/&gt;&lt;/body&gt;')
 [('img', {'src': 'hi.gif', 'alt': 'hi'}), 'foo',
  ('br', {}), ('br/', {}), ('/body', {})]

Text between C{'&lt;script&gt;'} and C{'&lt;style&gt;'} is rendered directly to
plain text. This prevents rogue C{'&lt;'} or C{'&gt;'} characters from
interfering with parsing.

 &gt;&gt;&gt; tagextract('&lt;script type="a"&gt;&lt;blah&gt;var x; &lt;/script&gt;')
 [('script', {'type': 'a'}), '&lt;blah&gt;var x; ', ('/script', {})]

Comment strings and XML directives are rendered as a single long
tag with no attributes.  The case of the tag "name" is not changed:

 &gt;&gt;&gt; tagextract('&lt;!-- blah --&gt;')
 [('!-- blah --', {})]
 &gt;&gt;&gt; tagextract('&lt;?xml version="1.0" encoding="utf-8" ?&gt;')
 [('?xml version="1.0" encoding="utf-8" ?', {})]
 &gt;&gt;&gt; tagextract('&lt;!DOCTYPE html PUBLIC etc...&gt;')
 [('!DOCTYPE html PUBLIC etc...', {})]

Greater-than and less-than characters occuring inside comments or
CDATA blocks are correctly kept as part of the block:

 &gt;&gt;&gt; tagextract('&lt;!-- &lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&gt;..&gt; --&gt;')
 [('!-- &lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&gt;..&gt; --', {})]
 &gt;&gt;&gt; tagextract('&lt;!CDATA[[&gt;&lt;&gt;&gt;&lt;&gt;]&lt;&gt; ]]&gt;')
 [('!CDATA[[&gt;&lt;&gt;&gt;&lt;&gt;]&lt;&gt; ]]', {})]

Note that if one modifies these tags, it is important to retain the
C{"--"} (for comments) or C{"]]"} (for C{CDATA}) at the end of the
tag name, so that output from L{tagjoin} will be correct HTML/XHTML.</pre> 
<p>Definition at line <a class="el" href="htmldata_8py_source.html#l00064">64</a> of file <a class="el" href="htmldata_8py_source.html">htmldata.py</a>.</p>

</div>
</div>
<a class="anchor" id="abea91d7c71df2f825ea2fd1ab11387cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def htmldata.tagjoin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert data structure back to HTML.

This reverses the L{tagextract} function.

More precisely, if an HTML string is turned into a data structure,
then back into HTML, the resulting string will be functionally
equivalent to the original HTML.

 &gt;&gt;&gt; tagjoin(tagextract(s))
 (string that is functionally equivalent to s)

Three changes are made to the HTML by L{tagjoin}: tags are
lowercased, C{key=value} pairs are sorted, and values are placed in
double-quotes.
</pre> 
<p>Definition at line <a class="el" href="htmldata_8py_source.html#l00127">127</a> of file <a class="el" href="htmldata_8py_source.html">htmldata.py</a>.</p>

</div>
</div>
<a class="anchor" id="a849b6b90a5518672e5494c58e7bee65c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def htmldata.urlextract </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>siteurl</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mimetype</em> = <code>'text/html'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Extract URLs from HTML or stylesheet.

Extracts only URLs that are linked to or embedded in the document.
Ignores plain text URLs that occur in the non-HTML part of the
document.

Returns a list of L{URLMatch} objects.

 &gt;&gt;&gt; L = urlextract('&lt;img src="a.gif"&gt;&lt;a href="www.google.com"&gt;')
 &gt;&gt;&gt; L[0].url
 'a.gif'
 &gt;&gt;&gt; L[1].url
 'www.google.com'

If C{siteurl} is specified, all URLs are made into absolute URLs
by assuming that C{doc} is located at the URL C{siteurl}.

 &gt;&gt;&gt; doc = '&lt;img src="a.gif"&gt;&lt;a href="/b.html"&gt;'
 &gt;&gt;&gt; L = urlextract(doc, 'http://www.python.org/~guido/')
 &gt;&gt;&gt; L[0].url
 'http://www.python.org/~guido/a.gif'
 &gt;&gt;&gt; L[1].url
 'http://www.python.org/b.html'

If C{mimetype} is C{"text/css"}, the document will be parsed
as a stylesheet.

If a stylesheet is embedded inside an HTML document, then
C{urlextract} will extract the URLs from both the HTML and the
stylesheet.
</pre> 
<p>Definition at line <a class="el" href="htmldata_8py_source.html#l00786">786</a> of file <a class="el" href="htmldata_8py_source.html">htmldata.py</a>.</p>

</div>
</div>
<a class="anchor" id="a281fd13bfba54efd22dfe1e901181648"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def htmldata.urljoin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Write back document with modified URLs (reverses L{urlextract}).

Given a list C{L} of L{URLMatch} objects obtained from
L{urlextract}, substitutes changed URLs into the original
document C{s}, and returns the modified document.

One should only modify the C{.url} attribute of the L{URLMatch}
objects.  The ordering of the URLs in the list is not important.

 &gt;&gt;&gt; doc = '&lt;img src="a.png"&gt;&lt;a href="b.png"&gt;'
 &gt;&gt;&gt; L = urlextract(doc)
 &gt;&gt;&gt; L[0].url = 'foo'
 &gt;&gt;&gt; L[1].url = 'bar'
 &gt;&gt;&gt; urljoin(doc, L)
 '&lt;img src="foo"&gt;&lt;a href="bar"&gt;'</pre> 
<p>Definition at line <a class="el" href="htmldata_8py_source.html#l00954">954</a> of file <a class="el" href="htmldata_8py_source.html">htmldata.py</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
