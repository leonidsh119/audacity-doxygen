.TH "grp_events_filters" 3 "Thu Apr 28 2016" "Audacity" \" -*- nroff -*-
.ad l
.nh
.SH NAME
grp_events_filters \- Events and Filters Handling
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBPmEvent\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBPM_FILT_ACTIVE\fP   (1 << 0x0E)"
.br
.ti -1c
.RI "#define \fBPM_FILT_SYSEX\fP   (1 << 0x00)"
.br
.ti -1c
.RI "#define \fBPM_FILT_CLOCK\fP   (1 << 0x08)"
.br
.ti -1c
.RI "#define \fBPM_FILT_PLAY\fP   ((1 << 0x0A) | (1 << 0x0C) | (1 << 0x0B))"
.br
.ti -1c
.RI "#define \fBPM_FILT_TICK\fP   (1 << 0x09)"
.br
.ti -1c
.RI "#define \fBPM_FILT_FD\fP   (1 << 0x0D)"
.br
.ti -1c
.RI "#define \fBPM_FILT_UNDEFINED\fP   \fBPM_FILT_FD\fP"
.br
.ti -1c
.RI "#define \fBPM_FILT_RESET\fP   (1 << 0x0F)"
.br
.ti -1c
.RI "#define \fBPM_FILT_REALTIME\fP"
.br
.ti -1c
.RI "#define \fBPM_FILT_NOTE\fP   ((1 << 0x19) | (1 << 0x18))"
.br
.ti -1c
.RI "#define \fBPM_FILT_CHANNEL_AFTERTOUCH\fP   (1 << 0x1D)"
.br
.ti -1c
.RI "#define \fBPM_FILT_POLY_AFTERTOUCH\fP   (1 << 0x1A)"
.br
.ti -1c
.RI "#define \fBPM_FILT_AFTERTOUCH\fP   (\fBPM_FILT_CHANNEL_AFTERTOUCH\fP | \fBPM_FILT_POLY_AFTERTOUCH\fP)"
.br
.ti -1c
.RI "#define \fBPM_FILT_PROGRAM\fP   (1 << 0x1C)"
.br
.ti -1c
.RI "#define \fBPM_FILT_CONTROL\fP   (1 << 0x1B)"
.br
.ti -1c
.RI "#define \fBPM_FILT_PITCHBEND\fP   (1 << 0x1E)"
.br
.ti -1c
.RI "#define \fBPM_FILT_MTC\fP   (1 << 0x01)"
.br
.ti -1c
.RI "#define \fBPM_FILT_SONG_POSITION\fP   (1 << 0x02)"
.br
.ti -1c
.RI "#define \fBPM_FILT_SONG_SELECT\fP   (1 << 0x03)"
.br
.ti -1c
.RI "#define \fBPM_FILT_TUNE\fP   (1 << 0x06)"
.br
.ti -1c
.RI "#define \fBPM_FILT_SYSTEMCOMMON\fP   (\fBPM_FILT_MTC\fP | \fBPM_FILT_SONG_POSITION\fP | \fBPM_FILT_SONG_SELECT\fP | \fBPM_FILT_TUNE\fP)"
.br
.ti -1c
.RI "#define \fBPm_Channel\fP(channel)   (1<<(channel))"
.br
.ti -1c
.RI "#define \fBPm_Message\fP(\fBstatus\fP,  data1,  data2)"
.br
.ti -1c
.RI "#define \fBPm_MessageStatus\fP(msg)   ((msg) & 0xFF)"
.br
.ti -1c
.RI "#define \fBPm_MessageData1\fP(msg)   (((msg) >> 8) & 0xFF)"
.br
.ti -1c
.RI "#define \fBPm_MessageData2\fP(msg)   (((msg) >> 16) & 0xFF)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef \fBint32_t\fP \fBPmMessage\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBPMEXPORT\fP \fBPmError\fP \fBPm_SetFilter\fP (\fBPortMidiStream\fP *stream, \fBint32_t\fP filters)"
.br
.ti -1c
.RI "\fBPMEXPORT\fP \fBPmError\fP \fBPm_SetChannelMask\fP (\fBPortMidiStream\fP *stream, \fBint\fP \fBmask\fP)"
.br
.ti -1c
.RI "\fBPMEXPORT\fP \fBPmError\fP \fBPm_Abort\fP (\fBPortMidiStream\fP *stream)"
.br
.ti -1c
.RI "\fBPMEXPORT\fP \fBPmError\fP \fBPm_Close\fP (\fBPortMidiStream\fP *stream)"
.br
.ti -1c
.RI "\fBPmError\fP \fBPm_Synchronize\fP (\fBPortMidiStream\fP *stream)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SH "Macro Definition Documentation"
.PP 
.SS "#define Pm_Channel(channel)   (1<<(channel))"

.PP
Definition at line 436 of file portmidi\&.h\&.
.SS "#define PM_FILT_ACTIVE   (1 << 0x0E)"
filter active sensing messages (0xFE): 
.PP
Definition at line 390 of file portmidi\&.h\&.
.SS "#define PM_FILT_AFTERTOUCH   (\fBPM_FILT_CHANNEL_AFTERTOUCH\fP | \fBPM_FILT_POLY_AFTERTOUCH\fP)"
filter both channel and poly aftertouch 
.PP
Definition at line 415 of file portmidi\&.h\&.
.SS "#define PM_FILT_CHANNEL_AFTERTOUCH   (1 << 0x1D)"
filter channel aftertouch (most midi controllers use this) (0xD0-0xDF) 
.PP
Definition at line 411 of file portmidi\&.h\&.
.SS "#define PM_FILT_CLOCK   (1 << 0x08)"
filter MIDI clock message (0xF8) 
.PP
Definition at line 394 of file portmidi\&.h\&.
.SS "#define PM_FILT_CONTROL   (1 << 0x1B)"
Control Changes (CC's) (0xB0-0xBF) 
.PP
Definition at line 419 of file portmidi\&.h\&.
.SS "#define PM_FILT_FD   (1 << 0x0D)"
filter undefined FD messages 
.PP
Definition at line 400 of file portmidi\&.h\&.
.SS "#define PM_FILT_MTC   (1 << 0x01)"
MIDI Time Code (0xF1) 
.PP
Definition at line 423 of file portmidi\&.h\&.
.SS "#define PM_FILT_NOTE   ((1 << 0x19) | (1 << 0x18))"
filter note-on and note-off (0x90-0x9F and 0x80-0x8F 
.PP
Definition at line 409 of file portmidi\&.h\&.
.SS "#define PM_FILT_PITCHBEND   (1 << 0x1E)"
Pitch Bender (0xE0-0xEF 
.PP
Definition at line 421 of file portmidi\&.h\&.
.SS "#define PM_FILT_PLAY   ((1 << 0x0A) | (1 << 0x0C) | (1 << 0x0B))"
filter play messages (start 0xFA, stop 0xFC, continue 0xFB) 
.PP
Definition at line 396 of file portmidi\&.h\&.
.SS "#define PM_FILT_POLY_AFTERTOUCH   (1 << 0x1A)"
per-note aftertouch (0xA0-0xAF) 
.PP
Definition at line 413 of file portmidi\&.h\&.
.SS "#define PM_FILT_PROGRAM   (1 << 0x1C)"
Program changes (0xC0-0xCF) 
.PP
Definition at line 417 of file portmidi\&.h\&.
.SS "#define PM_FILT_REALTIME"
\fBValue:\fP
.PP
.nf
(PM_FILT_ACTIVE | PM_FILT_SYSEX | PM_FILT_CLOCK | \
    PM_FILT_PLAY | PM_FILT_UNDEFINED | PM_FILT_RESET | PM_FILT_TICK)
.fi
filter all real-time messages 
.PP
Definition at line 406 of file portmidi\&.h\&.
.SS "#define PM_FILT_RESET   (1 << 0x0F)"
filter reset messages (0xFF) 
.PP
Definition at line 404 of file portmidi\&.h\&.
.SS "#define PM_FILT_SONG_POSITION   (1 << 0x02)"
Song Position (0xF2) 
.PP
Definition at line 425 of file portmidi\&.h\&.
.SS "#define PM_FILT_SONG_SELECT   (1 << 0x03)"
Song Select (0xF3) 
.PP
Definition at line 427 of file portmidi\&.h\&.
.SS "#define PM_FILT_SYSEX   (1 << 0x00)"
filter system exclusive messages (0xF0): 
.PP
Definition at line 392 of file portmidi\&.h\&.
.SS "#define PM_FILT_SYSTEMCOMMON   (\fBPM_FILT_MTC\fP | \fBPM_FILT_SONG_POSITION\fP | \fBPM_FILT_SONG_SELECT\fP | \fBPM_FILT_TUNE\fP)"
All System Common messages (mtc, song position, song select, tune request) 
.PP
Definition at line 431 of file portmidi\&.h\&.
.SS "#define PM_FILT_TICK   (1 << 0x09)"
filter tick messages (0xF9) 
.PP
Definition at line 398 of file portmidi\&.h\&.
.SS "#define PM_FILT_TUNE   (1 << 0x06)"
Tuning request (0xF6) 
.PP
Definition at line 429 of file portmidi\&.h\&.
.SS "#define PM_FILT_UNDEFINED   \fBPM_FILT_FD\fP"
filter undefined real-time messages 
.PP
Definition at line 402 of file portmidi\&.h\&.
.SS "#define Pm_Message(\fBstatus\fP, data1, data2)"
\fBValue:\fP
.PP
.nf
((((data2) << 16) & 0xFF0000) | \
          (((data1) << 8) & 0xFF00) | \
          ((status) & 0xFF))
.fi
\fBPm_Message()\fP encodes a short Midi message into a 32-bit word\&. If data1 and/or data2 are not present, use zero\&.
.PP
\fBPm_MessageStatus()\fP, \fBPm_MessageData1()\fP, and \fBPm_MessageData2()\fP extract fields from a 32-bit midi message\&. 
.PP
Definition at line 504 of file portmidi\&.h\&.
.SS "#define Pm_MessageData1(msg)   (((msg) >> 8) & 0xFF)"

.PP
Definition at line 509 of file portmidi\&.h\&.
.SS "#define Pm_MessageData2(msg)   (((msg) >> 16) & 0xFF)"

.PP
Definition at line 510 of file portmidi\&.h\&.
.SS "#define Pm_MessageStatus(msg)   ((msg) & 0xFF)"

.PP
Definition at line 508 of file portmidi\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef \fBint32_t\fP \fBPmMessage\fP"
see \fBPmEvent\fP 
.PP
Definition at line 512 of file portmidi\&.h\&.
.SH "Function Documentation"
.PP 
.SS "\fBPMEXPORT\fP \fBPmError\fP Pm_Abort (\fBPortMidiStream\fP * stream)"
\fBPm_Abort()\fP terminates outgoing messages immediately The caller should immediately close the output port; this call may result in transmission of a partial midi message\&. There is no abort for Midi input because the user can simply ignore messages in the buffer and close an input device at any time\&. 
.PP
Definition at line 906 of file portmidi\&.c\&.
.SS "\fBPMEXPORT\fP \fBPmError\fP Pm_Close (\fBPortMidiStream\fP * stream)"
\fBPm_Close()\fP closes a midi stream, flushing any pending buffers\&. (PortMidi attempts to close open streams when the application exits -- this is particularly difficult under Windows\&.) 
.PP
Definition at line 860 of file portmidi\&.c\&.
.SS "\fBPMEXPORT\fP \fBPmError\fP Pm_SetChannelMask (\fBPortMidiStream\fP * stream, \fBint\fP mask)"
\fBPm_SetChannelMask()\fP filters incoming messages based on channel\&. The mask is a 16-bit bitfield corresponding to appropriate channels\&. The Pm_Channel macro can assist in calling this function\&. i\&.e\&. to set receive only input on channel 1, call with Pm_SetChannelMask(Pm_Channel(1)); Multiple channels should be OR'd together, like Pm_SetChannelMask(\fBPm_Channel(10)\fP | \fBPm_Channel(11)\fP)
.PP
Note that channels are numbered 0 to 15 (not 1 to 16)\&. Most synthesizer and interfaces number channels starting at 1, but PortMidi numbers channels starting at 0\&.
.PP
All channels are allowed by default 
.PP
Definition at line 831 of file portmidi\&.c\&.
.SS "\fBPMEXPORT\fP \fBPmError\fP Pm_SetFilter (\fBPortMidiStream\fP * stream, \fBint32_t\fP filters)"

.PP
Definition at line 845 of file portmidi\&.c\&.
.SS "\fBPmError\fP Pm_Synchronize (\fBPortMidiStream\fP * stream)"
\fBPm_Synchronize()\fP instructs PortMidi to (re)synchronize to the time_proc passed when the stream was opened\&. Typically, this is used when the stream must be opened before the time_proc reference is actually advancing\&. In this case, message timing may be erratic, but since timestamps of zero mean 'send immediately,' initialization messages with zero timestamps can be written without a functioning time reference and without problems\&. Before the first MIDI message with a non-zero timestamp is written to the stream, the time reference must begin to advance (for example, if the time_proc computes time based on audio samples, time might begin to advance when an audio stream becomes active)\&. After time_proc return values become valid, and BEFORE writing the first non-zero timestamped MIDI message, call \fBPm_Synchronize()\fP so that PortMidi can observe the difference between the current time_proc value and its MIDI stream time\&.
.PP
In the more normal case where time_proc values advance continuously, there is no need to call Pm_Synchronize\&. PortMidi will always synchronize at the first output message and periodically thereafter\&. 
.PP
Definition at line 892 of file portmidi\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Audacity from the source code\&.
