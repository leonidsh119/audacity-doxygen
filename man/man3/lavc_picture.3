.TH "lavc_picture" 3 "Thu Apr 28 2016" "Audacity" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lavc_picture \- AVPicture
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBAVPicture\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBAVPicture\fP \fBAVPicture\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBint\fP \fBavpicture_alloc\fP (\fBAVPicture\fP *picture, enum \fBAVPixelFormat\fP pix_fmt, \fBint\fP width, \fBint\fP height)"
.br
.ti -1c
.RI "\fBvoid\fP \fBavpicture_free\fP (\fBAVPicture\fP *picture)"
.br
.ti -1c
.RI "\fBint\fP \fBavpicture_fill\fP (\fBAVPicture\fP *picture, \fBconst\fP \fBuint8_t\fP *ptr, enum \fBAVPixelFormat\fP pix_fmt, \fBint\fP width, \fBint\fP height)"
.br
.ti -1c
.RI "\fBint\fP \fBavpicture_layout\fP (\fBconst\fP \fBAVPicture\fP *src, enum \fBAVPixelFormat\fP pix_fmt, \fBint\fP width, \fBint\fP height, unsigned char *dest, \fBint\fP dest_size)"
.br
.ti -1c
.RI "\fBint\fP \fBavpicture_get_size\fP (enum \fBAVPixelFormat\fP pix_fmt, \fBint\fP width, \fBint\fP height)"
.br
.ti -1c
.RI "\fBattribute_deprecated\fP \fBint\fP \fBavpicture_deinterlace\fP (\fBAVPicture\fP *dst, \fBconst\fP \fBAVPicture\fP *src, enum \fBAVPixelFormat\fP pix_fmt, \fBint\fP width, \fBint\fP height)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_picture_copy\fP (\fBAVPicture\fP *dst, \fBconst\fP \fBAVPicture\fP *src, enum \fBAVPixelFormat\fP pix_fmt, \fBint\fP width, \fBint\fP height)"
.br
.ti -1c
.RI "\fBint\fP \fBav_picture_crop\fP (\fBAVPicture\fP *dst, \fBconst\fP \fBAVPicture\fP *src, enum \fBAVPixelFormat\fP pix_fmt, \fBint\fP top_band, \fBint\fP left_band)"
.br
.ti -1c
.RI "\fBint\fP \fBav_picture_pad\fP (\fBAVPicture\fP *dst, \fBconst\fP \fBAVPicture\fP *src, \fBint\fP height, \fBint\fP width, enum \fBAVPixelFormat\fP pix_fmt, \fBint\fP padtop, \fBint\fP padbottom, \fBint\fP padleft, \fBint\fP padright, \fBint\fP *color)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Functions for working with \fBAVPicture\fP 
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBAVPicture\fP  \fBAVPicture\fP"
Picture data structure\&.
.PP
Up to four components can be stored into it, the last component is alpha\&. 
.SH "Function Documentation"
.PP 
.SS "\fBvoid\fP av_picture_copy (\fBAVPicture\fP * dst, \fBconst\fP \fBAVPicture\fP * src, enum \fBAVPixelFormat\fP pix_fmt, \fBint\fP width, \fBint\fP height)"
Copy image src to dst\&. Wraps \fBav_image_copy()\fP\&. 
.SS "\fBint\fP av_picture_crop (\fBAVPicture\fP * dst, \fBconst\fP \fBAVPicture\fP * src, enum \fBAVPixelFormat\fP pix_fmt, \fBint\fP top_band, \fBint\fP left_band)"
Crop image top and left side\&. 
.SS "\fBint\fP av_picture_pad (\fBAVPicture\fP * dst, \fBconst\fP \fBAVPicture\fP * src, \fBint\fP height, \fBint\fP width, enum \fBAVPixelFormat\fP pix_fmt, \fBint\fP padtop, \fBint\fP padbottom, \fBint\fP padleft, \fBint\fP padright, \fBint\fP * color)"
Pad image\&. 
.SS "\fBint\fP avpicture_alloc (\fBAVPicture\fP * picture, enum \fBAVPixelFormat\fP pix_fmt, \fBint\fP width, \fBint\fP height)"
Allocate memory for the pixels of a picture and setup the \fBAVPicture\fP fields for it\&.
.PP
Call \fBavpicture_free()\fP to free it\&.
.PP
\fBParameters:\fP
.RS 4
\fIpicture\fP the picture structure to be filled in 
.br
\fIpix_fmt\fP the pixel format of the picture 
.br
\fIwidth\fP the width of the picture 
.br
\fIheight\fP the height of the picture 
.RE
.PP
\fBReturns:\fP
.RS 4
zero if successful, a negative error code otherwise
.RE
.PP
\fBSee also:\fP
.RS 4
\fBav_image_alloc()\fP, \fBavpicture_fill()\fP 
.RE
.PP

.SS "\fBattribute_deprecated\fP \fBint\fP avpicture_deinterlace (\fBAVPicture\fP * dst, \fBconst\fP \fBAVPicture\fP * src, enum \fBAVPixelFormat\fP pix_fmt, \fBint\fP width, \fBint\fP height)"
deinterlace - if not supported return -1
.PP
\fBDeprecated\fP
.RS 4
.IP "\(bu" 2
use yadif (in libavfilter) instead 
.PP
.RE
.PP

.SS "\fBint\fP avpicture_fill (\fBAVPicture\fP * picture, \fBconst\fP \fBuint8_t\fP * ptr, enum \fBAVPixelFormat\fP pix_fmt, \fBint\fP width, \fBint\fP height)"
Setup the picture fields based on the specified image parameters and the provided image data buffer\&.
.PP
The picture fields are filled in by using the image data buffer pointed to by ptr\&.
.PP
If ptr is NULL, the function will fill only the picture linesize array and return the required size for the image buffer\&.
.PP
To allocate an image buffer and fill the picture data in one call, use \fBavpicture_alloc()\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIpicture\fP the picture to be filled in 
.br
\fIptr\fP buffer where the image data is stored, or NULL 
.br
\fIpix_fmt\fP the pixel format of the image 
.br
\fIwidth\fP the width of the image in pixels 
.br
\fIheight\fP the height of the image in pixels 
.RE
.PP
\fBReturns:\fP
.RS 4
the size in bytes required for src, a negative error code in case of failure
.RE
.PP
\fBSee also:\fP
.RS 4
\fBav_image_fill_arrays()\fP 
.RE
.PP

.SS "\fBvoid\fP avpicture_free (\fBAVPicture\fP * picture)"
Free a picture previously allocated by \fBavpicture_alloc()\fP\&. The data buffer used by the \fBAVPicture\fP is freed, but the \fBAVPicture\fP structure itself is not\&.
.PP
\fBParameters:\fP
.RS 4
\fIpicture\fP the \fBAVPicture\fP to be freed 
.RE
.PP

.SS "\fBint\fP avpicture_get_size (enum \fBAVPixelFormat\fP pix_fmt, \fBint\fP width, \fBint\fP height)"
Calculate the size in bytes that a picture of the given width and height would occupy if stored in the given picture format\&.
.PP
\fBParameters:\fP
.RS 4
\fIpix_fmt\fP picture pixel format 
.br
\fIwidth\fP picture width 
.br
\fIheight\fP picture height 
.RE
.PP
\fBReturns:\fP
.RS 4
the computed picture buffer size or a negative error code in case of error
.RE
.PP
\fBSee also:\fP
.RS 4
\fBav_image_get_buffer_size()\fP\&. 
.RE
.PP

.SS "\fBint\fP avpicture_layout (\fBconst\fP \fBAVPicture\fP * src, enum \fBAVPixelFormat\fP pix_fmt, \fBint\fP width, \fBint\fP height, unsigned char * dest, \fBint\fP dest_size)"
Copy pixel data from an \fBAVPicture\fP into a buffer\&.
.PP
\fBavpicture_get_size()\fP can be used to compute the required size for the buffer to fill\&.
.PP
\fBParameters:\fP
.RS 4
\fIsrc\fP source picture with filled data 
.br
\fIpix_fmt\fP picture pixel format 
.br
\fIwidth\fP picture width 
.br
\fIheight\fP picture height 
.br
\fIdest\fP destination buffer 
.br
\fIdest_size\fP destination buffer size in bytes 
.RE
.PP
\fBReturns:\fP
.RS 4
the number of bytes written to dest, or a negative value (error code) on error, for example if the destination buffer is not big enough
.RE
.PP
\fBSee also:\fP
.RS 4
\fBav_image_copy_to_buffer()\fP 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Audacity from the source code\&.
