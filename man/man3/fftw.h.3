.TH "C:/_dev/OpenU/Audacity/audacity/lib-src/libnyquist/nyquist/nyqsrc/fftw.h" 3 "Thu Apr 28 2016" "Audacity" \" -*- nroff -*-
.ad l
.nh
.SH NAME
C:/_dev/OpenU/Audacity/audacity/lib-src/libnyquist/nyquist/nyqsrc/fftw.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stdlib\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBfftw_complex\fP"
.br
.ti -1c
.RI "struct \fBfftw_codelet_desc\fP"
.br
.ti -1c
.RI "struct \fBfftw_twiddle_struct\fP"
.br
.ti -1c
.RI "struct \fBfftw_rader_data_struct\fP"
.br
.ti -1c
.RI "struct \fBfftw_plan_node_struct\fP"
.br
.ti -1c
.RI "struct \fBfftw_plan_struct\fP"
.br
.ti -1c
.RI "struct \fBfftwnd_data\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBc_re\fP(\fBc\fP)   ((\fBc\fP)\&.re)"
.br
.ti -1c
.RI "#define \fBc_im\fP(\fBc\fP)   ((\fBc\fP)\&.im)"
.br
.ti -1c
.RI "#define \fBFFTW_1_0_COMPATIBILITY\fP   0"
.br
.ti -1c
.RI "#define \fBDL_IMPORT\fP(type)   type"
.br
.ti -1c
.RI "#define \fBFFTW_ESTIMATE\fP   (0)"
.br
.ti -1c
.RI "#define \fBFFTW_MEASURE\fP   (1)"
.br
.ti -1c
.RI "#define \fBFFTW_OUT_OF_PLACE\fP   (0)"
.br
.ti -1c
.RI "#define \fBFFTW_IN_PLACE\fP   (8)"
.br
.ti -1c
.RI "#define \fBFFTW_USE_WISDOM\fP   (16)"
.br
.ti -1c
.RI "#define \fBFFTW_THREADSAFE\fP"
.br
.ti -1c
.RI "#define \fBFFTWND_FORCE_BUFFERED\fP   (256)	/* internal, undocumented flag */"
.br
.ti -1c
.RI "#define \fBFFTW_HAS_PLAN_SPECIFIC\fP"
.br
.ti -1c
.RI "#define \fBFFTW_HAS_WISDOM\fP"
.br
.ti -1c
.RI "#define \fBFFTW_HAS_FPRINT_PLAN\fP"
.br
.ti -1c
.RI "#define \fBFFTWND_HAS_PRINT_PLAN\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef double \fBfftw_real\fP"
.br
.ti -1c
.RI "typedef \fBfftw_complex\fP \fBFFTW_COMPLEX\fP"
.br
.ti -1c
.RI "typedef \fBfftw_real\fP \fBFFTW_REAL\fP"
.br
.ti -1c
.RI "typedef \fBvoid\fP( \fBfftw_notw_codelet\fP) (\fBconst\fP \fBfftw_complex\fP *, \fBfftw_complex\fP *, \fBint\fP, \fBint\fP)"
.br
.ti -1c
.RI "typedef \fBvoid\fP( \fBfftw_twiddle_codelet\fP) (\fBfftw_complex\fP *, \fBconst\fP \fBfftw_complex\fP *, \fBint\fP, \fBint\fP, \fBint\fP)"
.br
.ti -1c
.RI "typedef \fBvoid\fP( \fBfftw_generic_codelet\fP) (\fBfftw_complex\fP *, \fBconst\fP \fBfftw_complex\fP *, \fBint\fP, \fBint\fP, \fBint\fP, \fBint\fP)"
.br
.ti -1c
.RI "typedef \fBvoid\fP( \fBfftw_real2hc_codelet\fP) (\fBconst\fP \fBfftw_real\fP *, \fBfftw_real\fP *, \fBfftw_real\fP *, \fBint\fP, \fBint\fP, \fBint\fP)"
.br
.ti -1c
.RI "typedef \fBvoid\fP( \fBfftw_hc2real_codelet\fP) (\fBconst\fP \fBfftw_real\fP *, \fBconst\fP \fBfftw_real\fP *, \fBfftw_real\fP *, \fBint\fP, \fBint\fP, \fBint\fP)"
.br
.ti -1c
.RI "typedef \fBvoid\fP( \fBfftw_hc2hc_codelet\fP) (\fBfftw_real\fP *, \fBconst\fP \fBfftw_complex\fP *, \fBint\fP, \fBint\fP, \fBint\fP)"
.br
.ti -1c
.RI "typedef \fBvoid\fP( \fBfftw_rgeneric_codelet\fP) (\fBfftw_real\fP *, \fBconst\fP \fBfftw_complex\fP *, \fBint\fP, \fBint\fP, \fBint\fP, \fBint\fP)"
.br
.ti -1c
.RI "typedef struct \fBfftw_twiddle_struct\fP \fBfftw_twiddle\fP"
.br
.ti -1c
.RI "typedef struct \fBfftw_rader_data_struct\fP \fBfftw_rader_data\fP"
.br
.ti -1c
.RI "typedef \fBvoid\fP( \fBfftw_rader_codelet\fP) (\fBfftw_complex\fP *, \fBconst\fP \fBfftw_complex\fP *, \fBint\fP, \fBint\fP, \fBint\fP, \fBfftw_rader_data\fP *)"
.br
.ti -1c
.RI "typedef struct \fBfftw_plan_node_struct\fP \fBfftw_plan_node\fP"
.br
.ti -1c
.RI "typedef struct \fBfftw_plan_struct\fP * \fBfftw_plan\fP"
.br
.ti -1c
.RI "typedef \fBvoid\fP *(* \fBfftw_malloc_type_function\fP) (size_t n)"
.br
.ti -1c
.RI "typedef \fBvoid\fP(* \fBfftw_free_type_function\fP) (\fBvoid\fP *\fBp\fP)"
.br
.ti -1c
.RI "typedef \fBvoid\fP(* \fBfftw_die_type_function\fP) (\fBconst\fP char *errString)"
.br
.ti -1c
.RI "typedef \fBfftwnd_data\fP * \fBfftwnd_plan\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBfftw_direction\fP { \fBFFTW_FORWARD\fP = -1, \fBFFTW_BACKWARD\fP = 1 }"
.br
.ti -1c
.RI "enum \fBfftw_status\fP { \fBFFTW_SUCCESS\fP = 0, \fBFFTW_FAILURE\fP = -1 }"
.br
.ti -1c
.RI "enum \fBfftw_node_type\fP { \fBFFTW_NOTW\fP, \fBFFTW_TWIDDLE\fP, \fBFFTW_GENERIC\fP, \fBFFTW_RADER\fP, \fBFFTW_REAL2HC\fP, \fBFFTW_HC2REAL\fP, \fBFFTW_HC2HC\fP, \fBFFTW_RGENERIC\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBDL_IMPORT\fP (\fBconst\fP char *) fftw_version"
.br
.ti -1c
.RI "\fBfftw_plan\fP \fBfftw_create_plan_specific\fP (\fBint\fP n, \fBfftw_direction\fP dir, \fBint\fP flags, \fBfftw_complex\fP *\fBin\fP, \fBint\fP istride, \fBfftw_complex\fP *\fBout\fP, \fBint\fP ostride)"
.br
.ti -1c
.RI "\fBfftw_plan\fP \fBfftw_create_plan\fP (\fBint\fP n, \fBfftw_direction\fP dir, \fBint\fP flags)"
.br
.ti -1c
.RI "\fBvoid\fP \fBfftw_print_plan\fP (\fBfftw_plan\fP plan)"
.br
.ti -1c
.RI "\fBvoid\fP \fBfftw_destroy_plan\fP (\fBfftw_plan\fP plan)"
.br
.ti -1c
.RI "\fBvoid\fP \fBfftw\fP (\fBfftw_plan\fP plan, \fBint\fP howmany, \fBfftw_complex\fP *\fBin\fP, \fBint\fP istride, \fBint\fP idist, \fBfftw_complex\fP *\fBout\fP, \fBint\fP ostride, \fBint\fP odist)"
.br
.ti -1c
.RI "\fBvoid\fP \fBfftw_one\fP (\fBfftw_plan\fP plan, \fBfftw_complex\fP *\fBin\fP, \fBfftw_complex\fP *\fBout\fP)"
.br
.ti -1c
.RI "\fBvoid\fP \fBfftw_die\fP (\fBconst\fP char *\fBs\fP)"
.br
.ti -1c
.RI "\fBvoid\fP * \fBfftw_malloc\fP (size_t n)"
.br
.ti -1c
.RI "\fBvoid\fP \fBfftw_free\fP (\fBvoid\fP *\fBp\fP)"
.br
.ti -1c
.RI "\fBvoid\fP \fBfftw_check_memory_leaks\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBvoid\fP \fBfftw_print_max_memory_usage\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBDL_IMPORT\fP (\fBfftw_malloc_type_function\fP) fftw_malloc_hook"
.br
.ti -1c
.RI "\fBDL_IMPORT\fP (\fBfftw_free_type_function\fP) fftw_free_hook"
.br
.ti -1c
.RI "\fBDL_IMPORT\fP (\fBfftw_die_type_function\fP) fftw_die_hook"
.br
.ti -1c
.RI "size_t \fBfftw_sizeof_fftw_real\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBvoid\fP \fBfftw_forget_wisdom\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBvoid\fP \fBfftw_export_wisdom\fP (\fBvoid\fP(*emitter)(char \fBc\fP, \fBvoid\fP *), \fBvoid\fP *\fBdata\fP)"
.br
.ti -1c
.RI "\fBfftw_status\fP \fBfftw_import_wisdom\fP (\fBint\fP(*g)(\fBvoid\fP *), \fBvoid\fP *\fBdata\fP)"
.br
.ti -1c
.RI "\fBvoid\fP \fBfftw_export_wisdom_to_file\fP (FILE *output_file)"
.br
.ti -1c
.RI "\fBfftw_status\fP \fBfftw_import_wisdom_from_file\fP (FILE *input_file)"
.br
.ti -1c
.RI "char * \fBfftw_export_wisdom_to_string\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBfftw_status\fP \fBfftw_import_wisdom_from_string\fP (\fBconst\fP char *input_string)"
.br
.ti -1c
.RI "\fBvoid\fP \fBfftw_fprint_plan\fP (FILE *\fBf\fP, \fBfftw_plan\fP plan)"
.br
.ti -1c
.RI "\fBfftwnd_plan\fP \fBfftw2d_create_plan\fP (\fBint\fP nx, \fBint\fP ny, \fBfftw_direction\fP dir, \fBint\fP flags)"
.br
.ti -1c
.RI "\fBfftwnd_plan\fP \fBfftw3d_create_plan\fP (\fBint\fP nx, \fBint\fP ny, \fBint\fP nz, \fBfftw_direction\fP dir, \fBint\fP flags)"
.br
.ti -1c
.RI "\fBfftwnd_plan\fP \fBfftwnd_create_plan\fP (\fBint\fP rank, \fBconst\fP \fBint\fP *n, \fBfftw_direction\fP dir, \fBint\fP flags)"
.br
.ti -1c
.RI "\fBfftwnd_plan\fP \fBfftw2d_create_plan_specific\fP (\fBint\fP nx, \fBint\fP ny, \fBfftw_direction\fP dir, \fBint\fP flags, \fBfftw_complex\fP *\fBin\fP, \fBint\fP istride, \fBfftw_complex\fP *\fBout\fP, \fBint\fP ostride)"
.br
.ti -1c
.RI "\fBfftwnd_plan\fP \fBfftw3d_create_plan_specific\fP (\fBint\fP nx, \fBint\fP ny, \fBint\fP nz, \fBfftw_direction\fP dir, \fBint\fP flags, \fBfftw_complex\fP *\fBin\fP, \fBint\fP istride, \fBfftw_complex\fP *\fBout\fP, \fBint\fP ostride)"
.br
.ti -1c
.RI "\fBfftwnd_plan\fP \fBfftwnd_create_plan_specific\fP (\fBint\fP rank, \fBconst\fP \fBint\fP *n, \fBfftw_direction\fP dir, \fBint\fP flags, \fBfftw_complex\fP *\fBin\fP, \fBint\fP istride, \fBfftw_complex\fP *\fBout\fP, \fBint\fP ostride)"
.br
.ti -1c
.RI "\fBvoid\fP \fBfftwnd_destroy_plan\fP (\fBfftwnd_plan\fP plan)"
.br
.ti -1c
.RI "\fBvoid\fP \fBfftwnd_fprint_plan\fP (FILE *\fBf\fP, \fBfftwnd_plan\fP \fBp\fP)"
.br
.ti -1c
.RI "\fBvoid\fP \fBfftwnd_print_plan\fP (\fBfftwnd_plan\fP \fBp\fP)"
.br
.ti -1c
.RI "\fBvoid\fP \fBfftwnd\fP (\fBfftwnd_plan\fP plan, \fBint\fP howmany, \fBfftw_complex\fP *\fBin\fP, \fBint\fP istride, \fBint\fP idist, \fBfftw_complex\fP *\fBout\fP, \fBint\fP ostride, \fBint\fP odist)"
.br
.ti -1c
.RI "\fBvoid\fP \fBfftwnd_one\fP (\fBfftwnd_plan\fP \fBp\fP, \fBfftw_complex\fP *\fBin\fP, \fBfftw_complex\fP *\fBout\fP)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define c_im(\fBc\fP)   ((\fBc\fP)\&.im)"

.PP
Definition at line 56 of file fftw\&.h\&.
.SS "#define c_re(\fBc\fP)   ((\fBc\fP)\&.re)"

.PP
Definition at line 55 of file fftw\&.h\&.
.SS "#define DL_IMPORT(type)   type"

.PP
Definition at line 147 of file fftw\&.h\&.
.SS "#define FFTW_1_0_COMPATIBILITY   0"

.PP
Definition at line 67 of file fftw\&.h\&.
.SS "#define FFTW_ESTIMATE   (0)"

.PP
Definition at line 277 of file fftw\&.h\&.
.SS "#define FFTW_HAS_FPRINT_PLAN"

.PP
Definition at line 334 of file fftw\&.h\&.
.SS "#define FFTW_HAS_PLAN_SPECIFIC"

.PP
Definition at line 294 of file fftw\&.h\&.
.SS "#define FFTW_HAS_WISDOM"

.PP
Definition at line 321 of file fftw\&.h\&.
.SS "#define FFTW_IN_PLACE   (8)"

.PP
Definition at line 281 of file fftw\&.h\&.
.SS "#define FFTW_MEASURE   (1)"

.PP
Definition at line 278 of file fftw\&.h\&.
.SS "#define FFTW_OUT_OF_PLACE   (0)"

.PP
Definition at line 280 of file fftw\&.h\&.
.SS "#define FFTW_THREADSAFE"
\fBValue:\fP
.PP
.nf
(128)  /* guarantee plan is read-only so that the
                                  same plan can be used in parallel by
                                  multiple threads */
.fi
.PP
Definition at line 284 of file fftw\&.h\&.
.SS "#define FFTW_USE_WISDOM   (16)"

.PP
Definition at line 282 of file fftw\&.h\&.
.SS "#define FFTWND_FORCE_BUFFERED   (256)	/* internal, undocumented flag */"

.PP
Definition at line 288 of file fftw\&.h\&.
.SS "#define FFTWND_HAS_PRINT_PLAN"

.PP
Definition at line 400 of file fftw\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef \fBfftw_complex\fP \fBFFTW_COMPLEX\fP"

.PP
Definition at line 63 of file fftw\&.h\&.
.SS "typedef \fBvoid\fP(* fftw_die_type_function) (\fBconst\fP char *errString)"

.PP
Definition at line 309 of file fftw\&.h\&.
.SS "typedef \fBvoid\fP(* fftw_free_type_function) (\fBvoid\fP *\fBp\fP)"

.PP
Definition at line 308 of file fftw\&.h\&.
.SS "typedef \fBvoid\fP( fftw_generic_codelet) (\fBfftw_complex\fP *, \fBconst\fP \fBfftw_complex\fP *, \fBint\fP, \fBint\fP, \fBint\fP, \fBint\fP)"

.PP
Definition at line 93 of file fftw\&.h\&.
.SS "typedef \fBvoid\fP( fftw_hc2hc_codelet) (\fBfftw_real\fP *, \fBconst\fP \fBfftw_complex\fP *, \fBint\fP, \fBint\fP, \fBint\fP)"

.PP
Definition at line 102 of file fftw\&.h\&.
.SS "typedef \fBvoid\fP( fftw_hc2real_codelet) (\fBconst\fP \fBfftw_real\fP *, \fBconst\fP \fBfftw_real\fP *, \fBfftw_real\fP *, \fBint\fP, \fBint\fP, \fBint\fP)"

.PP
Definition at line 99 of file fftw\&.h\&.
.SS "typedef \fBvoid\fP*(* fftw_malloc_type_function) (size_t n)"

.PP
Definition at line 307 of file fftw\&.h\&.
.SS "typedef \fBvoid\fP( fftw_notw_codelet) (\fBconst\fP \fBfftw_complex\fP *, \fBfftw_complex\fP *, \fBint\fP, \fBint\fP)"

.PP
Definition at line 88 of file fftw\&.h\&.
.SS "typedef struct \fBfftw_plan_struct\fP* \fBfftw_plan\fP"

.PP
Definition at line 274 of file fftw\&.h\&.
.SS "typedef struct \fBfftw_plan_node_struct\fP  \fBfftw_plan_node\fP"

.SS "typedef \fBvoid\fP( fftw_rader_codelet) (\fBfftw_complex\fP *, \fBconst\fP \fBfftw_complex\fP *, \fBint\fP, \fBint\fP, \fBint\fP, \fBfftw_rader_data\fP *)"

.PP
Definition at line 183 of file fftw\&.h\&.
.SS "typedef struct \fBfftw_rader_data_struct\fP  \fBfftw_rader_data\fP"

.SS "typedef double \fBfftw_real\fP"

.PP
Definition at line 45 of file fftw\&.h\&.
.SS "typedef \fBfftw_real\fP \fBFFTW_REAL\fP"

.PP
Definition at line 64 of file fftw\&.h\&.
.SS "typedef \fBvoid\fP( fftw_real2hc_codelet) (\fBconst\fP \fBfftw_real\fP *, \fBfftw_real\fP *, \fBfftw_real\fP *, \fBint\fP, \fBint\fP, \fBint\fP)"

.PP
Definition at line 96 of file fftw\&.h\&.
.SS "typedef \fBvoid\fP( fftw_rgeneric_codelet) (\fBfftw_real\fP *, \fBconst\fP \fBfftw_complex\fP *, \fBint\fP, \fBint\fP, \fBint\fP, \fBint\fP)"

.PP
Definition at line 105 of file fftw\&.h\&.
.SS "typedef struct \fBfftw_twiddle_struct\fP  \fBfftw_twiddle\fP"

.SS "typedef \fBvoid\fP( fftw_twiddle_codelet) (\fBfftw_complex\fP *, \fBconst\fP \fBfftw_complex\fP *, \fBint\fP, \fBint\fP, \fBint\fP)"

.PP
Definition at line 90 of file fftw\&.h\&.
.SS "typedef \fBfftwnd_data\fP* \fBfftwnd_plan\fP"

.PP
Definition at line 368 of file fftw\&.h\&.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBfftw_direction\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIFFTW_FORWARD \fP\fP
.TP
\fB\fIFFTW_BACKWARD \fP\fP
.PP
Definition at line 58 of file fftw\&.h\&.
.SS "enum \fBfftw_node_type\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIFFTW_NOTW \fP\fP
.TP
\fB\fIFFTW_TWIDDLE \fP\fP
.TP
\fB\fIFFTW_GENERIC \fP\fP
.TP
\fB\fIFFTW_RADER \fP\fP
.TP
\fB\fIFFTW_REAL2HC \fP\fP
.TP
\fB\fIFFTW_HC2REAL \fP\fP
.TP
\fB\fIFFTW_HC2HC \fP\fP
.TP
\fB\fIFFTW_RGENERIC \fP\fP
.PP
Definition at line 115 of file fftw\&.h\&.
.SS "enum \fBfftw_status\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIFFTW_SUCCESS \fP\fP
.TP
\fB\fIFFTW_FAILURE \fP\fP
.PP
Definition at line 80 of file fftw\&.h\&.
.SH "Function Documentation"
.PP 
.SS "DL_IMPORT (\fBconst\fP char *)"

.SS "DL_IMPORT (\fBfftw_malloc_type_function\fP)"

.SS "DL_IMPORT (\fBfftw_free_type_function\fP)"

.SS "DL_IMPORT (\fBfftw_die_type_function\fP)"

.SS "\fBvoid\fP fftw (\fBfftw_plan\fP plan, \fBint\fP howmany, \fBfftw_complex\fP * in, \fBint\fP istride, \fBint\fP idist, \fBfftw_complex\fP * out, \fBint\fP ostride, \fBint\fP odist)"

.SS "\fBfftwnd_plan\fP fftw2d_create_plan (\fBint\fP nx, \fBint\fP ny, \fBfftw_direction\fP dir, \fBint\fP flags)"

.SS "\fBfftwnd_plan\fP fftw2d_create_plan_specific (\fBint\fP nx, \fBint\fP ny, \fBfftw_direction\fP dir, \fBint\fP flags, \fBfftw_complex\fP * in, \fBint\fP istride, \fBfftw_complex\fP * out, \fBint\fP ostride)"

.SS "\fBfftwnd_plan\fP fftw3d_create_plan (\fBint\fP nx, \fBint\fP ny, \fBint\fP nz, \fBfftw_direction\fP dir, \fBint\fP flags)"

.SS "\fBfftwnd_plan\fP fftw3d_create_plan_specific (\fBint\fP nx, \fBint\fP ny, \fBint\fP nz, \fBfftw_direction\fP dir, \fBint\fP flags, \fBfftw_complex\fP * in, \fBint\fP istride, \fBfftw_complex\fP * out, \fBint\fP ostride)"

.SS "\fBvoid\fP fftw_check_memory_leaks (\fBvoid\fP)"

.SS "\fBfftw_plan\fP fftw_create_plan (\fBint\fP n, \fBfftw_direction\fP dir, \fBint\fP flags)"

.SS "\fBfftw_plan\fP fftw_create_plan_specific (\fBint\fP n, \fBfftw_direction\fP dir, \fBint\fP flags, \fBfftw_complex\fP * in, \fBint\fP istride, \fBfftw_complex\fP * out, \fBint\fP ostride)"

.SS "\fBvoid\fP fftw_destroy_plan (\fBfftw_plan\fP plan)"

.SS "\fBvoid\fP fftw_die (\fBconst\fP char * s)"

.SS "\fBvoid\fP fftw_export_wisdom (\fBvoid\fP(*)(char \fBc\fP, \fBvoid\fP *) emitter, \fBvoid\fP * data)"

.SS "\fBvoid\fP fftw_export_wisdom_to_file (FILE * output_file)"

.SS "char* fftw_export_wisdom_to_string (\fBvoid\fP)"

.SS "\fBvoid\fP fftw_forget_wisdom (\fBvoid\fP)"

.SS "\fBvoid\fP fftw_fprint_plan (FILE * f, \fBfftw_plan\fP plan)"

.SS "\fBvoid\fP fftw_free (\fBvoid\fP * p)"

.SS "\fBfftw_status\fP fftw_import_wisdom (\fBint\fP(*)(\fBvoid\fP *) g, \fBvoid\fP * data)"

.SS "\fBfftw_status\fP fftw_import_wisdom_from_file (FILE * input_file)"

.SS "\fBfftw_status\fP fftw_import_wisdom_from_string (\fBconst\fP char * input_string)"

.SS "\fBvoid\fP* fftw_malloc (size_t n)"

.SS "\fBvoid\fP fftw_one (\fBfftw_plan\fP plan, \fBfftw_complex\fP * in, \fBfftw_complex\fP * out)"

.SS "\fBvoid\fP fftw_print_max_memory_usage (\fBvoid\fP)"

.SS "\fBvoid\fP fftw_print_plan (\fBfftw_plan\fP plan)"

.SS "size_t fftw_sizeof_fftw_real (\fBvoid\fP)"

.SS "\fBvoid\fP fftwnd (\fBfftwnd_plan\fP plan, \fBint\fP howmany, \fBfftw_complex\fP * in, \fBint\fP istride, \fBint\fP idist, \fBfftw_complex\fP * out, \fBint\fP ostride, \fBint\fP odist)"

.SS "\fBfftwnd_plan\fP fftwnd_create_plan (\fBint\fP rank, \fBconst\fP \fBint\fP * n, \fBfftw_direction\fP dir, \fBint\fP flags)"

.SS "\fBfftwnd_plan\fP fftwnd_create_plan_specific (\fBint\fP rank, \fBconst\fP \fBint\fP * n, \fBfftw_direction\fP dir, \fBint\fP flags, \fBfftw_complex\fP * in, \fBint\fP istride, \fBfftw_complex\fP * out, \fBint\fP ostride)"

.SS "\fBvoid\fP fftwnd_destroy_plan (\fBfftwnd_plan\fP plan)"

.SS "\fBvoid\fP fftwnd_fprint_plan (FILE * f, \fBfftwnd_plan\fP p)"

.SS "\fBvoid\fP fftwnd_one (\fBfftwnd_plan\fP p, \fBfftw_complex\fP * in, \fBfftw_complex\fP * out)"

.SS "\fBvoid\fP fftwnd_print_plan (\fBfftwnd_plan\fP p)"

.SH "Author"
.PP 
Generated automatically by Doxygen for Audacity from the source code\&.
