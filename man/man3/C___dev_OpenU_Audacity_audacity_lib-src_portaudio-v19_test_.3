.TH "C:/_dev/OpenU/Audacity/audacity/lib-src/portaudio-v19/test Directory Reference" 3 "Thu Apr 28 2016" "Audacity" \" -*- nroff -*-
.ad l
.nh
.SH NAME
C:/_dev/OpenU/Audacity/audacity/lib-src/portaudio-v19/test Directory Reference \- 
.SH SYNOPSIS
.br
.PP
.SS "Files"

.in +1c
.ti -1c
.RI "file \fBpa_minlat\&.c\fP"
.br
.RI "\fIExperiment with different numbers of buffers to determine the minimum latency for a computer\&. \fP"
.ti -1c
.RI "file \fBpatest1\&.c\fP"
.br
.RI "\fIRing modulate the audio input with a sine wave for 20 seconds\&. \fP"
.ti -1c
.RI "file \fBpatest_buffer\&.c\fP"
.br
.RI "\fI\fBTest\fP opening streams with different buffer sizes\&. \fP"
.ti -1c
.RI "file \fBpatest_callbackstop\&.c\fP"
.br
.RI "\fI\fBTest\fP the paComplete callback result code\&. \fP"
.ti -1c
.RI "file \fBpatest_clip\&.c\fP"
.br
.RI "\fIPlay a sine wave for several seconds at an amplitude that would require clipping\&. \fP"
.ti -1c
.RI "file \fBpatest_converters\&.c\fP"
.br
.RI "\fITests the converter functions in pa_converters\&.c\&. \fP"
.ti -1c
.RI "file \fBpatest_dither\&.c\fP"
.br
.RI "\fIAttempt to hear difference between dithered and non-dithered signal\&. \fP"
.ti -1c
.RI "file \fBpatest_dsound_find_best_latency_params\&.c\fP"
.br
.ti -1c
.RI "file \fBpatest_dsound_low_level_latency_params\&.c\fP"
.br
.ti -1c
.RI "file \fBpatest_dsound_surround\&.c\fP"
.br
.ti -1c
.RI "file \fBpatest_hang\&.c\fP"
.br
.RI "\fIPlay a sine then hang audio callback to test watchdog\&. \fP"
.ti -1c
.RI "file \fBpatest_in_overflow\&.c\fP"
.br
.RI "\fICount input overflows (using paInputOverflow flag) under overloaded and normal conditions\&. This test uses the same method to overload the stream as does patest_out_underflow\&.c -- it generates sine waves until the cpu load exceeds a certain level\&. However this test is only concerned with input and so doesn't ouput any sound\&. \fP"
.ti -1c
.RI "file \fBpatest_jack_wasapi\&.c\fP"
.br
.ti -1c
.RI "file \fBpatest_latency\&.c\fP"
.br
.RI "\fIHear the latency caused by big buffers\&. Play a sine wave and change frequency based on letter input\&. \fP"
.ti -1c
.RI "file \fBpatest_leftright\&.c\fP"
.br
.RI "\fIPlay different tone sine waves that alternate between left and right channel\&. \fP"
.ti -1c
.RI "file \fBpatest_longsine\&.c\fP"
.br
.RI "\fIPlay a sine wave until ENTER hit\&. \fP"
.ti -1c
.RI "file \fBpatest_many\&.c\fP"
.br
.RI "\fIStart and stop the PortAudio Driver multiple times\&. \fP"
.ti -1c
.RI "file \fBpatest_maxsines\&.c\fP"
.br
.RI "\fIHow many sine waves can we calculate and play in less than 80% CPU Load\&. \fP"
.ti -1c
.RI "file \fBpatest_mono\&.c\fP"
.br
.RI "\fIPlay a monophonic sine wave using the Portable Audio api for several seconds\&. \fP"
.ti -1c
.RI "file \fBpatest_multi_sine\&.c\fP"
.br
.RI "\fIPlay a different sine wave on each channel\&. \fP"
.ti -1c
.RI "file \fBpatest_out_underflow\&.c\fP"
.br
.RI "\fICount output underflows (using paOutputUnderflow flag) under overloaded and normal conditions\&. \fP"
.ti -1c
.RI "file \fBpatest_prime\&.c\fP"
.br
.RI "\fI\fBTest\fP stream priming mode\&. \fP"
.ti -1c
.RI "file \fBpatest_read_record\&.c\fP"
.br
.RI "\fIRecord input into an array; Save array to a file; Playback recorded data\&. Implemented using the blocking API (\fBPa_ReadStream()\fP, \fBPa_WriteStream()\fP ) \fP"
.ti -1c
.RI "file \fBpatest_ringmix\&.c\fP"
.br
.RI "\fIRing modulate inputs to left output, mix inputs to right output\&. \fP"
.ti -1c
.RI "file \fBpatest_sine8\&.c\fP"
.br
.RI "\fI\fBTest\fP 8 bit data: play a sine wave for several seconds\&. \fP"
.ti -1c
.RI "file \fBpatest_sine_channelmaps\&.c\fP"
.br
.RI "\fIPlays sine waves using sme simple channel maps\&. Designed for use with CoreAudio, but should made to work with other APIs\&. \fP"
.ti -1c
.RI "file \fBpatest_sine_formats\&.c\fP"
.br
.RI "\fIPlay a sine wave for several seconds\&. \fBTest\fP various data formats\&. \fP"
.ti -1c
.RI "file \fBpatest_sine_srate\&.c\fP"
.br
.ti -1c
.RI "file \fBpatest_sine_time\&.c\fP"
.br
.RI "\fIPlay a sine wave for several seconds, pausing in the middle\&. Uses the \fBPa_GetStreamTime()\fP call\&. \fP"
.ti -1c
.RI "file \fBpatest_start_stop\&.c\fP"
.br
.RI "\fIPlay a sine wave for several seconds\&. Start and stop the stream multiple times\&. \fP"
.ti -1c
.RI "file \fBpatest_stop\&.c\fP"
.br
.RI "\fI\fBTest\fP different ways of stopping audio\&. \fP"
.ti -1c
.RI "file \fBpatest_stop_playout\&.c\fP"
.br
.RI "\fI\fBTest\fP whether all queued samples are played when \fBPa_StopStream()\fP is used with a callback or read/write stream, or when the callback returns paComplete\&. \fP"
.ti -1c
.RI "file \fBpatest_suggested_vs_streaminfo_latency\&.c\fP"
.br
.RI "\fIPrint suggested vs\&. \fBPaStreamInfo\fP reported actual latency\&. \fP"
.ti -1c
.RI "file \fBpatest_suggested_vs_streaminfo_latency\&.py\fP"
.br
.ti -1c
.RI "file \fBpatest_sync\&.c\fP"
.br
.RI "\fI\fBTest\fP time stamping and synchronization of audio and video\&. \fP"
.ti -1c
.RI "file \fBpatest_timing\&.c\fP"
.br
.RI "\fIPlay a sine wave for several seconds, and spits out a ton of timing info while it's at it\&. Based on patest_sine\&.c\&. \fP"
.ti -1c
.RI "file \fBpatest_toomanysines\&.c\fP"
.br
.RI "\fIPlay more sine waves than we can handle in real time as a stress test\&. \fP"
.ti -1c
.RI "file \fBpatest_two_rates\&.c\fP"
.br
.RI "\fIPlay two streams at different rates to make sure they don't interfere\&. \fP"
.ti -1c
.RI "file \fBpatest_underflow\&.c\fP"
.br
.RI "\fISimulate an output buffer underflow condition\&. Tests whether the stream can be stopped when underflowing buffers\&. \fP"
.ti -1c
.RI "file \fBpatest_wire\&.c\fP"
.br
.RI "\fIPass input directly to output\&. \fP"
.ti -1c
.RI "file \fBpatest_wmme_find_best_latency_params\&.c\fP"
.br
.ti -1c
.RI "file \fBpatest_wmme_low_level_latency_params\&.c\fP"
.br
.ti -1c
.RI "file \fBpatest_write_stop\&.c\fP"
.br
.RI "\fIPlay a few seconds of silence followed by a few cycles of a sine wave\&. Tests to make sure that pa_StopStream() completes playback in blocking I/O\&. \fP"
.in -1c
