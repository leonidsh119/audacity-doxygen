.TH "C:/_dev/OpenU/Audacity/audacity/lib-src/portaudio-v19/src/hostapi/coreaudio/pa_mac_core_blocking.c" 3 "Thu Apr 28 2016" "Audacity" \" -*- nroff -*-
.ad l
.nh
.SH NAME
C:/_dev/OpenU/Audacity/audacity/lib-src/portaudio-v19/src/hostapi/coreaudio/pa_mac_core_blocking.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'pa_mac_core_blocking\&.h'\fP
.br
\fC#include 'pa_mac_core_internal\&.h'\fP
.br
\fC#include <assert\&.h>\fP
.br
\fC#include <libkern/OSAtomic\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "\fBPaError\fP \fBinitializeBlioRingBuffers\fP (\fBPaMacBlio\fP *blio, \fBPaSampleFormat\fP inputSampleFormat, \fBPaSampleFormat\fP outputSampleFormat, size_t framesPerBuffer, long ringBufferSize, \fBint\fP inChan, \fBint\fP outChan)"
.br
.ti -1c
.RI "\fBPaError\fP \fBresetBlioRingBuffers\fP (\fBPaMacBlio\fP *blio)"
.br
.ti -1c
.RI "\fBPaError\fP \fBdestroyBlioRingBuffers\fP (\fBPaMacBlio\fP *blio)"
.br
.ti -1c
.RI "\fBint\fP \fBBlioCallback\fP (\fBconst\fP \fBvoid\fP *input, \fBvoid\fP *\fBoutput\fP, unsigned long frameCount, \fBconst\fP \fBPaStreamCallbackTimeInfo\fP *timeInfo, \fBPaStreamCallbackFlags\fP statusFlags, \fBvoid\fP *\fBuserData\fP)"
.br
.ti -1c
.RI "\fBPaError\fP \fBReadStream\fP (\fBPaStream\fP *stream, \fBvoid\fP *\fBbuffer\fP, unsigned long frames)"
.br
.ti -1c
.RI "\fBPaError\fP \fBWriteStream\fP (\fBPaStream\fP *stream, \fBconst\fP \fBvoid\fP *\fBbuffer\fP, unsigned long frames)"
.br
.ti -1c
.RI "\fBvoid\fP \fBwaitUntilBlioWriteBufferIsFlushed\fP (\fBPaMacBlio\fP *blio)"
.br
.ti -1c
.RI "signed long \fBGetStreamReadAvailable\fP (\fBPaStream\fP *stream)"
.br
.ti -1c
.RI "signed long \fBGetStreamWriteAvailable\fP (\fBPaStream\fP *stream)"
.br
.in -1c
.SH "Detailed Description"
.PP 
This file contains the implementation required for blocking I/O\&. It is separated from pa_mac_core\&.c simply to ease development\&. 
.PP
Definition in file \fBpa_mac_core_blocking\&.c\fP\&.
.SH "Function Documentation"
.PP 
.SS "\fBint\fP BlioCallback (\fBconst\fP \fBvoid\fP * input, \fBvoid\fP * output, unsigned long frameCount, \fBconst\fP \fBPaStreamCallbackTimeInfo\fP * timeInfo, \fBPaStreamCallbackFlags\fP statusFlags, \fBvoid\fP * userData)"

.PP
Definition at line 341 of file pa_mac_core_blocking\&.c\&.
.SS "\fBPaError\fP destroyBlioRingBuffers (\fBPaMacBlio\fP * blio)"

.PP
Definition at line 309 of file pa_mac_core_blocking\&.c\&.
.SS "static signed long GetStreamReadAvailable (\fBPaStream\fP * stream)"

.PP
Definition at line 575 of file pa_mac_core_blocking\&.c\&.
.SS "static signed long GetStreamWriteAvailable (\fBPaStream\fP * stream)"

.PP
Definition at line 585 of file pa_mac_core_blocking\&.c\&.
.SS "\fBPaError\fP initializeBlioRingBuffers (\fBPaMacBlio\fP * blio, \fBPaSampleFormat\fP inputSampleFormat, \fBPaSampleFormat\fP outputSampleFormat, size_t framesPerBuffer, long ringBufferSize, \fBint\fP inChan, \fBint\fP outChan)"

.PP
Definition at line 113 of file pa_mac_core_blocking\&.c\&.
.SS "static \fBPaError\fP ReadStream (\fBPaStream\fP * stream, \fBvoid\fP * buffer, unsigned long frames)"

.PP
\fBTodo\fP
.RS 4
REVIEW: consider what to do if the input overflows\&. do we requeue all of the buffers? should we be running a thread to make sure they are always queued? see: http://www.portaudio.com/trac/ticket/117 
.RE
.PP

.PP
Definition at line 407 of file pa_mac_core_blocking\&.c\&.
.SS "\fBPaError\fP resetBlioRingBuffers (\fBPaMacBlio\fP * blio)"

.PP
Definition at line 262 of file pa_mac_core_blocking\&.c\&.
.SS "\fBvoid\fP waitUntilBlioWriteBufferIsFlushed (\fBPaMacBlio\fP * blio)"

.PP
Definition at line 562 of file pa_mac_core_blocking\&.c\&.
.SS "static \fBPaError\fP WriteStream (\fBPaStream\fP * stream, \fBconst\fP \fBvoid\fP * buffer, unsigned long frames)"

.PP
\fBTodo\fP
.RS 4
REVIEW: consider what to do if the output underflows\&. do we requeue all the existing buffers with zeros? should we run a separate thread to keep the buffers enqueued at all times? see: http://www.portaudio.com/trac/ticket/117 
.RE
.PP

.PP
Definition at line 483 of file pa_mac_core_blocking\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Audacity from the source code\&.
