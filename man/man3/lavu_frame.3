.TH "lavu_frame" 3 "Thu Apr 28 2016" "Audacity" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lavu_frame \- AVFrame
.SS "Files"

.in +1c
.ti -1c
.RI "file \fBframe\&.h\fP"
.br
.in -1c
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBAVFrameSideData\fP"
.br
.ti -1c
.RI "struct \fBAVFrame\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBAVFrameSideData\fP \fBAVFrameSideData\fP"
.br
.ti -1c
.RI "typedef struct \fBAVFrame\fP \fBAVFrame\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBAVFrameSideDataType\fP { \fBAV_FRAME_DATA_PANSCAN\fP, \fBAV_FRAME_DATA_A53_CC\fP, \fBAV_FRAME_DATA_STEREO3D\fP, \fBAV_FRAME_DATA_MATRIXENCODING\fP, \fBAV_FRAME_DATA_DOWNMIX_INFO\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBint64_t\fP \fBav_frame_get_best_effort_timestamp\fP (\fBconst\fP \fBAVFrame\fP *frame)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_frame_set_best_effort_timestamp\fP (\fBAVFrame\fP *frame, \fBint64_t\fP val)"
.br
.ti -1c
.RI "\fBint64_t\fP \fBav_frame_get_pkt_duration\fP (\fBconst\fP \fBAVFrame\fP *frame)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_frame_set_pkt_duration\fP (\fBAVFrame\fP *frame, \fBint64_t\fP val)"
.br
.ti -1c
.RI "\fBint64_t\fP \fBav_frame_get_pkt_pos\fP (\fBconst\fP \fBAVFrame\fP *frame)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_frame_set_pkt_pos\fP (\fBAVFrame\fP *frame, \fBint64_t\fP val)"
.br
.ti -1c
.RI "\fBint64_t\fP \fBav_frame_get_channel_layout\fP (\fBconst\fP \fBAVFrame\fP *frame)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_frame_set_channel_layout\fP (\fBAVFrame\fP *frame, \fBint64_t\fP val)"
.br
.ti -1c
.RI "\fBint\fP \fBav_frame_get_channels\fP (\fBconst\fP \fBAVFrame\fP *frame)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_frame_set_channels\fP (\fBAVFrame\fP *frame, \fBint\fP val)"
.br
.ti -1c
.RI "\fBint\fP \fBav_frame_get_sample_rate\fP (\fBconst\fP \fBAVFrame\fP *frame)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_frame_set_sample_rate\fP (\fBAVFrame\fP *frame, \fBint\fP val)"
.br
.ti -1c
.RI "\fBAVDictionary\fP * \fBav_frame_get_metadata\fP (\fBconst\fP \fBAVFrame\fP *frame)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_frame_set_metadata\fP (\fBAVFrame\fP *frame, \fBAVDictionary\fP *val)"
.br
.ti -1c
.RI "\fBint\fP \fBav_frame_get_decode_error_flags\fP (\fBconst\fP \fBAVFrame\fP *frame)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_frame_set_decode_error_flags\fP (\fBAVFrame\fP *frame, \fBint\fP val)"
.br
.ti -1c
.RI "\fBint\fP \fBav_frame_get_pkt_size\fP (\fBconst\fP \fBAVFrame\fP *frame)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_frame_set_pkt_size\fP (\fBAVFrame\fP *frame, \fBint\fP val)"
.br
.ti -1c
.RI "\fBAVDictionary\fP ** \fBavpriv_frame_get_metadatap\fP (\fBAVFrame\fP *frame)"
.br
.ti -1c
.RI "\fBint8_t\fP * \fBav_frame_get_qp_table\fP (\fBAVFrame\fP *\fBf\fP, \fBint\fP *stride, \fBint\fP *type)"
.br
.ti -1c
.RI "\fBint\fP \fBav_frame_set_qp_table\fP (\fBAVFrame\fP *\fBf\fP, \fBAVBufferRef\fP *\fBbuf\fP, \fBint\fP stride, \fBint\fP type)"
.br
.ti -1c
.RI "enum \fBAVColorSpace\fP \fBav_frame_get_colorspace\fP (\fBconst\fP \fBAVFrame\fP *frame)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_frame_set_colorspace\fP (\fBAVFrame\fP *frame, enum \fBAVColorSpace\fP val)"
.br
.ti -1c
.RI "enum \fBAVColorRange\fP \fBav_frame_get_color_range\fP (\fBconst\fP \fBAVFrame\fP *frame)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_frame_set_color_range\fP (\fBAVFrame\fP *frame, enum \fBAVColorRange\fP val)"
.br
.ti -1c
.RI "\fBconst\fP char * \fBav_get_colorspace_name\fP (enum \fBAVColorSpace\fP val)"
.br
.ti -1c
.RI "\fBAVFrame\fP * \fBav_frame_alloc\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_frame_free\fP (\fBAVFrame\fP **frame)"
.br
.ti -1c
.RI "\fBint\fP \fBav_frame_ref\fP (\fBAVFrame\fP *dst, \fBconst\fP \fBAVFrame\fP *src)"
.br
.ti -1c
.RI "\fBAVFrame\fP * \fBav_frame_clone\fP (\fBconst\fP \fBAVFrame\fP *src)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_frame_unref\fP (\fBAVFrame\fP *frame)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_frame_move_ref\fP (\fBAVFrame\fP *dst, \fBAVFrame\fP *src)"
.br
.ti -1c
.RI "\fBint\fP \fBav_frame_get_buffer\fP (\fBAVFrame\fP *frame, \fBint\fP align)"
.br
.ti -1c
.RI "\fBint\fP \fBav_frame_is_writable\fP (\fBAVFrame\fP *frame)"
.br
.ti -1c
.RI "\fBint\fP \fBav_frame_make_writable\fP (\fBAVFrame\fP *frame)"
.br
.ti -1c
.RI "\fBint\fP \fBav_frame_copy\fP (\fBAVFrame\fP *dst, \fBconst\fP \fBAVFrame\fP *src)"
.br
.ti -1c
.RI "\fBint\fP \fBav_frame_copy_props\fP (\fBAVFrame\fP *dst, \fBconst\fP \fBAVFrame\fP *src)"
.br
.ti -1c
.RI "\fBAVBufferRef\fP * \fBav_frame_get_plane_buffer\fP (\fBAVFrame\fP *frame, \fBint\fP plane)"
.br
.ti -1c
.RI "\fBAVFrameSideData\fP * \fBav_frame_new_side_data\fP (\fBAVFrame\fP *frame, enum \fBAVFrameSideDataType\fP type, \fBint\fP \fBsize\fP)"
.br
.ti -1c
.RI "\fBAVFrameSideData\fP * \fBav_frame_get_side_data\fP (\fBconst\fP \fBAVFrame\fP *frame, enum \fBAVFrameSideDataType\fP type)"
.br
.in -1c
.SH "Detailed Description"
.PP 
\fBAVFrame\fP is an abstraction for reference-counted raw multimedia data\&. 
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBAVFrame\fP  \fBAVFrame\fP"
This structure describes decoded (raw) audio or video data\&.
.PP
\fBAVFrame\fP must be allocated using \fBav_frame_alloc()\fP\&. Note that this only allocates the \fBAVFrame\fP itself, the buffers for the data must be managed through other means (see below)\&. \fBAVFrame\fP must be freed with \fBav_frame_free()\fP\&.
.PP
\fBAVFrame\fP is typically allocated once and then reused multiple times to hold different data (e\&.g\&. a single \fBAVFrame\fP to hold frames received from a decoder)\&. In such a case, \fBav_frame_unref()\fP will free any references held by the frame and reset it to its original clean state before it is reused again\&.
.PP
The data described by an \fBAVFrame\fP is usually reference counted through the AVBuffer API\&. The underlying buffer references are stored in \fBAVFrame\&.buf\fP / \fBAVFrame\&.extended_buf\fP\&. An \fBAVFrame\fP is considered to be reference counted if at least one reference is set, i\&.e\&. if \fBAVFrame\&.buf\fP[0] != NULL\&. In such a case, every single data plane must be contained in one of the buffers in \fBAVFrame\&.buf\fP or \fBAVFrame\&.extended_buf\fP\&. There may be a single buffer for all the data, or one separate buffer for each plane, or anything in between\&.
.PP
sizeof(AVFrame) is not a part of the public ABI, so new fields may be added to the end with a minor bump\&. Similarly fields that are marked as to be only accessed by \fBav_opt_ptr()\fP can be reordered\&. This allows 2 forks to add fields without breaking compatibility with each other\&. 
.SS "typedef struct \fBAVFrameSideData\fP  \fBAVFrameSideData\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBAVFrameSideDataType\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIAV_FRAME_DATA_PANSCAN \fP\fP
The data is the \fBAVPanScan\fP struct defined in libavcodec\&. 
.TP
\fB\fIAV_FRAME_DATA_A53_CC \fP\fP
ATSC A53 Part 4 Closed Captions\&. A53 CC bitstream is stored as uint8_t in \fBAVFrameSideData\&.data\fP\&. The number of bytes of CC data is \fBAVFrameSideData\&.size\fP\&. 
.TP
\fB\fIAV_FRAME_DATA_STEREO3D \fP\fP
Stereoscopic 3d metadata\&. The data is the \fBAVStereo3D\fP struct defined in \fBlibavutil/stereo3d\&.h\fP\&. 
.TP
\fB\fIAV_FRAME_DATA_MATRIXENCODING \fP\fP
The data is the AVMatrixEncoding enum defined in \fBlibavutil/channel_layout\&.h\fP\&. 
.TP
\fB\fIAV_FRAME_DATA_DOWNMIX_INFO \fP\fP
Metadata relevant to a downmix procedure\&. The data is the \fBAVDownmixInfo\fP struct defined in \fBlibavutil/downmix_info\&.h\fP\&. 
.PP
Definition at line 70 of file frame\&.h\&.
.SH "Function Documentation"
.PP 
.SS "\fBAVFrame\fP* av_frame_alloc (\fBvoid\fP)"
Allocate an \fBAVFrame\fP and set its fields to default values\&. The resulting struct must be freed using \fBav_frame_free()\fP\&.
.PP
\fBReturns:\fP
.RS 4
An \fBAVFrame\fP filled with default values or NULL on failure\&.
.RE
.PP
\fBNote:\fP
.RS 4
this only allocates the \fBAVFrame\fP itself, not the data buffers\&. Those must be allocated through other means, e\&.g\&. with \fBav_frame_get_buffer()\fP or manually\&. 
.RE
.PP

.SS "\fBAVFrame\fP* av_frame_clone (\fBconst\fP \fBAVFrame\fP * src)"
Create a new frame that references the same data as src\&.
.PP
This is a shortcut for \fBav_frame_alloc()\fP+av_frame_ref()\&.
.PP
\fBReturns:\fP
.RS 4
newly created \fBAVFrame\fP on success, NULL on error\&. 
.RE
.PP

.SS "\fBint\fP av_frame_copy (\fBAVFrame\fP * dst, \fBconst\fP \fBAVFrame\fP * src)"
Copy the frame data from src to dst\&.
.PP
This function does not allocate anything, dst must be already initialized and allocated with the same parameters as src\&.
.PP
This function only copies the frame data (i\&.e\&. the contents of the data / extended data arrays), not any other properties\&.
.PP
\fBReturns:\fP
.RS 4
>= 0 on success, a negative AVERROR on error\&. 
.RE
.PP

.SS "\fBint\fP av_frame_copy_props (\fBAVFrame\fP * dst, \fBconst\fP \fBAVFrame\fP * src)"
Copy only 'metadata' fields from src to dst\&.
.PP
Metadata for the purpose of this function are those fields that do not affect the data layout in the buffers\&. E\&.g\&. pts, sample rate (for audio) or sample aspect ratio (for video), but not width/height or channel layout\&. Side data is also copied\&. 
.SS "\fBvoid\fP av_frame_free (\fBAVFrame\fP ** frame)"
Free the frame and any dynamically allocated objects in it, e\&.g\&. extended_data\&. If the frame is reference counted, it will be unreferenced first\&.
.PP
\fBParameters:\fP
.RS 4
\fIframe\fP frame to be freed\&. The pointer will be set to NULL\&. 
.RE
.PP

.SS "\fBint64_t\fP av_frame_get_best_effort_timestamp (\fBconst\fP \fBAVFrame\fP * frame)"
Accessors for some \fBAVFrame\fP fields\&. The position of these field in the structure is not part of the ABI, they should not be accessed directly outside libavcodec\&. 
.SS "\fBint\fP av_frame_get_buffer (\fBAVFrame\fP * frame, \fBint\fP align)"
Allocate new \fBbuffer(s)\fP for audio or video data\&.
.PP
The following fields must be set on frame before calling this function:
.IP "\(bu" 2
format (pixel format for video, sample format for audio)
.IP "\(bu" 2
width and height for video
.IP "\(bu" 2
nb_samples and channel_layout for audio
.PP
.PP
This function will fill \fBAVFrame\&.data\fP and \fBAVFrame\&.buf\fP arrays and, if necessary, allocate and fill \fBAVFrame\&.extended_data\fP and \fBAVFrame\&.extended_buf\fP\&. For planar formats, one buffer will be allocated for each plane\&.
.PP
\fBParameters:\fP
.RS 4
\fIframe\fP frame in which to store the new buffers\&. 
.br
\fIalign\fP required buffer size alignment
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, a negative AVERROR on error\&. 
.RE
.PP

.SS "\fBint64_t\fP av_frame_get_channel_layout (\fBconst\fP \fBAVFrame\fP * frame)"

.SS "\fBint\fP av_frame_get_channels (\fBconst\fP \fBAVFrame\fP * frame)"

.SS "enum \fBAVColorRange\fP av_frame_get_color_range (\fBconst\fP \fBAVFrame\fP * frame)"

.SS "enum \fBAVColorSpace\fP av_frame_get_colorspace (\fBconst\fP \fBAVFrame\fP * frame)"

.SS "\fBint\fP av_frame_get_decode_error_flags (\fBconst\fP \fBAVFrame\fP * frame)"

.SS "\fBAVDictionary\fP* av_frame_get_metadata (\fBconst\fP \fBAVFrame\fP * frame)"

.SS "\fBint64_t\fP av_frame_get_pkt_duration (\fBconst\fP \fBAVFrame\fP * frame)"

.SS "\fBint64_t\fP av_frame_get_pkt_pos (\fBconst\fP \fBAVFrame\fP * frame)"

.SS "\fBint\fP av_frame_get_pkt_size (\fBconst\fP \fBAVFrame\fP * frame)"

.SS "\fBAVBufferRef\fP* av_frame_get_plane_buffer (\fBAVFrame\fP * frame, \fBint\fP plane)"
Get the buffer reference a given data plane is stored in\&.
.PP
\fBParameters:\fP
.RS 4
\fIplane\fP index of the data plane of interest in frame->extended_data\&.
.RE
.PP
\fBReturns:\fP
.RS 4
the buffer reference that contains the plane or NULL if the input frame is not valid\&. 
.RE
.PP

.SS "\fBint8_t\fP* av_frame_get_qp_table (\fBAVFrame\fP * f, \fBint\fP * stride, \fBint\fP * type)"

.SS "\fBint\fP av_frame_get_sample_rate (\fBconst\fP \fBAVFrame\fP * frame)"

.SS "\fBAVFrameSideData\fP* av_frame_get_side_data (\fBconst\fP \fBAVFrame\fP * frame, enum \fBAVFrameSideDataType\fP type)"

.PP
\fBReturns:\fP
.RS 4
a pointer to the side data of a given type on success, NULL if there is no side data with such type in this frame\&. 
.RE
.PP

.SS "\fBint\fP av_frame_is_writable (\fBAVFrame\fP * frame)"
Check if the frame data is writable\&.
.PP
\fBReturns:\fP
.RS 4
A positive value if the frame data is writable (which is true if and only if each of the underlying buffers has only one reference, namely the one stored in this frame)\&. Return 0 otherwise\&.
.RE
.PP
If 1 is returned the answer is valid until \fBav_buffer_ref()\fP is called on any of the underlying AVBufferRefs (e\&.g\&. through \fBav_frame_ref()\fP or directly)\&.
.PP
\fBSee also:\fP
.RS 4
\fBav_frame_make_writable()\fP, \fBav_buffer_is_writable()\fP 
.RE
.PP

.SS "\fBint\fP av_frame_make_writable (\fBAVFrame\fP * frame)"
Ensure that the frame data is writable, avoiding data copy if possible\&.
.PP
Do nothing if the frame is writable, allocate new buffers and copy the data if it is not\&.
.PP
\fBReturns:\fP
.RS 4
0 on success, a negative AVERROR on error\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBav_frame_is_writable()\fP, \fBav_buffer_is_writable()\fP, \fBav_buffer_make_writable()\fP 
.RE
.PP

.SS "\fBvoid\fP av_frame_move_ref (\fBAVFrame\fP * dst, \fBAVFrame\fP * src)"
Move everythnig contained in src to dst and reset src\&. 
.SS "\fBAVFrameSideData\fP* av_frame_new_side_data (\fBAVFrame\fP * frame, enum \fBAVFrameSideDataType\fP type, \fBint\fP size)"
Add a new side data to a frame\&.
.PP
\fBParameters:\fP
.RS 4
\fIframe\fP a frame to which the side data should be added 
.br
\fItype\fP type of the added side data 
.br
\fIsize\fP size of the side data
.RE
.PP
\fBReturns:\fP
.RS 4
newly added side data on success, NULL on error 
.RE
.PP

.SS "\fBint\fP av_frame_ref (\fBAVFrame\fP * dst, \fBconst\fP \fBAVFrame\fP * src)"
Set up a new reference to the data described by the source frame\&.
.PP
Copy frame properties from src to dst and create a new reference for each \fBAVBufferRef\fP from src\&.
.PP
If src is not reference counted, new buffers are allocated and the data is copied\&.
.PP
\fBReturns:\fP
.RS 4
0 on success, a negative AVERROR on error 
.RE
.PP

.SS "\fBvoid\fP av_frame_set_best_effort_timestamp (\fBAVFrame\fP * frame, \fBint64_t\fP val)"

.SS "\fBvoid\fP av_frame_set_channel_layout (\fBAVFrame\fP * frame, \fBint64_t\fP val)"

.SS "\fBvoid\fP av_frame_set_channels (\fBAVFrame\fP * frame, \fBint\fP val)"

.SS "\fBvoid\fP av_frame_set_color_range (\fBAVFrame\fP * frame, enum \fBAVColorRange\fP val)"

.SS "\fBvoid\fP av_frame_set_colorspace (\fBAVFrame\fP * frame, enum \fBAVColorSpace\fP val)"

.SS "\fBvoid\fP av_frame_set_decode_error_flags (\fBAVFrame\fP * frame, \fBint\fP val)"

.SS "\fBvoid\fP av_frame_set_metadata (\fBAVFrame\fP * frame, \fBAVDictionary\fP * val)"

.SS "\fBvoid\fP av_frame_set_pkt_duration (\fBAVFrame\fP * frame, \fBint64_t\fP val)"

.SS "\fBvoid\fP av_frame_set_pkt_pos (\fBAVFrame\fP * frame, \fBint64_t\fP val)"

.SS "\fBvoid\fP av_frame_set_pkt_size (\fBAVFrame\fP * frame, \fBint\fP val)"

.SS "\fBint\fP av_frame_set_qp_table (\fBAVFrame\fP * f, \fBAVBufferRef\fP * buf, \fBint\fP stride, \fBint\fP type)"

.SS "\fBvoid\fP av_frame_set_sample_rate (\fBAVFrame\fP * frame, \fBint\fP val)"

.SS "\fBvoid\fP av_frame_unref (\fBAVFrame\fP * frame)"
Unreference all the buffers referenced by frame and reset the frame fields\&. 
.SS "\fBconst\fP char* av_get_colorspace_name (enum \fBAVColorSpace\fP val)"
Get the name of a colorspace\&. 
.PP
\fBReturns:\fP
.RS 4
a static string identifying the colorspace; can be NULL\&. 
.RE
.PP

.SS "\fBAVDictionary\fP** avpriv_frame_get_metadatap (\fBAVFrame\fP * frame)"

.SH "Author"
.PP 
Generated automatically by Doxygen for Audacity from the source code\&.
