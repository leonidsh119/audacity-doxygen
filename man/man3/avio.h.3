.TH "C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavformat/avio.h" 3 "Thu Apr 28 2016" "Audacity" \" -*- nroff -*-
.ad l
.nh
.SH NAME
C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavformat/avio.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stdint\&.h>\fP
.br
\fC#include 'libavutil/common\&.h'\fP
.br
\fC#include 'libavutil/dict\&.h'\fP
.br
\fC#include 'libavutil/log\&.h'\fP
.br
\fC#include 'libavformat/version\&.h'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBAVIOInterruptCB\fP"
.br
.ti -1c
.RI "struct \fBAVIOContext\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBAVIO_SEEKABLE_NORMAL\fP   0x0001"
.br
.ti -1c
.RI "#define \fBAVSEEK_SIZE\fP   0x10000"
.br
.ti -1c
.RI "#define \fBAVSEEK_FORCE\fP   0x20000"
.br
.ti -1c
.RI "#define \fBAVIO_FLAG_NONBLOCK\fP   8"
.br
.ti -1c
.RI "#define \fBAVIO_FLAG_DIRECT\fP   0x8000"
.br
.in -1c
.PP
.RI "\fBURL open modes\fP"
.br
The flags argument to avio_open must be one of the following constants, optionally ORed with other flags\&. 
.PP
.in +1c
.in +1c
.ti -1c
.RI "#define \fBAVIO_FLAG_READ\fP   1"
.br
.ti -1c
.RI "#define \fBAVIO_FLAG_WRITE\fP   2"
.br
.ti -1c
.RI "#define \fBAVIO_FLAG_READ_WRITE\fP   (\fBAVIO_FLAG_READ\fP|\fBAVIO_FLAG_WRITE\fP)"
.br
.in -1c
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBAVIOInterruptCB\fP \fBAVIOInterruptCB\fP"
.br
.ti -1c
.RI "typedef struct \fBAVIOContext\fP \fBAVIOContext\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBconst\fP char * \fBavio_find_protocol_name\fP (\fBconst\fP char *url)"
.br
.ti -1c
.RI "\fBint\fP \fBavio_check\fP (\fBconst\fP char *url, \fBint\fP flags)"
.br
.ti -1c
.RI "\fBAVIOContext\fP * \fBavio_alloc_context\fP (unsigned char *\fBbuffer\fP, \fBint\fP buffer_size, \fBint\fP write_flag, \fBvoid\fP *opaque, \fBint\fP(*read_packet)(\fBvoid\fP *opaque, \fBuint8_t\fP *\fBbuf\fP, \fBint\fP buf_size), \fBint\fP(*write_packet)(\fBvoid\fP *opaque, \fBuint8_t\fP *\fBbuf\fP, \fBint\fP buf_size), \fBint64_t\fP(*seek)(\fBvoid\fP *opaque, \fBint64_t\fP \fBoffset\fP, \fBint\fP whence))"
.br
.ti -1c
.RI "\fBvoid\fP \fBavio_w8\fP (\fBAVIOContext\fP *\fBs\fP, \fBint\fP \fBb\fP)"
.br
.ti -1c
.RI "\fBvoid\fP \fBavio_write\fP (\fBAVIOContext\fP *\fBs\fP, \fBconst\fP unsigned char *\fBbuf\fP, \fBint\fP \fBsize\fP)"
.br
.ti -1c
.RI "\fBvoid\fP \fBavio_wl64\fP (\fBAVIOContext\fP *\fBs\fP, \fBuint64_t\fP val)"
.br
.ti -1c
.RI "\fBvoid\fP \fBavio_wb64\fP (\fBAVIOContext\fP *\fBs\fP, \fBuint64_t\fP val)"
.br
.ti -1c
.RI "\fBvoid\fP \fBavio_wl32\fP (\fBAVIOContext\fP *\fBs\fP, unsigned \fBint\fP val)"
.br
.ti -1c
.RI "\fBvoid\fP \fBavio_wb32\fP (\fBAVIOContext\fP *\fBs\fP, unsigned \fBint\fP val)"
.br
.ti -1c
.RI "\fBvoid\fP \fBavio_wl24\fP (\fBAVIOContext\fP *\fBs\fP, unsigned \fBint\fP val)"
.br
.ti -1c
.RI "\fBvoid\fP \fBavio_wb24\fP (\fBAVIOContext\fP *\fBs\fP, unsigned \fBint\fP val)"
.br
.ti -1c
.RI "\fBvoid\fP \fBavio_wl16\fP (\fBAVIOContext\fP *\fBs\fP, unsigned \fBint\fP val)"
.br
.ti -1c
.RI "\fBvoid\fP \fBavio_wb16\fP (\fBAVIOContext\fP *\fBs\fP, unsigned \fBint\fP val)"
.br
.ti -1c
.RI "\fBint\fP \fBavio_put_str\fP (\fBAVIOContext\fP *\fBs\fP, \fBconst\fP char *\fBstr\fP)"
.br
.ti -1c
.RI "\fBint\fP \fBavio_put_str16le\fP (\fBAVIOContext\fP *\fBs\fP, \fBconst\fP char *\fBstr\fP)"
.br
.ti -1c
.RI "\fBint64_t\fP \fBavio_seek\fP (\fBAVIOContext\fP *\fBs\fP, \fBint64_t\fP \fBoffset\fP, \fBint\fP whence)"
.br
.ti -1c
.RI "\fBint64_t\fP \fBavio_skip\fP (\fBAVIOContext\fP *\fBs\fP, \fBint64_t\fP \fBoffset\fP)"
.br
.ti -1c
.RI "\fBint64_t\fP \fBavio_size\fP (\fBAVIOContext\fP *\fBs\fP)"
.br
.ti -1c
.RI "\fBint\fP \fBurl_feof\fP (\fBAVIOContext\fP *\fBs\fP)"
.br
.ti -1c
.RI "\fBint\fP \fBavio_printf\fP (\fBAVIOContext\fP *\fBs\fP, \fBconst\fP char *fmt,\&.\&.\&.) \fBav_printf_format\fP(2"
.br
.ti -1c
.RI "\fBint\fP \fBvoid\fP \fBavio_flush\fP (\fBAVIOContext\fP *\fBs\fP)"
.br
.ti -1c
.RI "\fBint\fP \fBavio_read\fP (\fBAVIOContext\fP *\fBs\fP, unsigned char *\fBbuf\fP, \fBint\fP \fBsize\fP)"
.br
.ti -1c
.RI "\fBint\fP \fBavio_get_str\fP (\fBAVIOContext\fP *pb, \fBint\fP maxlen, char *\fBbuf\fP, \fBint\fP buflen)"
.br
.ti -1c
.RI "\fBint\fP \fBavio_get_str16le\fP (\fBAVIOContext\fP *pb, \fBint\fP maxlen, char *\fBbuf\fP, \fBint\fP buflen)"
.br
.ti -1c
.RI "\fBint\fP \fBavio_get_str16be\fP (\fBAVIOContext\fP *pb, \fBint\fP maxlen, char *\fBbuf\fP, \fBint\fP buflen)"
.br
.ti -1c
.RI "\fBint\fP \fBavio_open\fP (\fBAVIOContext\fP **\fBs\fP, \fBconst\fP char *url, \fBint\fP flags)"
.br
.ti -1c
.RI "\fBint\fP \fBavio_open2\fP (\fBAVIOContext\fP **\fBs\fP, \fBconst\fP char *url, \fBint\fP flags, \fBconst\fP \fBAVIOInterruptCB\fP *int_cb, \fBAVDictionary\fP **options)"
.br
.ti -1c
.RI "\fBint\fP \fBavio_close\fP (\fBAVIOContext\fP *\fBs\fP)"
.br
.ti -1c
.RI "\fBint\fP \fBavio_closep\fP (\fBAVIOContext\fP **\fBs\fP)"
.br
.ti -1c
.RI "\fBint\fP \fBavio_open_dyn_buf\fP (\fBAVIOContext\fP **\fBs\fP)"
.br
.ti -1c
.RI "\fBint\fP \fBavio_close_dyn_buf\fP (\fBAVIOContext\fP *\fBs\fP, \fBuint8_t\fP **pbuffer)"
.br
.ti -1c
.RI "\fBconst\fP char * \fBavio_enum_protocols\fP (\fBvoid\fP **opaque, \fBint\fP \fBoutput\fP)"
.br
.ti -1c
.RI "\fBint\fP \fBavio_pause\fP (\fBAVIOContext\fP *h, \fBint\fP \fBpause\fP)"
.br
.ti -1c
.RI "\fBint64_t\fP \fBavio_seek_time\fP (\fBAVIOContext\fP *h, \fBint\fP stream_index, \fBint64_t\fP timestamp, \fBint\fP flags)"
.br
.in -1c
.PP
.RI "\fBFunctions for reading from AVIOContext\fP"
.br

.PP
\fBNote:\fP
.RS 4
return 0 if EOF, so you cannot use it if EOF handling is necessary 
.RE
.PP

.PP
.in +1c
.in +1c
.ti -1c
.RI "\fBint\fP \fBavio_r8\fP (\fBAVIOContext\fP *\fBs\fP)"
.br
.ti -1c
.RI "unsigned \fBint\fP \fBavio_rl16\fP (\fBAVIOContext\fP *\fBs\fP)"
.br
.ti -1c
.RI "unsigned \fBint\fP \fBavio_rl24\fP (\fBAVIOContext\fP *\fBs\fP)"
.br
.ti -1c
.RI "unsigned \fBint\fP \fBavio_rl32\fP (\fBAVIOContext\fP *\fBs\fP)"
.br
.ti -1c
.RI "\fBuint64_t\fP \fBavio_rl64\fP (\fBAVIOContext\fP *\fBs\fP)"
.br
.ti -1c
.RI "unsigned \fBint\fP \fBavio_rb16\fP (\fBAVIOContext\fP *\fBs\fP)"
.br
.ti -1c
.RI "unsigned \fBint\fP \fBavio_rb24\fP (\fBAVIOContext\fP *\fBs\fP)"
.br
.ti -1c
.RI "unsigned \fBint\fP \fBavio_rb32\fP (\fBAVIOContext\fP *\fBs\fP)"
.br
.ti -1c
.RI "\fBuint64_t\fP \fBavio_rb64\fP (\fBAVIOContext\fP *\fBs\fP)"
.br
.in -1c
.in -1c
.SH "Detailed Description"
.PP 
Buffered I/O operations 
.PP
Definition in file \fBavio\&.h\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define AVIO_FLAG_DIRECT   0x8000"
Use direct mode\&. avio_read and avio_write should if possible be satisfied directly instead of going through a buffer, and avio_seek will always call the underlying seek function directly\&. 
.PP
Definition at line 368 of file avio\&.h\&.
.SS "#define AVIO_FLAG_NONBLOCK   8"
Use non-blocking mode\&. If this flag is set, operations on the context will return \fBAVERROR(EAGAIN)\fP if they can not be performed immediately\&. If this flag is not set, operations on the context will never return \fBAVERROR(EAGAIN)\fP\&. Note that this flag does not affect the opening/connecting of the context\&. Connecting a protocol will always block if necessary (e\&.g\&. on network protocols) but never hang (e\&.g\&. on busy devices)\&. Warning: non-blocking protocols is work-in-progress; this flag may be silently ignored\&. 
.PP
Definition at line 360 of file avio\&.h\&.
.SS "#define AVIO_FLAG_READ   1"
read-only 
.PP
Definition at line 341 of file avio\&.h\&.
.SS "#define AVIO_FLAG_READ_WRITE   (\fBAVIO_FLAG_READ\fP|\fBAVIO_FLAG_WRITE\fP)"
read-write pseudo flag 
.PP
Definition at line 343 of file avio\&.h\&.
.SS "#define AVIO_FLAG_WRITE   2"
write-only 
.PP
Definition at line 342 of file avio\&.h\&.
.SS "#define AVIO_SEEKABLE_NORMAL   0x0001"
Seeking works like for a local file 
.PP
Definition at line 38 of file avio\&.h\&.
.SS "#define AVSEEK_FORCE   0x20000"
Oring this flag as into the 'whence' parameter to a seek function causes it to seek by any means (like reopening and linear reading) or other normally unreasonable means that can be extremely slow\&. This may be ignored by the seek code\&. 
.PP
Definition at line 239 of file avio\&.h\&.
.SS "#define AVSEEK_SIZE   0x10000"
Passing this as the 'whence' parameter to a seek function causes it to return the filesize without seeking anywhere\&. Supporting this is optional\&. If it is not supported then the seek function will return <0\&. 
.PP
Definition at line 231 of file avio\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBAVIOContext\fP  \fBAVIOContext\fP"
Bytestream IO Context\&. New fields can be added to the end with minor version bumps\&. Removal, reordering and changes to existing fields require a major version bump\&. sizeof(AVIOContext) must not be used outside libav*\&.
.PP
\fBNote:\fP
.RS 4
None of the function pointers in \fBAVIOContext\fP should be called directly, they should only be set by the client application when implementing custom I/O\&. Normally these are set to the function pointers specified in \fBavio_alloc_context()\fP 
.RE
.PP

.SS "typedef struct \fBAVIOInterruptCB\fP  \fBAVIOInterruptCB\fP"
\fBCallback\fP for checking whether to abort blocking functions\&. AVERROR_EXIT is returned in this case by the interrupted function\&. During blocking operations, callback is called with opaque as parameter\&. If the callback returns 1, the blocking operation will be aborted\&.
.PP
No members can be added to this struct without a major bump, if new elements have been added after this struct in \fBAVFormatContext\fP or \fBAVIOContext\fP\&. 
.SH "Function Documentation"
.PP 
.SS "\fBAVIOContext\fP* avio_alloc_context (unsigned char * buffer, \fBint\fP buffer_size, \fBint\fP write_flag, \fBvoid\fP * opaque, \fBint\fP(*)(\fBvoid\fP *opaque, \fBuint8_t\fP *\fBbuf\fP, \fBint\fP buf_size) read_packet, \fBint\fP(*)(\fBvoid\fP *opaque, \fBuint8_t\fP *\fBbuf\fP, \fBint\fP buf_size) write_packet, \fBint64_t\fP(*)(\fBvoid\fP *opaque, \fBint64_t\fP \fBoffset\fP, \fBint\fP whence) seek)"
Allocate and initialize an \fBAVIOContext\fP for buffered I/O\&. It must be later freed with \fBav_free()\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIbuffer\fP Memory block for input/output operations via \fBAVIOContext\fP\&. The buffer must be allocated with \fBav_malloc()\fP and friends\&. 
.br
\fIbuffer_size\fP The buffer size is very important for performance\&. For protocols with fixed blocksize it should be set to this blocksize\&. For others a typical size is a cache page, e\&.g\&. 4kb\&. 
.br
\fIwrite_flag\fP Set to 1 if the buffer should be writable, 0 otherwise\&. 
.br
\fIopaque\fP An opaque pointer to user-specific data\&. 
.br
\fIread_packet\fP A function for refilling the buffer, may be NULL\&. 
.br
\fIwrite_packet\fP A function for writing the buffer contents, may be NULL\&. The function may not change the input buffers content\&. 
.br
\fIseek\fP A function for seeking to specified byte position, may be NULL\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Allocated \fBAVIOContext\fP or NULL on failure\&. 
.RE
.PP

.SS "\fBint\fP avio_check (\fBconst\fP char * url, \fBint\fP flags)"
Return AVIO_FLAG_* access flags corresponding to the access permissions of the resource in url, or a negative value corresponding to an AVERROR code in case of failure\&. The returned access flags are masked by the value in flags\&.
.PP
\fBNote:\fP
.RS 4
This function is intrinsically unsafe, in the sense that the checked resource may change its existence or permission status from one call to another\&. Thus you should not trust the returned value, unless you are sure that no other processes are accessing the checked resource\&. 
.RE
.PP

.SS "\fBint\fP avio_close (\fBAVIOContext\fP * s)"
Close the resource accessed by the \fBAVIOContext\fP s and free it\&. This function can only be used if s was opened by \fBavio_open()\fP\&.
.PP
The internal buffer is automatically flushed before closing the resource\&.
.PP
\fBReturns:\fP
.RS 4
0 on success, an AVERROR < 0 on error\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBavio_closep\fP 
.RE
.PP

.SS "\fBint\fP avio_close_dyn_buf (\fBAVIOContext\fP * s, \fBuint8_t\fP ** pbuffer)"
Return the written size and a pointer to the buffer\&. The buffer must be freed with \fBav_free()\fP\&. Padding of FF_INPUT_BUFFER_PADDING_SIZE is added to the buffer\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP IO context 
.br
\fIpbuffer\fP pointer to a byte buffer 
.RE
.PP
\fBReturns:\fP
.RS 4
the length of the byte buffer 
.RE
.PP

.SS "\fBint\fP avio_closep (\fBAVIOContext\fP ** s)"
Close the resource accessed by the \fBAVIOContext\fP *s, free it and set the pointer pointing to it to NULL\&. This function can only be used if s was opened by \fBavio_open()\fP\&.
.PP
The internal buffer is automatically flushed before closing the resource\&.
.PP
\fBReturns:\fP
.RS 4
0 on success, an AVERROR < 0 on error\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBavio_close\fP 
.RE
.PP

.SS "\fBconst\fP char* avio_enum_protocols (\fBvoid\fP ** opaque, \fBint\fP output)"
Iterate through names of available protocols\&.
.PP
\fBParameters:\fP
.RS 4
\fIopaque\fP A private pointer representing current protocol\&. It must be a pointer to NULL on first iteration and will be updated by successive calls to avio_enum_protocols\&. 
.br
\fIoutput\fP If set to 1, iterate over output protocols, otherwise over input protocols\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A static string containing the name of current protocol or NULL 
.RE
.PP

.SS "\fBconst\fP char* avio_find_protocol_name (\fBconst\fP char * url)"
Return the name of the protocol that will handle the passed URL\&.
.PP
NULL is returned if no protocol could be found for the given URL\&.
.PP
\fBReturns:\fP
.RS 4
Name of the protocol or NULL\&. 
.RE
.PP

.SS "\fBint\fP \fBvoid\fP avio_flush (\fBAVIOContext\fP * s)"
Force flushing of buffered data to the output s\&.
.PP
Force the buffered data to be immediately written to the output, without to wait to fill the internal buffer\&. 
.SS "\fBint\fP avio_get_str (\fBAVIOContext\fP * pb, \fBint\fP maxlen, char * buf, \fBint\fP buflen)"
Read a string from pb into buf\&. The reading will terminate when either a NULL character was encountered, maxlen bytes have been read, or nothing more can be read from pb\&. The result is guaranteed to be NULL-terminated, it will be truncated if buf is too small\&. Note that the string is not interpreted or validated in any way, it might get truncated in the middle of a sequence for multi-byte encodings\&.
.PP
\fBReturns:\fP
.RS 4
number of bytes read (is always <= maxlen)\&. If reading ends on EOF or error, the return value will be one more than bytes actually read\&. 
.RE
.PP

.SS "\fBint\fP avio_get_str16be (\fBAVIOContext\fP * pb, \fBint\fP maxlen, char * buf, \fBint\fP buflen)"

.SS "\fBint\fP avio_get_str16le (\fBAVIOContext\fP * pb, \fBint\fP maxlen, char * buf, \fBint\fP buflen)"
Read a UTF-16 string from pb and convert it to UTF-8\&. The reading will terminate when either a null or invalid character was encountered or maxlen bytes have been read\&. 
.PP
\fBReturns:\fP
.RS 4
number of bytes read (is always <= maxlen) 
.RE
.PP

.SS "\fBint\fP avio_open (\fBAVIOContext\fP ** s, \fBconst\fP char * url, \fBint\fP flags)"
Create and initialize a \fBAVIOContext\fP for accessing the resource indicated by url\&. 
.PP
\fBNote:\fP
.RS 4
When the resource indicated by url has been opened in read+write mode, the \fBAVIOContext\fP can be used only for writing\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Used to return the pointer to the created \fBAVIOContext\fP\&. In case of failure the pointed to value is set to NULL\&. 
.br
\fIurl\fP resource to access 
.br
\fIflags\fP flags which control how the resource indicated by url is to be opened 
.RE
.PP
\fBReturns:\fP
.RS 4
>= 0 in case of success, a negative value corresponding to an AVERROR code in case of failure 
.RE
.PP

.SS "\fBint\fP avio_open2 (\fBAVIOContext\fP ** s, \fBconst\fP char * url, \fBint\fP flags, \fBconst\fP \fBAVIOInterruptCB\fP * int_cb, \fBAVDictionary\fP ** options)"
Create and initialize a \fBAVIOContext\fP for accessing the resource indicated by url\&. 
.PP
\fBNote:\fP
.RS 4
When the resource indicated by url has been opened in read+write mode, the \fBAVIOContext\fP can be used only for writing\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Used to return the pointer to the created \fBAVIOContext\fP\&. In case of failure the pointed to value is set to NULL\&. 
.br
\fIurl\fP resource to access 
.br
\fIflags\fP flags which control how the resource indicated by url is to be opened 
.br
\fIint_cb\fP an interrupt callback to be used at the protocols level 
.br
\fIoptions\fP A dictionary filled with protocol-private options\&. On return this parameter will be destroyed and replaced with a dict containing options that were not found\&. May be NULL\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
>= 0 in case of success, a negative value corresponding to an AVERROR code in case of failure 
.RE
.PP

.SS "\fBint\fP avio_open_dyn_buf (\fBAVIOContext\fP ** s)"
Open a write only memory stream\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP new IO context 
.RE
.PP
\fBReturns:\fP
.RS 4
zero if no error\&. 
.RE
.PP

.SS "\fBint\fP avio_pause (\fBAVIOContext\fP * h, \fBint\fP pause)"
Pause and resume playing - only meaningful if using a network streaming protocol (e\&.g\&. MMS)\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP IO context from which to call the read_pause function pointer 
.br
\fIpause\fP 1 for pause, 0 for resume 
.RE
.PP

.SS "\fBint\fP avio_printf (\fBAVIOContext\fP * s, \fBconst\fP char * fmt,  \&.\&.\&.)"

.PP
\fBWarning:\fP
.RS 4
currently size is limited 
.RE
.PP

.SS "\fBint\fP avio_put_str (\fBAVIOContext\fP * s, \fBconst\fP char * str)"
Write a NULL-terminated string\&. 
.PP
\fBReturns:\fP
.RS 4
number of bytes written\&. 
.RE
.PP

.SS "\fBint\fP avio_put_str16le (\fBAVIOContext\fP * s, \fBconst\fP char * str)"
Convert an UTF-8 string to UTF-16LE and write it\&. 
.PP
\fBReturns:\fP
.RS 4
number of bytes written\&. 
.RE
.PP

.SS "\fBint\fP avio_r8 (\fBAVIOContext\fP * s)"

.SS "unsigned \fBint\fP avio_rb16 (\fBAVIOContext\fP * s)"

.SS "unsigned \fBint\fP avio_rb24 (\fBAVIOContext\fP * s)"

.SS "unsigned \fBint\fP avio_rb32 (\fBAVIOContext\fP * s)"

.SS "\fBuint64_t\fP avio_rb64 (\fBAVIOContext\fP * s)"

.SS "\fBint\fP avio_read (\fBAVIOContext\fP * s, unsigned char * buf, \fBint\fP size)"
Read size bytes from \fBAVIOContext\fP into buf\&. 
.PP
\fBReturns:\fP
.RS 4
number of bytes read or AVERROR 
.RE
.PP

.SS "unsigned \fBint\fP avio_rl16 (\fBAVIOContext\fP * s)"

.SS "unsigned \fBint\fP avio_rl24 (\fBAVIOContext\fP * s)"

.SS "unsigned \fBint\fP avio_rl32 (\fBAVIOContext\fP * s)"

.SS "\fBuint64_t\fP avio_rl64 (\fBAVIOContext\fP * s)"

.SS "\fBint64_t\fP avio_seek (\fBAVIOContext\fP * s, \fBint64_t\fP offset, \fBint\fP whence)"
fseek() equivalent for \fBAVIOContext\fP\&. 
.PP
\fBReturns:\fP
.RS 4
new position or AVERROR\&. 
.RE
.PP

.SS "\fBint64_t\fP avio_seek_time (\fBAVIOContext\fP * h, \fBint\fP stream_index, \fBint64_t\fP timestamp, \fBint\fP flags)"
Seek to a given timestamp relative to some component stream\&. Only meaningful if using a network streaming protocol (e\&.g\&. MMS\&.)\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP IO context from which to call the seek function pointers 
.br
\fIstream_index\fP The stream index that the timestamp is relative to\&. If stream_index is (-1) the timestamp should be in AV_TIME_BASE units from the beginning of the presentation\&. If a stream_index >= 0 is used and the protocol does not support seeking based on component streams, the call will fail\&. 
.br
\fItimestamp\fP timestamp in \fBAVStream\&.time_base\fP units or if there is no stream specified then in AV_TIME_BASE units\&. 
.br
\fIflags\fP Optional combination of AVSEEK_FLAG_BACKWARD, AVSEEK_FLAG_BYTE and AVSEEK_FLAG_ANY\&. The protocol may silently ignore AVSEEK_FLAG_BACKWARD and AVSEEK_FLAG_ANY, but AVSEEK_FLAG_BYTE will fail if used and not supported\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
>= 0 on success 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBAVInputFormat::read_seek\fP 
.RE
.PP

.SS "\fBint64_t\fP avio_size (\fBAVIOContext\fP * s)"
Get the filesize\&. 
.PP
\fBReturns:\fP
.RS 4
filesize or AVERROR 
.RE
.PP

.SS "\fBint64_t\fP avio_skip (\fBAVIOContext\fP * s, \fBint64_t\fP offset)"
Skip given number of bytes forward 
.PP
\fBReturns:\fP
.RS 4
new position or AVERROR\&. 
.RE
.PP

.SS "\fBvoid\fP avio_w8 (\fBAVIOContext\fP * s, \fBint\fP b)"

.SS "\fBvoid\fP avio_wb16 (\fBAVIOContext\fP * s, unsigned \fBint\fP val)"

.SS "\fBvoid\fP avio_wb24 (\fBAVIOContext\fP * s, unsigned \fBint\fP val)"

.SS "\fBvoid\fP avio_wb32 (\fBAVIOContext\fP * s, unsigned \fBint\fP val)"

.SS "\fBvoid\fP avio_wb64 (\fBAVIOContext\fP * s, \fBuint64_t\fP val)"

.SS "\fBvoid\fP avio_wl16 (\fBAVIOContext\fP * s, unsigned \fBint\fP val)"

.SS "\fBvoid\fP avio_wl24 (\fBAVIOContext\fP * s, unsigned \fBint\fP val)"

.SS "\fBvoid\fP avio_wl32 (\fBAVIOContext\fP * s, unsigned \fBint\fP val)"

.SS "\fBvoid\fP avio_wl64 (\fBAVIOContext\fP * s, \fBuint64_t\fP val)"

.SS "\fBvoid\fP avio_write (\fBAVIOContext\fP * s, \fBconst\fP unsigned char * buf, \fBint\fP size)"

.SS "\fBint\fP url_feof (\fBAVIOContext\fP * s)"
feof() equivalent for \fBAVIOContext\fP\&. 
.PP
\fBReturns:\fP
.RS 4
non zero if and only if end of file 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Audacity from the source code\&.
