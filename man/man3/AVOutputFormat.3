.TH "AVOutputFormat" 3 "Thu Apr 28 2016" "Audacity" \" -*- nroff -*-
.ad l
.nh
.SH NAME
AVOutputFormat \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <avformat\&.h>\fP
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBconst\fP char * \fBname\fP"
.br
.ti -1c
.RI "\fBconst\fP char * \fBlong_name\fP"
.br
.ti -1c
.RI "\fBconst\fP char * \fBmime_type\fP"
.br
.ti -1c
.RI "\fBconst\fP char * \fBextensions\fP"
.br
.ti -1c
.RI "enum \fBAVCodecID\fP \fBaudio_codec\fP"
.br
.ti -1c
.RI "enum \fBAVCodecID\fP \fBvideo_codec\fP"
.br
.ti -1c
.RI "enum \fBAVCodecID\fP \fBsubtitle_codec\fP"
.br
.ti -1c
.RI "\fBint\fP \fBflags\fP"
.br
.ti -1c
.RI "\fBconst\fP struct AVCodecTag *\fBconst\fP * \fBcodec_tag\fP"
.br
.ti -1c
.RI "\fBconst\fP \fBAVClass\fP * \fBpriv_class\fP"
.br
.RI "\fI\fBAVClass\fP for the private context\&. \fP"
.ti -1c
.RI "struct \fBAVOutputFormat\fP * \fBnext\fP"
.br
.ti -1c
.RI "\fBint\fP \fBpriv_data_size\fP"
.br
.ti -1c
.RI "\fBint\fP(* \fBwrite_header\fP )(struct \fBAVFormatContext\fP *)"
.br
.ti -1c
.RI "\fBint\fP(* \fBwrite_packet\fP )(struct \fBAVFormatContext\fP *, \fBAVPacket\fP *pkt)"
.br
.ti -1c
.RI "\fBint\fP(* \fBwrite_trailer\fP )(struct \fBAVFormatContext\fP *)"
.br
.ti -1c
.RI "\fBint\fP(* \fBinterleave_packet\fP )(struct \fBAVFormatContext\fP *, \fBAVPacket\fP *\fBout\fP, \fBAVPacket\fP *\fBin\fP, \fBint\fP \fBflush\fP)"
.br
.ti -1c
.RI "\fBint\fP(* \fBquery_codec\fP )(enum \fBAVCodecID\fP id, \fBint\fP std_compliance)"
.br
.ti -1c
.RI "\fBvoid\fP(* \fBget_output_timestamp\fP )(struct \fBAVFormatContext\fP *\fBs\fP, \fBint\fP stream, \fBint64_t\fP *dts, \fBint64_t\fP *wall)"
.br
.ti -1c
.RI "\fBint\fP(* \fBcontrol_message\fP )(struct \fBAVFormatContext\fP *\fBs\fP, \fBint\fP type, \fBvoid\fP *\fBdata\fP, size_t data_size)"
.br
.ti -1c
.RI "\fBint\fP(* \fBwrite_uncoded_frame\fP )(struct \fBAVFormatContext\fP *, \fBint\fP stream_index, \fBAVFrame\fP **frame, unsigned \fBflags\fP)"
.br
.ti -1c
.RI "\fBint\fP(* \fBget_device_list\fP )(struct \fBAVFormatContext\fP *\fBs\fP, struct AVDeviceInfoList *device_list)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 451 of file avformat\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "enum \fBAVCodecID\fP AVOutputFormat::audio_codec"
default audio codec 
.PP
Definition at line 462 of file avformat\&.h\&.
.SS "\fBconst\fP struct AVCodecTag* \fBconst\fP* AVOutputFormat::codec_tag"
List of supported codec_id-codec_tag pairs, ordered by 'better
choice first'\&. The arrays are all terminated by AV_CODEC_ID_NONE\&. 
.PP
Definition at line 477 of file avformat\&.h\&.
.SS "\fBint\fP(* AVOutputFormat::control_message) (struct \fBAVFormatContext\fP *\fBs\fP, \fBint\fP type, \fBvoid\fP *\fBdata\fP, size_t data_size)"
Allows sending messages from application to device\&. 
.PP
Definition at line 524 of file avformat\&.h\&.
.SS "\fBconst\fP char* AVOutputFormat::extensions"
comma-separated filename extensions 
.PP
Definition at line 460 of file avformat\&.h\&.
.SS "\fBint\fP AVOutputFormat::flags"
can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_RAWPICTURE, AVFMT_GLOBALHEADER, AVFMT_NOTIMESTAMPS, AVFMT_VARIABLE_FPS, AVFMT_NODIMENSIONS, AVFMT_NOSTREAMS, AVFMT_ALLOW_FLUSH, AVFMT_TS_NONSTRICT 
.PP
Definition at line 471 of file avformat\&.h\&.
.SS "\fBint\fP(* AVOutputFormat::get_device_list) (struct \fBAVFormatContext\fP *\fBs\fP, struct AVDeviceInfoList *device_list)"
Returns device list with it properties\&. 
.PP
\fBSee also:\fP
.RS 4
avdevice_list_devices() \fBfor\fP more details\&. 
.RE
.PP

.PP
Definition at line 541 of file avformat\&.h\&.
.SS "\fBvoid\fP(* AVOutputFormat::get_output_timestamp) (struct \fBAVFormatContext\fP *\fBs\fP, \fBint\fP stream, \fBint64_t\fP *dts, \fBint64_t\fP *wall)"

.PP
Definition at line 519 of file avformat\&.h\&.
.SS "\fBint\fP(* AVOutputFormat::interleave_packet) (struct \fBAVFormatContext\fP *, \fBAVPacket\fP *\fBout\fP, \fBAVPacket\fP *\fBin\fP, \fBint\fP \fBflush\fP)"
Currently only used to set pixel format if not YUV420P\&. 
.PP
Definition at line 508 of file avformat\&.h\&.
.SS "\fBconst\fP char* AVOutputFormat::long_name"
Descriptive name for the format, meant to be more human-readable than name\&. You should use the NULL_IF_CONFIG_SMALL() macro to define it\&. 
.PP
Definition at line 458 of file avformat\&.h\&.
.SS "\fBconst\fP char* AVOutputFormat::mime_type"

.PP
Definition at line 459 of file avformat\&.h\&.
.SS "\fBconst\fP char* AVOutputFormat::name"

.PP
Definition at line 452 of file avformat\&.h\&.
.SS "struct \fBAVOutputFormat\fP* AVOutputFormat::next"

.PP
Definition at line 489 of file avformat\&.h\&.
.SS "\fBconst\fP \fBAVClass\fP* AVOutputFormat::priv_class"

.PP
\fBAVClass\fP for the private context\&. 
.PP
Definition at line 480 of file avformat\&.h\&.
.SS "\fBint\fP AVOutputFormat::priv_data_size"
size of private data so that it can be allocated in the wrapper 
.PP
Definition at line 493 of file avformat\&.h\&.
.SS "\fBint\fP(* AVOutputFormat::query_codec) (enum \fBAVCodecID\fP id, \fBint\fP std_compliance)"
\fBTest\fP if the given codec can be stored in this container\&.
.PP
\fBReturns:\fP
.RS 4
1 if the codec is supported, 0 if it is not\&. A negative number if unknown\&. MKTAG('A', 'P', 'I', 'C') if the codec is only supported as AV_DISPOSITION_ATTACHED_PIC 
.RE
.PP

.PP
Definition at line 517 of file avformat\&.h\&.
.SS "enum \fBAVCodecID\fP AVOutputFormat::subtitle_codec"
default subtitle codec 
.PP
Definition at line 464 of file avformat\&.h\&.
.SS "enum \fBAVCodecID\fP AVOutputFormat::video_codec"
default video codec 
.PP
Definition at line 463 of file avformat\&.h\&.
.SS "\fBint\fP(* AVOutputFormat::write_header) (struct \fBAVFormatContext\fP *)"

.PP
Definition at line 495 of file avformat\&.h\&.
.SS "\fBint\fP(* AVOutputFormat::write_packet) (struct \fBAVFormatContext\fP *, \fBAVPacket\fP *pkt)"
Write a packet\&. If AVFMT_ALLOW_FLUSH is set in flags, pkt can be NULL in order to flush data buffered in the muxer\&. When flushing, return 0 if there still is more data to flush, or 1 if everything was flushed and there is no more buffered data\&. 
.PP
Definition at line 503 of file avformat\&.h\&.
.SS "\fBint\fP(* AVOutputFormat::write_trailer) (struct \fBAVFormatContext\fP *)"

.PP
Definition at line 504 of file avformat\&.h\&.
.SS "\fBint\fP(* AVOutputFormat::write_uncoded_frame) (struct \fBAVFormatContext\fP *, \fBint\fP stream_index, \fBAVFrame\fP **frame, unsigned \fBflags\fP)"
Write an uncoded \fBAVFrame\fP\&.
.PP
See \fBav_write_uncoded_frame()\fP for details\&.
.PP
The library will free *frame afterwards, but the muxer can prevent it by setting the pointer to NULL\&. 
.PP
Definition at line 535 of file avformat\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Audacity from the source code\&.
