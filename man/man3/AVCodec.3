.TH "AVCodec" 3 "Thu Apr 28 2016" "Audacity" \" -*- nroff -*-
.ad l
.nh
.SH NAME
AVCodec \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <avcodec\&.h>\fP
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBconst\fP char * \fBname\fP"
.br
.ti -1c
.RI "\fBconst\fP char * \fBlong_name\fP"
.br
.ti -1c
.RI "enum \fBAVMediaType\fP \fBtype\fP"
.br
.ti -1c
.RI "enum \fBAVCodecID\fP \fBid\fP"
.br
.ti -1c
.RI "\fBint\fP \fBcapabilities\fP"
.br
.ti -1c
.RI "\fBconst\fP \fBAVRational\fP * \fBsupported_framerates\fP"
.br
.RI "\fIarray of supported framerates, or NULL if any, array is terminated by {0,0} \fP"
.ti -1c
.RI "enum \fBAVPixelFormat\fP * \fBpix_fmts\fP"
.br
.RI "\fIarray of supported pixel formats, or NULL if unknown, array is terminated by -1 \fP"
.ti -1c
.RI "\fBconst\fP \fBint\fP * \fBsupported_samplerates\fP"
.br
.RI "\fIarray of supported audio samplerates, or NULL if unknown, array is terminated by 0 \fP"
.ti -1c
.RI "enum \fBAVSampleFormat\fP * \fBsample_fmts\fP"
.br
.RI "\fIarray of supported sample formats, or NULL if unknown, array is terminated by -1 \fP"
.ti -1c
.RI "\fBconst\fP \fBuint64_t\fP * \fBchannel_layouts\fP"
.br
.RI "\fIarray of support channel layouts, or NULL if unknown\&. array is terminated by 0 \fP"
.ti -1c
.RI "\fBuint8_t\fP \fBmax_lowres\fP"
.br
.RI "\fImaximum value for lowres supported by the decoder, no direct access, use \fBav_codec_get_max_lowres()\fP \fP"
.ti -1c
.RI "\fBconst\fP \fBAVClass\fP * \fBpriv_class\fP"
.br
.RI "\fI\fBAVClass\fP for the private context\&. \fP"
.ti -1c
.RI "\fBconst\fP \fBAVProfile\fP * \fBprofiles\fP"
.br
.RI "\fIarray of recognized profiles, or NULL if unknown, array is terminated by {FF_PROFILE_UNKNOWN} \fP"
.ti -1c
.RI "\fBint\fP \fBpriv_data_size\fP"
.br
.ti -1c
.RI "struct \fBAVCodec\fP * \fBnext\fP"
.br
.ti -1c
.RI "\fBconst\fP \fBAVCodecDefault\fP * \fBdefaults\fP"
.br
.ti -1c
.RI "\fBvoid\fP(* \fBinit_static_data\fP )(struct \fBAVCodec\fP *codec)"
.br
.ti -1c
.RI "\fBint\fP(* \fBinit\fP )(\fBAVCodecContext\fP *)"
.br
.ti -1c
.RI "\fBint\fP(* \fBencode_sub\fP )(\fBAVCodecContext\fP *, \fBuint8_t\fP *\fBbuf\fP, \fBint\fP buf_size, \fBconst\fP struct \fBAVSubtitle\fP *sub)"
.br
.ti -1c
.RI "\fBint\fP(* \fBencode2\fP )(\fBAVCodecContext\fP *avctx, \fBAVPacket\fP *avpkt, \fBconst\fP \fBAVFrame\fP *frame, \fBint\fP *got_packet_ptr)"
.br
.ti -1c
.RI "\fBint\fP(* \fBdecode\fP )(\fBAVCodecContext\fP *, \fBvoid\fP *outdata, \fBint\fP *outdata_size, \fBAVPacket\fP *avpkt)"
.br
.ti -1c
.RI "\fBint\fP(* \fBclose\fP )(\fBAVCodecContext\fP *)"
.br
.ti -1c
.RI "\fBvoid\fP(* \fBflush\fP )(\fBAVCodecContext\fP *)"
.br
.in -1c
.PP
.RI "\fBFrame-level threading support functions\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBint\fP(* \fBinit_thread_copy\fP )(\fBAVCodecContext\fP *)"
.br
.ti -1c
.RI "\fBint\fP(* \fBupdate_thread_context\fP )(\fBAVCodecContext\fP *dst, \fBconst\fP \fBAVCodecContext\fP *src)"
.br
.in -1c
.in -1c
.SH "Detailed Description"
.PP 
\fBAVCodec\fP\&. 
.PP
Definition at line 3031 of file avcodec\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBint\fP AVCodec::capabilities"
Codec capabilities\&. see CODEC_CAP_* 
.PP
Definition at line 3050 of file avcodec\&.h\&.
.SS "\fBconst\fP \fBuint64_t\fP* AVCodec::channel_layouts"

.PP
array of support channel layouts, or NULL if unknown\&. array is terminated by 0 
.PP
Definition at line 3055 of file avcodec\&.h\&.
.SS "\fBint\fP(* AVCodec::close) (\fBAVCodecContext\fP *)"

.PP
Definition at line 3117 of file avcodec\&.h\&.
.SS "\fBint\fP(* AVCodec::decode) (\fBAVCodecContext\fP *, \fBvoid\fP *outdata, \fBint\fP *outdata_size, \fBAVPacket\fP *avpkt)"

.PP
Definition at line 3116 of file avcodec\&.h\&.
.SS "\fBconst\fP \fBAVCodecDefault\fP* AVCodec::defaults"
Private codec-specific defaults\&. 
.PP
Definition at line 3094 of file avcodec\&.h\&.
.SS "\fBint\fP(* AVCodec::encode2) (\fBAVCodecContext\fP *avctx, \fBAVPacket\fP *avpkt, \fBconst\fP \fBAVFrame\fP *frame, \fBint\fP *got_packet_ptr)"
Encode data to an \fBAVPacket\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIavctx\fP codec context 
.br
\fIavpkt\fP output \fBAVPacket\fP (may contain a user-provided buffer) 
.br
\fIframe\fP \fBAVFrame\fP containing the raw data to be encoded 
.br
\fIgot_packet_ptr\fP encoder sets to 0 or 1 to indicate that a non-empty packet was returned in avpkt\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, negative error code on failure 
.RE
.PP

.PP
Definition at line 3114 of file avcodec\&.h\&.
.SS "\fBint\fP(* AVCodec::encode_sub) (\fBAVCodecContext\fP *, \fBuint8_t\fP *\fBbuf\fP, \fBint\fP buf_size, \fBconst\fP struct \fBAVSubtitle\fP *sub)"

.PP
Definition at line 3102 of file avcodec\&.h\&.
.SS "\fBvoid\fP(* AVCodec::flush) (\fBAVCodecContext\fP *)"
Flush buffers\&. Will be called when seeking 
.PP
Definition at line 3122 of file avcodec\&.h\&.
.SS "enum \fBAVCodecID\fP AVCodec::id"

.PP
Definition at line 3045 of file avcodec\&.h\&.
.SS "\fBint\fP(* AVCodec::init) (\fBAVCodecContext\fP *)"

.PP
Definition at line 3101 of file avcodec\&.h\&.
.SS "\fBvoid\fP(* AVCodec::init_static_data) (struct \fBAVCodec\fP *codec)"
Initialize codec static data, called from \fBavcodec_register()\fP\&. 
.PP
Definition at line 3099 of file avcodec\&.h\&.
.SS "\fBint\fP(* AVCodec::init_thread_copy) (\fBAVCodecContext\fP *)"
If defined, called on thread contexts when they are created\&. If the codec allocates writable tables in \fBinit()\fP, re-allocate them here\&. priv_data will be set to a copy of the original\&. 
.PP
Definition at line 3080 of file avcodec\&.h\&.
.SS "\fBconst\fP char* AVCodec::long_name"
Descriptive name for the codec, meant to be more human readable than name\&. You should use the NULL_IF_CONFIG_SMALL() macro to define it\&. 
.PP
Definition at line 3043 of file avcodec\&.h\&.
.SS "\fBuint8_t\fP AVCodec::max_lowres"

.PP
maximum value for lowres supported by the decoder, no direct access, use \fBav_codec_get_max_lowres()\fP 
.PP
Definition at line 3057 of file avcodec\&.h\&.
.SS "\fBconst\fP char* AVCodec::name"
Name of the codec implementation\&. The name is globally unique among encoders and among decoders (but an encoder and a decoder can share the same name)\&. This is the primary way to find a codec from the user perspective\&. 
.PP
Definition at line 3038 of file avcodec\&.h\&.
.SS "struct \fBAVCodec\fP* AVCodec::next"

.PP
Definition at line 3070 of file avcodec\&.h\&.
.SS "enum \fBAVPixelFormat\fP* AVCodec::pix_fmts"

.PP
array of supported pixel formats, or NULL if unknown, array is terminated by -1 
.PP
Definition at line 3052 of file avcodec\&.h\&.
.SS "\fBconst\fP \fBAVClass\fP* AVCodec::priv_class"

.PP
\fBAVClass\fP for the private context\&. 
.PP
Definition at line 3059 of file avcodec\&.h\&.
.SS "\fBint\fP AVCodec::priv_data_size"

.PP
Definition at line 3069 of file avcodec\&.h\&.
.SS "\fBconst\fP \fBAVProfile\fP* AVCodec::profiles"

.PP
array of recognized profiles, or NULL if unknown, array is terminated by {FF_PROFILE_UNKNOWN} 
.PP
Definition at line 3060 of file avcodec\&.h\&.
.SS "enum \fBAVSampleFormat\fP* AVCodec::sample_fmts"

.PP
array of supported sample formats, or NULL if unknown, array is terminated by -1 
.PP
Definition at line 3054 of file avcodec\&.h\&.
.SS "\fBconst\fP \fBAVRational\fP* AVCodec::supported_framerates"

.PP
array of supported framerates, or NULL if any, array is terminated by {0,0} 
.PP
Definition at line 3051 of file avcodec\&.h\&.
.SS "\fBconst\fP \fBint\fP* AVCodec::supported_samplerates"

.PP
array of supported audio samplerates, or NULL if unknown, array is terminated by 0 
.PP
Definition at line 3053 of file avcodec\&.h\&.
.SS "enum \fBAVMediaType\fP AVCodec::type"

.PP
Definition at line 3044 of file avcodec\&.h\&.
.SS "\fBint\fP(* AVCodec::update_thread_context) (\fBAVCodecContext\fP *dst, \fBconst\fP \fBAVCodecContext\fP *src)"
Copy necessary context variables from a previous thread context to the current one\&. If not defined, the next thread will start automatically; otherwise, the codec must call ff_thread_finish_setup()\&.
.PP
dst and src will (rarely) point to the same context, in which case memcpy should be skipped\&. 
.PP
Definition at line 3088 of file avcodec\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Audacity from the source code\&.
