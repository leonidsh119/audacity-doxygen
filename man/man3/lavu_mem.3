.TH "lavu_mem" 3 "Thu Apr 28 2016" "Audacity" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lavu_mem \- Memory Management
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBDECLARE_ALIGNED\fP(n,  \fBt\fP,  v)           \fBt\fP v"
.br
.ti -1c
.RI "#define \fBDECLARE_ASM_CONST\fP(n,  \fBt\fP,  v)       static \fBconst\fP \fBt\fP v"
.br
.ti -1c
.RI "#define \fBav_malloc_attrib\fP"
.br
.ti -1c
.RI "#define \fBav_alloc_size\fP(\&.\&.\&.)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBvoid\fP * \fBav_malloc\fP (size_t \fBsize\fP) \fBav_malloc_attrib\fP \fBav_alloc_size\fP(1)"
.br
.ti -1c
.RI "\fBav_alloc_size\fP (1, 2) static \fBinline\fP \fBvoid\fP *av_malloc_array(size_t \fBnmemb\fP"
.br
.ti -1c
.RI "\fBreturn\fP \fBav_malloc\fP (\fBnmemb\fP *\fBsize\fP)"
.br
.ti -1c
.RI "\fBvoid\fP * \fBav_realloc\fP (\fBvoid\fP *ptr, size_t \fBsize\fP) \fBav_alloc_size\fP(2)"
.br
.ti -1c
.RI "\fBvoid\fP * \fBav_realloc_f\fP (\fBvoid\fP *ptr, size_t nelem, size_t elsize)"
.br
.ti -1c
.RI "\fBint\fP \fBav_reallocp\fP (\fBvoid\fP *ptr, size_t \fBsize\fP)"
.br
.ti -1c
.RI "\fBav_alloc_size\fP (2, 3) \fBvoid\fP *av_realloc_array(\fBvoid\fP *ptr"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_free\fP (\fBvoid\fP *ptr)"
.br
.ti -1c
.RI "\fBvoid\fP * \fBav_mallocz\fP (size_t \fBsize\fP) \fBav_malloc_attrib\fP \fBav_alloc_size\fP(1)"
.br
.ti -1c
.RI "\fBvoid\fP * \fBav_calloc\fP (size_t \fBnmemb\fP, size_t \fBsize\fP) \fBav_malloc_attrib\fP"
.br
.ti -1c
.RI "\fBreturn\fP \fBav_mallocz\fP (\fBnmemb\fP *\fBsize\fP)"
.br
.ti -1c
.RI "char * \fBav_strdup\fP (\fBconst\fP char *\fBs\fP) \fBav_malloc_attrib\fP"
.br
.ti -1c
.RI "\fBvoid\fP * \fBav_memdup\fP (\fBconst\fP \fBvoid\fP *\fBp\fP, size_t \fBsize\fP)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_freep\fP (\fBvoid\fP *ptr)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_dynarray_add\fP (\fBvoid\fP *tab_ptr, \fBint\fP *nb_ptr, \fBvoid\fP *\fBelem\fP)"
.br
.ti -1c
.RI "\fBvoid\fP * \fBav_dynarray2_add\fP (\fBvoid\fP **tab_ptr, \fBint\fP *nb_ptr, size_t elem_size, \fBconst\fP \fBuint8_t\fP *elem_data)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_max_alloc\fP (size_t \fBmax\fP)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_memcpy_backptr\fP (\fBuint8_t\fP *dst, \fBint\fP back, \fBint\fP cnt)"
.br
.ti -1c
.RI "\fBvoid\fP * \fBav_fast_realloc\fP (\fBvoid\fP *ptr, unsigned \fBint\fP *\fBsize\fP, size_t min_size)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_fast_malloc\fP (\fBvoid\fP *ptr, unsigned \fBint\fP *\fBsize\fP, size_t min_size)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "size_t \fBsize\fP"
.br
.ti -1c
.RI "size_t \fBnmemb\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SH "Macro Definition Documentation"
.PP 
.SS "#define av_alloc_size( \&.\&.\&.)"

.PP
Definition at line 72 of file mem\&.h\&.
.SS "#define av_malloc_attrib"

.PP
Definition at line 66 of file mem\&.h\&.
.SS "#define DECLARE_ALIGNED(n, \fBt\fP, v)   \fBt\fP v"

.PP
Definition at line 59 of file mem\&.h\&.
.SS "#define DECLARE_ASM_CONST(n, \fBt\fP, v)   static \fBconst\fP \fBt\fP v"

.PP
Definition at line 60 of file mem\&.h\&.
.SH "Function Documentation"
.PP 
.SS "av_alloc_size (1, 2)"
Allocate a block of size * nmemb bytes with \fBav_malloc()\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fInmemb\fP Number of elements 
.br
\fIsize\fP Size of the single element 
.RE
.PP
\fBReturns:\fP
.RS 4
Pointer to the allocated block, NULL if the block cannot be allocated\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBav_malloc()\fP
.RE
.PP
Allocate a block of size * nmemb bytes with \fBav_mallocz()\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fInmemb\fP Number of elements 
.br
\fIsize\fP Size of the single element 
.RE
.PP
\fBReturns:\fP
.RS 4
Pointer to the allocated block, NULL if the block cannot be allocated\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBav_mallocz()\fP 
.PP
av_malloc_array() 
.RE
.PP

.SS "av_alloc_size (2, 3)"
Allocate or reallocate an array\&. If ptr is NULL and nmemb > 0, allocate a new block\&. If nmemb is zero, free the memory block pointed to by ptr\&. 
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP Pointer to a memory block already allocated with \fBav_realloc()\fP or NULL\&. 
.br
\fInmemb\fP Number of elements 
.br
\fIsize\fP Size of the single element 
.RE
.PP
\fBReturns:\fP
.RS 4
Pointer to a newly-reallocated block or NULL if the block cannot be reallocated or the function is used to free the memory block\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Pointers originating from the \fBav_malloc()\fP family of functions must not be passed to \fBav_realloc()\fP\&. The former can be implemented using memalign() (or other functions), and there is no guarantee that pointers from such functions can be passed to realloc() at all\&. The situation is undefined according to POSIX and may crash with some libc implementations\&.
.RE
.PP
Allocate or reallocate an array through a pointer to a pointer\&. If *ptr is NULL and nmemb > 0, allocate a new block\&. If nmemb is zero, free the memory block pointed to by ptr\&. 
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP Pointer to a pointer to a memory block already allocated with \fBav_realloc()\fP, or pointer to a pointer to NULL\&. The pointer is updated on success, or freed on failure\&. 
.br
\fInmemb\fP Number of elements 
.br
\fIsize\fP Size of the single element 
.RE
.PP
\fBReturns:\fP
.RS 4
Zero on success, an AVERROR error code on failure\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Pointers originating from the \fBav_malloc()\fP family of functions must not be passed to \fBav_realloc()\fP\&. The former can be implemented using memalign() (or other functions), and there is no guarantee that pointers from such functions can be passed to realloc() at all\&. The situation is undefined according to POSIX and may crash with some libc implementations\&. 
.RE
.PP

.SS "\fBvoid\fP* av_calloc (size_t nmemb, size_t size)"
Allocate a block of nmemb * size bytes with alignment suitable for all memory accesses (including vectors if available on the CPU) and zero all the bytes of the block\&. The allocation will fail if nmemb * size is greater than or equal to INT_MAX\&. 
.PP
\fBParameters:\fP
.RS 4
\fInmemb\fP 
.br
\fIsize\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Pointer to the allocated block, NULL if it cannot be allocated\&. 
.RE
.PP

.SS "\fBvoid\fP* av_dynarray2_add (\fBvoid\fP ** tab_ptr, \fBint\fP * nb_ptr, size_t elem_size, \fBconst\fP \fBuint8_t\fP * elem_data)"
Add an element of size elem_size to a dynamic array\&.
.PP
The array is reallocated when its number of elements reaches powers of 2\&. Therefore, the amortized cost of adding an element is constant\&.
.PP
In case of success, the pointer to the array is updated in order to point to the new grown array, and the number pointed to by nb_ptr is incremented\&. In case of failure, the array is freed, *tab_ptr is set to NULL and *nb_ptr is set to 0\&.
.PP
\fBParameters:\fP
.RS 4
\fItab_ptr\fP pointer to the array to grow 
.br
\fInb_ptr\fP pointer to the number of elements in the array 
.br
\fIelem_size\fP size in bytes of the elements in the array 
.br
\fIelem_data\fP pointer to the data of the element to add\&. If NULL, the space of the new added element is not filled\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
pointer to the data of the element to copy in the new allocated space\&. If NULL, the new allocated space is left uninitialized\&." 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBav_dynarray_add()\fP 
.RE
.PP

.SS "\fBvoid\fP av_dynarray_add (\fBvoid\fP * tab_ptr, \fBint\fP * nb_ptr, \fBvoid\fP * elem)"
Add an element to a dynamic array\&.
.PP
The array to grow is supposed to be an array of pointers to structures, and the element to add must be a pointer to an already allocated structure\&.
.PP
The array is reallocated when its size reaches powers of 2\&. Therefore, the amortized cost of adding an element is constant\&.
.PP
In case of success, the pointer to the array is updated in order to point to the new grown array, and the number pointed to by nb_ptr is incremented\&. In case of failure, the array is freed, *tab_ptr is set to NULL and *nb_ptr is set to 0\&.
.PP
\fBParameters:\fP
.RS 4
\fItab_ptr\fP pointer to the array to grow 
.br
\fInb_ptr\fP pointer to the number of elements in the array 
.br
\fIelem\fP element to add 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBav_dynarray2_add()\fP 
.RE
.PP

.SS "\fBvoid\fP av_fast_malloc (\fBvoid\fP * ptr, unsigned \fBint\fP * size, size_t min_size)"
Allocate a buffer, reusing the given one if large enough\&.
.PP
Contrary to av_fast_realloc the current buffer contents might not be preserved and on error the old buffer is freed, thus no special handling to avoid memleaks is necessary\&.
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP pointer to pointer to already allocated buffer, overwritten with pointer to new buffer 
.br
\fIsize\fP size of the buffer *ptr points to 
.br
\fImin_size\fP minimum size of *ptr buffer after returning, *ptr will be NULL and *size 0 if an error occurred\&. 
.RE
.PP

.SS "\fBvoid\fP* av_fast_realloc (\fBvoid\fP * ptr, unsigned \fBint\fP * size, size_t min_size)"
Reallocate the given block if it is not large enough, otherwise do nothing\&.
.PP
\fBSee also:\fP
.RS 4
\fBav_realloc\fP 
.RE
.PP

.SS "\fBvoid\fP av_free (\fBvoid\fP * ptr)"
Free a memory block which has been allocated with av_malloc(z)() or \fBav_realloc()\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP Pointer to the memory block which should be freed\&. 
.RE
.PP
\fBNote:\fP
.RS 4
ptr = NULL is explicitly allowed\&. 
.PP
It is recommended that you use \fBav_freep()\fP instead\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBav_freep()\fP 
.RE
.PP

.SS "\fBvoid\fP av_freep (\fBvoid\fP * ptr)"
Free a memory block which has been allocated with av_malloc(z)() or \fBav_realloc()\fP and set the pointer pointing to it to NULL\&. 
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP Pointer to the pointer to the memory block which should be freed\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBav_free()\fP 
.RE
.PP

.SS "\fBvoid\fP* av_malloc (size_t size)"
Allocate a block of size bytes with alignment suitable for all memory accesses (including vectors if available on the CPU)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsize\fP Size in bytes for the memory block to be allocated\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Pointer to the allocated block, NULL if the block cannot be allocated\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBav_mallocz()\fP 
.RE
.PP

.SS "\fBreturn\fP av_malloc (\fBnmemb\fP * size)"

.SS "\fBvoid\fP* av_mallocz (size_t size)"
Allocate a block of size bytes with alignment suitable for all memory accesses (including vectors if available on the CPU) and zero all the bytes of the block\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsize\fP Size in bytes for the memory block to be allocated\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Pointer to the allocated block, NULL if it cannot be allocated\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBav_malloc()\fP 
.RE
.PP

.SS "\fBreturn\fP av_mallocz (\fBnmemb\fP * size)"

.SS "\fBvoid\fP av_max_alloc (size_t max)"
Set the maximum size that may me allocated in one block\&. 
.SS "\fBvoid\fP av_memcpy_backptr (\fBuint8_t\fP * dst, \fBint\fP back, \fBint\fP cnt)"
deliberately overlapping memcpy implementation 
.PP
\fBParameters:\fP
.RS 4
\fIdst\fP destination buffer 
.br
\fIback\fP how many bytes back we start (the initial size of the overlapping window), must be > 0 
.br
\fIcnt\fP number of bytes to copy, must be >= 0
.RE
.PP
cnt > back is valid, this will copy the bytes we just copied, thus creating a repeating pattern with a period length of back\&. 
.SS "\fBvoid\fP* av_memdup (\fBconst\fP \fBvoid\fP * p, size_t size)"
Duplicate the buffer p\&. 
.PP
\fBParameters:\fP
.RS 4
\fIp\fP buffer to be duplicated 
.RE
.PP
\fBReturns:\fP
.RS 4
Pointer to a newly allocated buffer containing a copy of p or NULL if the buffer cannot be allocated\&. 
.RE
.PP

.SS "\fBvoid\fP* av_realloc (\fBvoid\fP * ptr, size_t size)"
Allocate or reallocate a block of memory\&. If ptr is NULL and size > 0, allocate a new block\&. If size is zero, free the memory block pointed to by ptr\&. 
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP Pointer to a memory block already allocated with \fBav_realloc()\fP or NULL\&. 
.br
\fIsize\fP Size in bytes of the memory block to be allocated or reallocated\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Pointer to a newly-reallocated block or NULL if the block cannot be reallocated or the function is used to free the memory block\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Pointers originating from the \fBav_malloc()\fP family of functions must not be passed to \fBav_realloc()\fP\&. The former can be implemented using memalign() (or other functions), and there is no guarantee that pointers from such functions can be passed to realloc() at all\&. The situation is undefined according to POSIX and may crash with some libc implementations\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBav_fast_realloc()\fP 
.RE
.PP

.SS "\fBvoid\fP* av_realloc_f (\fBvoid\fP * ptr, size_t nelem, size_t elsize)"
Allocate or reallocate a block of memory\&. This function does the same thing as av_realloc, except:
.IP "\(bu" 2
It takes two arguments and checks the result of the multiplication for integer overflow\&.
.IP "\(bu" 2
It frees the input block in case of failure, thus avoiding the memory leak with the classic 'buf = realloc(buf); if (!buf) return -1;'\&. 
.PP

.SS "\fBint\fP av_reallocp (\fBvoid\fP * ptr, size_t size)"
Allocate or reallocate a block of memory\&. If *ptr is NULL and size > 0, allocate a new block\&. If size is zero, free the memory block pointed to by ptr\&. 
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP Pointer to a pointer to a memory block already allocated with \fBav_realloc()\fP, or pointer to a pointer to NULL\&. The pointer is updated on success, or freed on failure\&. 
.br
\fIsize\fP Size in bytes for the memory block to be allocated or reallocated 
.RE
.PP
\fBReturns:\fP
.RS 4
Zero on success, an AVERROR error code on failure\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Pointers originating from the \fBav_malloc()\fP family of functions must not be passed to \fBav_reallocp()\fP\&. The former can be implemented using memalign() (or other functions), and there is no guarantee that pointers from such functions can be passed to realloc() at all\&. The situation is undefined according to POSIX and may crash with some libc implementations\&. 
.RE
.PP

.SS "char* av_strdup (\fBconst\fP char * s)"
Duplicate the string s\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP string to be duplicated 
.RE
.PP
\fBReturns:\fP
.RS 4
Pointer to a newly-allocated string containing a copy of s or NULL if the string cannot be allocated\&. 
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "size_t nmemb"

.PP
Definition at line 166 of file mem\&.h\&.
.SS "size_t size"
\fBInitial value:\fP
.PP
.nf
{
    if (!size || nmemb >= INT_MAX / size)
        return NULL
.fi
.PP
Definition at line 94 of file mem\&.h\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Audacity from the source code\&.
