.TH "lavc_misc" 3 "Thu Apr 28 2016" "Audacity" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lavc_misc \- Utility functions
.SS "Modules"

.in +1c
.ti -1c
.RI "\fBPixel formats\fP"
.br
.ti -1c
.RI "\fBFFT functions\fP"
.br
.in -1c
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBAVBitStreamFilterContext\fP"
.br
.ti -1c
.RI "struct \fBAVBitStreamFilter\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBAVBitStreamFilterContext\fP \fBAVBitStreamFilterContext\fP"
.br
.ti -1c
.RI "typedef struct \fBAVBitStreamFilter\fP \fBAVBitStreamFilter\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBAVLockOp\fP { \fBAV_LOCK_CREATE\fP, \fBAV_LOCK_OBTAIN\fP, \fBAV_LOCK_RELEASE\fP, \fBAV_LOCK_DESTROY\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBattribute_deprecated\fP \fBvoid\fP \fBavcodec_set_dimensions\fP (\fBAVCodecContext\fP *\fBs\fP, \fBint\fP width, \fBint\fP height)"
.br
.ti -1c
.RI "size_t \fBav_get_codec_tag_string\fP (char *\fBbuf\fP, size_t buf_size, unsigned \fBint\fP codec_tag)"
.br
.ti -1c
.RI "\fBvoid\fP \fBavcodec_string\fP (char *\fBbuf\fP, \fBint\fP buf_size, \fBAVCodecContext\fP *enc, \fBint\fP encode)"
.br
.ti -1c
.RI "\fBconst\fP char * \fBav_get_profile_name\fP (\fBconst\fP \fBAVCodec\fP *codec, \fBint\fP profile)"
.br
.ti -1c
.RI "\fBint\fP \fBavcodec_default_execute\fP (\fBAVCodecContext\fP *\fBc\fP, \fBint\fP(*func)(\fBAVCodecContext\fP *\fBc2\fP, \fBvoid\fP *arg2), \fBvoid\fP *arg, \fBint\fP *ret, \fBint\fP \fBcount\fP, \fBint\fP \fBsize\fP)"
.br
.ti -1c
.RI "\fBint\fP \fBavcodec_default_execute2\fP (\fBAVCodecContext\fP *\fBc\fP, \fBint\fP(*func)(\fBAVCodecContext\fP *\fBc2\fP, \fBvoid\fP *arg2, \fBint\fP, \fBint\fP), \fBvoid\fP *arg, \fBint\fP *ret, \fBint\fP \fBcount\fP)"
.br
.ti -1c
.RI "\fBint\fP \fBavcodec_fill_audio_frame\fP (\fBAVFrame\fP *frame, \fBint\fP nb_channels, enum \fBAVSampleFormat\fP sample_fmt, \fBconst\fP \fBuint8_t\fP *\fBbuf\fP, \fBint\fP buf_size, \fBint\fP align)"
.br
.ti -1c
.RI "\fBvoid\fP \fBavcodec_flush_buffers\fP (\fBAVCodecContext\fP *avctx)"
.br
.ti -1c
.RI "\fBint\fP \fBav_get_bits_per_sample\fP (enum \fBAVCodecID\fP codec_id)"
.br
.ti -1c
.RI "enum \fBAVCodecID\fP \fBav_get_pcm_codec\fP (enum \fBAVSampleFormat\fP fmt, \fBint\fP be)"
.br
.ti -1c
.RI "\fBint\fP \fBav_get_exact_bits_per_sample\fP (enum \fBAVCodecID\fP codec_id)"
.br
.ti -1c
.RI "\fBint\fP \fBav_get_audio_frame_duration\fP (\fBAVCodecContext\fP *avctx, \fBint\fP frame_bytes)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_register_bitstream_filter\fP (\fBAVBitStreamFilter\fP *bsf)"
.br
.ti -1c
.RI "\fBAVBitStreamFilterContext\fP * \fBav_bitstream_filter_init\fP (\fBconst\fP char *\fBname\fP)"
.br
.ti -1c
.RI "\fBint\fP \fBav_bitstream_filter_filter\fP (\fBAVBitStreamFilterContext\fP *bsfc, \fBAVCodecContext\fP *avctx, \fBconst\fP char *args, \fBuint8_t\fP **poutbuf, \fBint\fP *poutbuf_size, \fBconst\fP \fBuint8_t\fP *\fBbuf\fP, \fBint\fP buf_size, \fBint\fP keyframe)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_bitstream_filter_close\fP (\fBAVBitStreamFilterContext\fP *bsf)"
.br
.ti -1c
.RI "\fBAVBitStreamFilter\fP * \fBav_bitstream_filter_next\fP (\fBAVBitStreamFilter\fP *\fBf\fP)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_fast_padded_malloc\fP (\fBvoid\fP *ptr, unsigned \fBint\fP *\fBsize\fP, size_t min_size)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_fast_padded_mallocz\fP (\fBvoid\fP *ptr, unsigned \fBint\fP *\fBsize\fP, size_t min_size)"
.br
.ti -1c
.RI "unsigned \fBint\fP \fBav_xiphlacing\fP (unsigned char *\fBs\fP, unsigned \fBint\fP v)"
.br
.ti -1c
.RI "\fBattribute_deprecated\fP \fBvoid\fP \fBav_log_missing_feature\fP (\fBvoid\fP *avc, \fBconst\fP char *feature, \fBint\fP want_sample)"
.br
.ti -1c
.RI "\fBattribute_deprecated\fP \fBvoid\fP \fBav_log_ask_for_sample\fP (\fBvoid\fP *avc, \fBconst\fP char *msg,\&.\&.\&.) \fBav_printf_format\fP(2"
.br
.ti -1c
.RI "\fBattribute_deprecated\fP \fBvoid\fP \fBvoid\fP \fBav_register_hwaccel\fP (\fBAVHWAccel\fP *hwaccel)"
.br
.ti -1c
.RI "\fBAVHWAccel\fP * \fBav_hwaccel_next\fP (\fBAVHWAccel\fP *hwaccel)"
.br
.ti -1c
.RI "\fBint\fP \fBav_lockmgr_register\fP (\fBint\fP(*cb)(\fBvoid\fP **mutex, enum \fBAVLockOp\fP op))"
.br
.ti -1c
.RI "enum \fBAVMediaType\fP \fBavcodec_get_type\fP (enum \fBAVCodecID\fP codec_id)"
.br
.ti -1c
.RI "\fBconst\fP char * \fBavcodec_get_name\fP (enum \fBAVCodecID\fP id)"
.br
.ti -1c
.RI "\fBint\fP \fBavcodec_is_open\fP (\fBAVCodecContext\fP *\fBs\fP)"
.br
.ti -1c
.RI "\fBint\fP \fBav_codec_is_encoder\fP (\fBconst\fP \fBAVCodec\fP *codec)"
.br
.ti -1c
.RI "\fBint\fP \fBav_codec_is_decoder\fP (\fBconst\fP \fBAVCodec\fP *codec)"
.br
.ti -1c
.RI "\fBconst\fP \fBAVCodecDescriptor\fP * \fBavcodec_descriptor_get\fP (enum \fBAVCodecID\fP id)"
.br
.ti -1c
.RI "\fBconst\fP \fBAVCodecDescriptor\fP * \fBavcodec_descriptor_next\fP (\fBconst\fP \fBAVCodecDescriptor\fP *prev)"
.br
.ti -1c
.RI "\fBconst\fP \fBAVCodecDescriptor\fP * \fBavcodec_descriptor_get_by_name\fP (\fBconst\fP char *\fBname\fP)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Miscellaneous utility functions related to both encoding and decoding (or neither)\&. 
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBAVBitStreamFilter\fP  \fBAVBitStreamFilter\fP"

.SS "typedef struct \fBAVBitStreamFilterContext\fP  \fBAVBitStreamFilterContext\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBAVLockOp\fP"
Lock operation used by lockmgr 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIAV_LOCK_CREATE \fP\fP
Create a mutex\&. 
.TP
\fB\fIAV_LOCK_OBTAIN \fP\fP
Lock the mutex\&. 
.TP
\fB\fIAV_LOCK_RELEASE \fP\fP
Unlock the mutex\&. 
.TP
\fB\fIAV_LOCK_DESTROY \fP\fP
Free mutex resources\&. 
.PP
Definition at line 5023 of file avcodec\&.h\&.
.SH "Function Documentation"
.PP 
.SS "\fBvoid\fP av_bitstream_filter_close (\fBAVBitStreamFilterContext\fP * bsf)"
Release bitstream filter context\&.
.PP
\fBParameters:\fP
.RS 4
\fIbsf\fP the bitstream filter context created with \fBav_bitstream_filter_init()\fP, can be NULL 
.RE
.PP

.SS "\fBint\fP av_bitstream_filter_filter (\fBAVBitStreamFilterContext\fP * bsfc, \fBAVCodecContext\fP * avctx, \fBconst\fP char * args, \fBuint8_t\fP ** poutbuf, \fBint\fP * poutbuf_size, \fBconst\fP \fBuint8_t\fP * buf, \fBint\fP buf_size, \fBint\fP keyframe)"
\fBFilter\fP bitstream\&.
.PP
This function filters the buffer buf with size buf_size, and places the filtered buffer in the buffer pointed to by poutbuf\&.
.PP
The output buffer must be freed by the caller\&.
.PP
\fBParameters:\fP
.RS 4
\fIbsfc\fP bitstream filter context created by \fBav_bitstream_filter_init()\fP 
.br
\fIavctx\fP \fBAVCodecContext\fP accessed by the filter, may be NULL\&. If specified, this must point to the encoder context of the output stream the packet is sent to\&. 
.br
\fIargs\fP arguments which specify the filter configuration, may be NULL 
.br
\fIpoutbuf\fP pointer which is updated to point to the filtered buffer 
.br
\fIpoutbuf_size\fP pointer which is updated to the filtered buffer size in bytes 
.br
\fIbuf\fP buffer containing the data to filter 
.br
\fIbuf_size\fP size in bytes of buf 
.br
\fIkeyframe\fP set to non-zero if the buffer to filter corresponds to a key-frame packet data 
.RE
.PP
\fBReturns:\fP
.RS 4
>= 0 in case of success, or a negative error code in case of failure
.RE
.PP
If the return value is positive, an output buffer is allocated and is availble in *poutbuf, and is distinct from the input buffer\&.
.PP
If the return value is 0, the output buffer is not allocated and should be considered identical to the input buffer, or in case *poutbuf was set it points to the input buffer (not necessarily to its starting address)\&. 
.SS "\fBAVBitStreamFilterContext\fP* av_bitstream_filter_init (\fBconst\fP char * name)"
Create and initialize a bitstream filter context given a bitstream filter name\&.
.PP
The returned context must be freed with \fBav_bitstream_filter_close()\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIname\fP the name of the bitstream filter 
.RE
.PP
\fBReturns:\fP
.RS 4
a bitstream filter context if a matching filter was found and successfully initialized, NULL otherwise 
.RE
.PP

.SS "\fBAVBitStreamFilter\fP* av_bitstream_filter_next (\fBAVBitStreamFilter\fP * f)"
If f is NULL, return the first registered bitstream filter, if f is non-NULL, return the next registered bitstream filter after f, or NULL if f is the last one\&.
.PP
This function can be used to iterate over all registered bitstream filters\&. 
.SS "\fBint\fP av_codec_is_decoder (\fBconst\fP \fBAVCodec\fP * codec)"

.PP
\fBReturns:\fP
.RS 4
a non-zero number if codec is a decoder, zero otherwise 
.RE
.PP

.SS "\fBint\fP av_codec_is_encoder (\fBconst\fP \fBAVCodec\fP * codec)"

.PP
\fBReturns:\fP
.RS 4
a non-zero number if codec is an encoder, zero otherwise 
.RE
.PP

.SS "\fBvoid\fP av_fast_padded_malloc (\fBvoid\fP * ptr, unsigned \fBint\fP * size, size_t min_size)"
Same behaviour av_fast_malloc but the buffer has additional FF_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0\&.
.PP
In addition the whole buffer will initially and after resizes be 0-initialized so that no uninitialized data will ever appear\&. 
.SS "\fBvoid\fP av_fast_padded_mallocz (\fBvoid\fP * ptr, unsigned \fBint\fP * size, size_t min_size)"
Same behaviour av_fast_padded_malloc except that buffer will always be 0-initialized after call\&. 
.SS "\fBint\fP av_get_audio_frame_duration (\fBAVCodecContext\fP * avctx, \fBint\fP frame_bytes)"
Return audio frame duration\&.
.PP
\fBParameters:\fP
.RS 4
\fIavctx\fP codec context 
.br
\fIframe_bytes\fP size of the frame, or 0 if unknown 
.RE
.PP
\fBReturns:\fP
.RS 4
frame duration, in samples, if known\&. 0 if not able to determine\&. 
.RE
.PP

.SS "\fBint\fP av_get_bits_per_sample (enum \fBAVCodecID\fP codec_id)"
Return codec bits per sample\&.
.PP
\fBParameters:\fP
.RS 4
\fIcodec_id\fP the codec 
.RE
.PP
\fBReturns:\fP
.RS 4
Number of bits per sample or zero if unknown for the given codec\&. 
.RE
.PP

.SS "size_t av_get_codec_tag_string (char * buf, size_t buf_size, unsigned \fBint\fP codec_tag)"
Put a string representing the codec tag codec_tag in buf\&.
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP buffer to place codec tag in 
.br
\fIbuf_size\fP size in bytes of buf 
.br
\fIcodec_tag\fP codec tag to assign 
.RE
.PP
\fBReturns:\fP
.RS 4
the length of the string that would have been generated if enough space had been available, excluding the trailing null 
.RE
.PP

.SS "\fBint\fP av_get_exact_bits_per_sample (enum \fBAVCodecID\fP codec_id)"
Return codec bits per sample\&. Only return non-zero if the bits per sample is exactly correct, not an approximation\&.
.PP
\fBParameters:\fP
.RS 4
\fIcodec_id\fP the codec 
.RE
.PP
\fBReturns:\fP
.RS 4
Number of bits per sample or zero if unknown for the given codec\&. 
.RE
.PP

.SS "enum \fBAVCodecID\fP av_get_pcm_codec (enum \fBAVSampleFormat\fP fmt, \fBint\fP be)"
Return the PCM codec associated with a sample format\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbe\fP endianness, 0 for little, 1 for big, -1 (or anything else) for native 
.RE
.PP
\fBReturns:\fP
.RS 4
AV_CODEC_ID_PCM_* or AV_CODEC_ID_NONE 
.RE
.PP

.SS "\fBconst\fP char* av_get_profile_name (\fBconst\fP \fBAVCodec\fP * codec, \fBint\fP profile)"
Return a name for the specified profile, if available\&.
.PP
\fBParameters:\fP
.RS 4
\fIcodec\fP the codec that is searched for the given profile 
.br
\fIprofile\fP the profile value for which a name is requested 
.RE
.PP
\fBReturns:\fP
.RS 4
A name for the profile if found, NULL otherwise\&. 
.RE
.PP

.SS "\fBAVHWAccel\fP* av_hwaccel_next (\fBAVHWAccel\fP * hwaccel)"
If hwaccel is NULL, returns the first registered hardware accelerator, if hwaccel is non-NULL, returns the next registered hardware accelerator after hwaccel, or NULL if hwaccel is the last one\&. 
.SS "\fBint\fP av_lockmgr_register (\fBint\fP(*)(\fBvoid\fP **mutex, enum \fBAVLockOp\fP op) cb)"
Register a user provided lock manager supporting the operations specified by AVLockOp\&. mutex points to a (void *) where the lockmgr should store/get a pointer to a user allocated mutex\&. It's NULL upon AV_LOCK_CREATE and != NULL for all other ops\&.
.PP
\fBParameters:\fP
.RS 4
\fIcb\fP User defined callback\&. Note: FFmpeg may invoke calls to this callback during the call to \fBav_lockmgr_register()\fP\&. Thus, the application must be prepared to handle that\&. If cb is set to NULL the lockmgr will be unregistered\&. Also note that during unregistration the previously registered lockmgr callback may also be invoked\&. 
.RE
.PP

.SS "\fBattribute_deprecated\fP \fBvoid\fP av_log_ask_for_sample (\fBvoid\fP * avc, \fBconst\fP char * msg,  \&.\&.\&.)"
Log a generic warning message asking for a sample\&. This function is intended to be used internally by FFmpeg (libavcodec, libavformat, etc\&.) only, and would normally not be used by applications\&. 
.PP
\fBParameters:\fP
.RS 4
\fIavc\fP a pointer to an arbitrary struct of which the first field is a pointer to an \fBAVClass\fP struct 
.br
\fImsg\fP string containing an optional message, or NULL if no message 
.RE
.PP
\fBDeprecated\fP
.RS 4
Use avpriv_request_sample() instead\&. 
.RE
.PP

.SS "\fBattribute_deprecated\fP \fBvoid\fP av_log_missing_feature (\fBvoid\fP * avc, \fBconst\fP char * feature, \fBint\fP want_sample)"
Log a generic warning message about a missing feature\&. This function is intended to be used internally by FFmpeg (libavcodec, libavformat, etc\&.) only, and would normally not be used by applications\&. 
.PP
\fBParameters:\fP
.RS 4
\fIavc\fP a pointer to an arbitrary struct of which the first field is a pointer to an \fBAVClass\fP struct 
.br
\fIfeature\fP string containing the name of the missing feature 
.br
\fIwant_sample\fP indicates if samples are wanted which exhibit this feature\&. If want_sample is non-zero, additional verbage will be added to the log message which tells the user how to report samples to the development mailing list\&. 
.RE
.PP
\fBDeprecated\fP
.RS 4
Use avpriv_report_missing_feature() instead\&. 
.RE
.PP

.SS "\fBvoid\fP av_register_bitstream_filter (\fBAVBitStreamFilter\fP * bsf)"
Register a bitstream filter\&.
.PP
The filter will be accessible to the application code through \fBav_bitstream_filter_next()\fP or can be directly initialized with \fBav_bitstream_filter_init()\fP\&.
.PP
\fBSee also:\fP
.RS 4
\fBavcodec_register_all()\fP 
.RE
.PP

.SS "\fBattribute_deprecated\fP \fBvoid\fP \fBvoid\fP av_register_hwaccel (\fBAVHWAccel\fP * hwaccel)"
Register the hardware accelerator hwaccel\&. 
.SS "unsigned \fBint\fP av_xiphlacing (unsigned char * s, unsigned \fBint\fP v)"
Encode extradata length to a buffer\&. Used by xiph codecs\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP buffer to write to; must be at least (v/255+1) bytes long 
.br
\fIv\fP size of extradata in bytes 
.RE
.PP
\fBReturns:\fP
.RS 4
number of bytes written to the buffer\&. 
.RE
.PP

.SS "\fBint\fP avcodec_default_execute (\fBAVCodecContext\fP * c, \fBint\fP(*)(\fBAVCodecContext\fP *\fBc2\fP, \fBvoid\fP *arg2) func, \fBvoid\fP * arg, \fBint\fP * ret, \fBint\fP count, \fBint\fP size)"

.SS "\fBint\fP avcodec_default_execute2 (\fBAVCodecContext\fP * c, \fBint\fP(*)(\fBAVCodecContext\fP *\fBc2\fP, \fBvoid\fP *arg2, \fBint\fP, \fBint\fP) func, \fBvoid\fP * arg, \fBint\fP * ret, \fBint\fP count)"

.SS "\fBconst\fP \fBAVCodecDescriptor\fP* avcodec_descriptor_get (enum \fBAVCodecID\fP id)"

.PP
\fBReturns:\fP
.RS 4
descriptor for given codec ID or NULL if no descriptor exists\&. 
.RE
.PP

.SS "\fBconst\fP \fBAVCodecDescriptor\fP* avcodec_descriptor_get_by_name (\fBconst\fP char * name)"

.PP
\fBReturns:\fP
.RS 4
codec descriptor with the given name or NULL if no such descriptor exists\&. 
.RE
.PP

.SS "\fBconst\fP \fBAVCodecDescriptor\fP* avcodec_descriptor_next (\fBconst\fP \fBAVCodecDescriptor\fP * prev)"
Iterate over all codec descriptors known to libavcodec\&.
.PP
\fBParameters:\fP
.RS 4
\fIprev\fP previous descriptor\&. NULL to get the first descriptor\&.
.RE
.PP
\fBReturns:\fP
.RS 4
next descriptor or NULL after the last descriptor 
.RE
.PP

.SS "\fBint\fP avcodec_fill_audio_frame (\fBAVFrame\fP * frame, \fBint\fP nb_channels, enum \fBAVSampleFormat\fP sample_fmt, \fBconst\fP \fBuint8_t\fP * buf, \fBint\fP buf_size, \fBint\fP align)"
Fill \fBAVFrame\fP audio data and linesize pointers\&.
.PP
The buffer buf must be a preallocated buffer with a size big enough to contain the specified samples amount\&. The filled \fBAVFrame\fP data pointers will point to this buffer\&.
.PP
\fBAVFrame\fP extended_data channel pointers are allocated if necessary for planar audio\&.
.PP
\fBParameters:\fP
.RS 4
\fIframe\fP the \fBAVFrame\fP frame->nb_samples must be set prior to calling the function\&. This function fills in frame->data, frame->extended_data, frame->linesize[0]\&. 
.br
\fInb_channels\fP channel count 
.br
\fIsample_fmt\fP sample format 
.br
\fIbuf\fP buffer to use for frame data 
.br
\fIbuf_size\fP size of buffer 
.br
\fIalign\fP plane size sample alignment (0 = default) 
.RE
.PP
\fBReturns:\fP
.RS 4
>=0 on success, negative error code on failure 
.RE
.PP
\fBTodo\fP
.RS 4
return the size in bytes required to store the samples in case of success, at the next libavutil bump 
.RE
.PP

.SS "\fBvoid\fP avcodec_flush_buffers (\fBAVCodecContext\fP * avctx)"
Reset the internal decoder state / flush internal buffers\&. Should be called e\&.g\&. when seeking or when switching to a different stream\&.
.PP
\fBNote:\fP
.RS 4
when refcounted frames are not used (i\&.e\&. avctx->refcounted_frames is 0), this invalidates the frames previously returned from the decoder\&. When refcounted frames are used, the decoder just releases any references it might keep internally, but the caller's reference remains valid\&. 
.RE
.PP

.SS "\fBconst\fP char* avcodec_get_name (enum \fBAVCodecID\fP id)"
Get the name of a codec\&. 
.PP
\fBReturns:\fP
.RS 4
a static string identifying the codec; never NULL 
.RE
.PP

.SS "enum \fBAVMediaType\fP avcodec_get_type (enum \fBAVCodecID\fP codec_id)"
Get the type of the given codec\&. 
.SS "\fBint\fP avcodec_is_open (\fBAVCodecContext\fP * s)"

.PP
\fBReturns:\fP
.RS 4
a positive value if s is open (i\&.e\&. \fBavcodec_open2()\fP was called on it with no corresponding \fBavcodec_close()\fP), 0 otherwise\&. 
.RE
.PP

.SS "\fBattribute_deprecated\fP \fBvoid\fP avcodec_set_dimensions (\fBAVCodecContext\fP * s, \fBint\fP width, \fBint\fP height)"

.PP
\fBDeprecated\fP
.RS 4
this function is not supposed to be used from outside of lavc 
.RE
.PP

.SS "\fBvoid\fP avcodec_string (char * buf, \fBint\fP buf_size, \fBAVCodecContext\fP * enc, \fBint\fP encode)"

.SH "Author"
.PP 
Generated automatically by Doxygen for Audacity from the source code\&.
