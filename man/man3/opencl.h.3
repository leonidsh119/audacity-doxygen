.TH "C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/opencl.h" 3 "Thu Apr 28 2016" "Audacity" \" -*- nroff -*-
.ad l
.nh
.SH NAME
C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/opencl.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'config\&.h'\fP
.br
\fC#include <OpenCL/cl\&.h>\fP
.br
\fC#include 'dict\&.h'\fP
.br
\fC#include 'libavutil/version\&.h'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBAVOpenCLDeviceNode\fP"
.br
.ti -1c
.RI "struct \fBAVOpenCLPlatformNode\fP"
.br
.ti -1c
.RI "struct \fBAVOpenCLDeviceList\fP"
.br
.ti -1c
.RI "struct \fBAVOpenCLExternalEnv\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBAV_OPENCL_KERNEL\fP(\&.\&.\&.)   # __VA_ARGS__"
.br
.ti -1c
.RI "#define \fBAV_OPENCL_MAX_KERNEL_NAME_SIZE\fP   150"
.br
.ti -1c
.RI "#define \fBAV_OPENCL_MAX_DEVICE_NAME_SIZE\fP   100"
.br
.ti -1c
.RI "#define \fBAV_OPENCL_MAX_PLATFORM_NAME_SIZE\fP   100"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBint\fP \fBav_opencl_get_device_list\fP (\fBAVOpenCLDeviceList\fP **device_list)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_opencl_free_device_list\fP (\fBAVOpenCLDeviceList\fP **device_list)"
.br
.ti -1c
.RI "\fBint\fP \fBav_opencl_set_option\fP (\fBconst\fP char *key, \fBconst\fP char *val)"
.br
.ti -1c
.RI "\fBint\fP \fBav_opencl_get_option\fP (\fBconst\fP char *key, \fBuint8_t\fP **out_val)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_opencl_free_option\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBAVOpenCLExternalEnv\fP * \fBav_opencl_alloc_external_env\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_opencl_free_external_env\fP (\fBAVOpenCLExternalEnv\fP **ext_opencl_env)"
.br
.ti -1c
.RI "\fBconst\fP char * \fBav_opencl_errstr\fP (cl_int \fBstatus\fP)"
.br
.ti -1c
.RI "\fBint\fP \fBav_opencl_register_kernel_code\fP (\fBconst\fP char *kernel_code)"
.br
.ti -1c
.RI "\fBint\fP \fBav_opencl_init\fP (\fBAVOpenCLExternalEnv\fP *ext_opencl_env)"
.br
.ti -1c
.RI "cl_program \fBav_opencl_compile\fP (\fBconst\fP char *\fBprogram_name\fP, \fBconst\fP char *build_opts)"
.br
.ti -1c
.RI "cl_command_queue \fBav_opencl_get_command_queue\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBint\fP \fBav_opencl_buffer_create\fP (cl_mem *cl_buf, size_t cl_buf_size, \fBint\fP flags, \fBvoid\fP *host_ptr)"
.br
.ti -1c
.RI "\fBint\fP \fBav_opencl_buffer_write\fP (cl_mem dst_cl_buf, \fBuint8_t\fP *src_buf, size_t buf_size)"
.br
.ti -1c
.RI "\fBint\fP \fBav_opencl_buffer_read\fP (\fBuint8_t\fP *dst_buf, cl_mem src_cl_buf, size_t buf_size)"
.br
.ti -1c
.RI "\fBint\fP \fBav_opencl_buffer_write_image\fP (cl_mem dst_cl_buf, size_t cl_buffer_size, \fBint\fP dst_cl_offset, \fBuint8_t\fP **src_data, \fBint\fP *plane_size, \fBint\fP plane_num)"
.br
.ti -1c
.RI "\fBint\fP \fBav_opencl_buffer_read_image\fP (\fBuint8_t\fP **dst_data, \fBint\fP *plane_size, \fBint\fP plane_num, cl_mem src_cl_buf, size_t cl_buffer_size)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_opencl_buffer_release\fP (cl_mem *cl_buf)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_opencl_uninit\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBint64_t\fP \fBav_opencl_benchmark\fP (\fBAVOpenCLDeviceNode\fP *device, cl_platform_id platform, \fBint64_t\fP(*benchmark)(\fBAVOpenCLExternalEnv\fP *ext_opencl_env))"
.br
.in -1c
.SH "Detailed Description"
.PP 
OpenCL wrapper
.PP
This interface is considered still experimental and its API and ABI may change without prior notice\&. 
.PP
Definition in file \fBopencl\&.h\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define AV_OPENCL_KERNEL( \&.\&.\&.)   # __VA_ARGS__"

.PP
Definition at line 45 of file opencl\&.h\&.
.SS "#define AV_OPENCL_MAX_DEVICE_NAME_SIZE   100"

.PP
Definition at line 49 of file opencl\&.h\&.
.SS "#define AV_OPENCL_MAX_KERNEL_NAME_SIZE   150"

.PP
Definition at line 47 of file opencl\&.h\&.
.SS "#define AV_OPENCL_MAX_PLATFORM_NAME_SIZE   100"

.PP
Definition at line 51 of file opencl\&.h\&.
.SH "Function Documentation"
.PP 
.SS "\fBAVOpenCLExternalEnv\fP* av_opencl_alloc_external_env (\fBvoid\fP)"
Allocate OpenCL external environment\&.
.PP
It must be freed with \fBav_opencl_free_external_env()\fP\&.
.PP
\fBReturns:\fP
.RS 4
pointer to allocated OpenCL external environment 
.RE
.PP

.SS "\fBint64_t\fP av_opencl_benchmark (\fBAVOpenCLDeviceNode\fP * device, cl_platform_id platform, \fBint64_t\fP(*)(\fBAVOpenCLExternalEnv\fP *ext_opencl_env) benchmark)"
Benchmark an OpenCL device with a user defined callback function\&. This function sets up an external OpenCL environment including context and command queue on the device then tears it down in the end\&. The callback function should perform the rest of the work\&.
.PP
\fBParameters:\fP
.RS 4
\fIdevice\fP pointer to the OpenCL device to be used 
.br
\fIplatform\fP cl_platform_id handle to which the device belongs to 
.br
\fIbenchmark\fP callback function to perform the benchmark, return a negative value in case of failure 
.RE
.PP
\fBReturns:\fP
.RS 4
the score passed from the callback function, a negative error code in case of failure 
.RE
.PP

.SS "\fBint\fP av_opencl_buffer_create (cl_mem * cl_buf, size_t cl_buf_size, \fBint\fP flags, \fBvoid\fP * host_ptr)"
Create OpenCL buffer\&.
.PP
The buffer is used to save the data used or created by an OpenCL kernel\&. The created buffer must be released with \fBav_opencl_buffer_release()\fP\&.
.PP
See clCreateBuffer() function reference for more information about the parameters\&.
.PP
\fBParameters:\fP
.RS 4
\fIcl_buf\fP pointer to OpenCL buffer 
.br
\fIcl_buf_size\fP size in bytes of the OpenCL buffer to create 
.br
\fIflags\fP flags used to control buffer attributes 
.br
\fIhost_ptr\fP host pointer of the OpenCL buffer 
.RE
.PP
\fBReturns:\fP
.RS 4
>=0 on success, a negative error code in case of failure 
.RE
.PP

.SS "\fBint\fP av_opencl_buffer_read (\fBuint8_t\fP * dst_buf, cl_mem src_cl_buf, size_t buf_size)"
Read data from OpenCL buffer to memory buffer\&.
.PP
\fBParameters:\fP
.RS 4
\fIdst_buf\fP pointer to destination buffer (CPU memory) 
.br
\fIsrc_cl_buf\fP pointer to source OpenCL buffer 
.br
\fIbuf_size\fP size in bytes of the source and destination buffers 
.RE
.PP
\fBReturns:\fP
.RS 4
>=0 on success, a negative error code in case of failure 
.RE
.PP

.SS "\fBint\fP av_opencl_buffer_read_image (\fBuint8_t\fP ** dst_data, \fBint\fP * plane_size, \fBint\fP plane_num, cl_mem src_cl_buf, size_t cl_buffer_size)"
Read image data from OpenCL buffer\&.
.PP
\fBParameters:\fP
.RS 4
\fIdst_data\fP array of pointers to destination plane buffers 
.br
\fIdst_plane_sizes\fP array of pointers to destination plane buffers 
.br
\fIdst_plane_num\fP number of destination image planes 
.br
\fIsrc_cl_buf\fP pointer to source OpenCL buffer 
.br
\fIsrc_cl_buf_size\fP size in bytes of OpenCL buffer 
.RE
.PP
\fBReturns:\fP
.RS 4
>=0 on success, a negative error code in case of failure 
.RE
.PP

.SS "\fBvoid\fP av_opencl_buffer_release (cl_mem * cl_buf)"
Release OpenCL buffer\&.
.PP
\fBParameters:\fP
.RS 4
\fIcl_buf\fP pointer to OpenCL buffer to release, which was previously filled with \fBav_opencl_buffer_create()\fP 
.RE
.PP

.SS "\fBint\fP av_opencl_buffer_write (cl_mem dst_cl_buf, \fBuint8_t\fP * src_buf, size_t buf_size)"
Write OpenCL buffer with data from src_buf\&.
.PP
\fBParameters:\fP
.RS 4
\fIdst_cl_buf\fP pointer to OpenCL destination buffer 
.br
\fIsrc_buf\fP pointer to source buffer 
.br
\fIbuf_size\fP size in bytes of the source and destination buffers 
.RE
.PP
\fBReturns:\fP
.RS 4
>=0 on success, a negative error code in case of failure 
.RE
.PP

.SS "\fBint\fP av_opencl_buffer_write_image (cl_mem dst_cl_buf, size_t cl_buffer_size, \fBint\fP dst_cl_offset, \fBuint8_t\fP ** src_data, \fBint\fP * plane_size, \fBint\fP plane_num)"
Write image data from memory to OpenCL buffer\&.
.PP
The source must be an array of pointers to image plane buffers\&.
.PP
\fBParameters:\fP
.RS 4
\fIdst_cl_buf\fP pointer to destination OpenCL buffer 
.br
\fIdst_cl_buf_size\fP size in bytes of OpenCL buffer 
.br
\fIdst_cl_buf_offset\fP the offset of the OpenCL buffer start position 
.br
\fIsrc_data\fP array of pointers to source plane buffers 
.br
\fIsrc_plane_sizes\fP array of sizes in bytes of the source plane buffers 
.br
\fIsrc_plane_num\fP number of source image planes 
.RE
.PP
\fBReturns:\fP
.RS 4
>=0 on success, a negative error code in case of failure 
.RE
.PP

.SS "cl_program av_opencl_compile (\fBconst\fP char * program_name, \fBconst\fP char * build_opts)"
compile specific OpenCL kernel source
.PP
\fBParameters:\fP
.RS 4
\fIprogram_name\fP pointer to a program name used for identification 
.br
\fIbuild_opts\fP pointer to a string that describes the preprocessor build options to be used for building the program 
.RE
.PP
\fBReturns:\fP
.RS 4
a cl_program object 
.RE
.PP

.SS "\fBconst\fP char* av_opencl_errstr (cl_int status)"
Get OpenCL error string\&.
.PP
\fBParameters:\fP
.RS 4
\fIstatus\fP OpenCL error code 
.RE
.PP
\fBReturns:\fP
.RS 4
OpenCL error string 
.RE
.PP

.SS "\fBvoid\fP av_opencl_free_device_list (\fBAVOpenCLDeviceList\fP ** device_list)"
Free OpenCL device list\&.
.PP
\fBParameters:\fP
.RS 4
\fIdevice_list\fP pointer to OpenCL environment device list created by \fBav_opencl_get_device_list()\fP 
.RE
.PP

.SS "\fBvoid\fP av_opencl_free_external_env (\fBAVOpenCLExternalEnv\fP ** ext_opencl_env)"
Free OpenCL external environment\&.
.PP
\fBParameters:\fP
.RS 4
\fIext_opencl_env\fP pointer to OpenCL external environment created by \fBav_opencl_alloc_external_env()\fP 
.RE
.PP

.SS "\fBvoid\fP av_opencl_free_option (\fBvoid\fP)"
Free option values of the global OpenCL context\&. 
.SS "cl_command_queue av_opencl_get_command_queue (\fBvoid\fP)"
get OpenCL command queue
.PP
\fBReturns:\fP
.RS 4
a cl_command_queue object 
.RE
.PP

.SS "\fBint\fP av_opencl_get_device_list (\fBAVOpenCLDeviceList\fP ** device_list)"
Get OpenCL device list\&.
.PP
It must be freed with \fBav_opencl_free_device_list()\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIdevice_list\fP pointer to OpenCL environment device list, should be released by \fBav_opencl_free_device_list()\fP
.RE
.PP
\fBReturns:\fP
.RS 4
>=0 on success, a negative error code in case of failure 
.RE
.PP

.SS "\fBint\fP av_opencl_get_option (\fBconst\fP char * key, \fBuint8_t\fP ** out_val)"
Get option value from the global OpenCL context\&.
.PP
\fBParameters:\fP
.RS 4
\fIkey\fP option key 
.br
\fIout_val\fP pointer to location where option value will be written, must be freed with \fBav_freep()\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
>=0 on success, a negative error code in case of failure 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBav_opencl_set_option()\fP 
.RE
.PP

.SS "\fBint\fP av_opencl_init (\fBAVOpenCLExternalEnv\fP * ext_opencl_env)"
Initialize the run time OpenCL environment
.PP
\fBParameters:\fP
.RS 4
\fIext_opencl_env\fP external OpenCL environment, created by an application program, ignored if set to NULL 
.RE
.PP
\fBReturns:\fP
.RS 4
>=0 on success, a negative error code in case of failure 
.RE
.PP

.SS "\fBint\fP av_opencl_register_kernel_code (\fBconst\fP char * kernel_code)"
Register kernel code\&.
.PP
The registered kernel code is stored in a global context, and compiled in the runtime environment when \fBav_opencl_init()\fP is called\&.
.PP
\fBParameters:\fP
.RS 4
\fIkernel_code\fP kernel code to be compiled in the OpenCL runtime environment 
.RE
.PP
\fBReturns:\fP
.RS 4
>=0 on success, a negative error code in case of failure 
.RE
.PP

.SS "\fBint\fP av_opencl_set_option (\fBconst\fP char * key, \fBconst\fP char * val)"
Set option in the global OpenCL context\&.
.PP
This options affect the operation performed by the next \fBav_opencl_init()\fP operation\&.
.PP
The currently accepted options are:
.IP "\(bu" 2
platform: set index of platform in device list
.IP "\(bu" 2
device: set index of device in device list
.PP
.PP
See reference 'OpenCL Specification Version: 1\&.2 chapter 5\&.6\&.4'\&.
.PP
\fBParameters:\fP
.RS 4
\fIkey\fP option key 
.br
\fIval\fP option value 
.RE
.PP
\fBReturns:\fP
.RS 4
>=0 on success, a negative error code in case of failure 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBav_opencl_get_option()\fP 
.RE
.PP

.SS "\fBvoid\fP av_opencl_uninit (\fBvoid\fP)"
Release OpenCL environment\&.
.PP
The OpenCL environment is effectively released only if all the created kernels had been released with av_opencl_release_kernel()\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for Audacity from the source code\&.
