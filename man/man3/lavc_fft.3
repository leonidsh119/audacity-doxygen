.TH "lavc_fft" 3 "Thu Apr 28 2016" "Audacity" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lavc_fft \- FFT functions
.SS "Files"

.in +1c
.ti -1c
.RI "file \fBavfft\&.h\fP"
.br
.in -1c
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBFFTComplex\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef float \fBFFTSample\fP"
.br
.ti -1c
.RI "typedef struct \fBFFTComplex\fP \fBFFTComplex\fP"
.br
.ti -1c
.RI "typedef struct \fBFFTContext\fP \fBFFTContext\fP"
.br
.ti -1c
.RI "typedef struct \fBRDFTContext\fP \fBRDFTContext\fP"
.br
.ti -1c
.RI "typedef struct \fBDCTContext\fP \fBDCTContext\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBRDFTransformType\fP { \fBDFT_R2C\fP, \fBIDFT_C2R\fP, \fBIDFT_R2C\fP, \fBDFT_C2R\fP }"
.br
.ti -1c
.RI "enum \fBDCTTransformType\fP { \fBDCT_II\fP = 0, \fBDCT_III\fP, \fBDCT_I\fP, \fBDST_I\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBFFTContext\fP * \fBav_fft_init\fP (\fBint\fP nbits, \fBint\fP inverse)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_fft_permute\fP (\fBFFTContext\fP *\fBs\fP, \fBFFTComplex\fP *z)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_fft_calc\fP (\fBFFTContext\fP *\fBs\fP, \fBFFTComplex\fP *z)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_fft_end\fP (\fBFFTContext\fP *\fBs\fP)"
.br
.ti -1c
.RI "\fBFFTContext\fP * \fBav_mdct_init\fP (\fBint\fP nbits, \fBint\fP inverse, double \fBscale\fP)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_imdct_calc\fP (\fBFFTContext\fP *\fBs\fP, \fBFFTSample\fP *\fBoutput\fP, \fBconst\fP \fBFFTSample\fP *input)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_imdct_half\fP (\fBFFTContext\fP *\fBs\fP, \fBFFTSample\fP *\fBoutput\fP, \fBconst\fP \fBFFTSample\fP *input)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_mdct_calc\fP (\fBFFTContext\fP *\fBs\fP, \fBFFTSample\fP *\fBoutput\fP, \fBconst\fP \fBFFTSample\fP *input)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_mdct_end\fP (\fBFFTContext\fP *\fBs\fP)"
.br
.ti -1c
.RI "\fBRDFTContext\fP * \fBav_rdft_init\fP (\fBint\fP nbits, enum \fBRDFTransformType\fP trans)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_rdft_calc\fP (\fBRDFTContext\fP *\fBs\fP, \fBFFTSample\fP *\fBdata\fP)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_rdft_end\fP (\fBRDFTContext\fP *\fBs\fP)"
.br
.ti -1c
.RI "\fBDCTContext\fP * \fBav_dct_init\fP (\fBint\fP nbits, enum \fBDCTTransformType\fP type)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_dct_calc\fP (\fBDCTContext\fP *\fBs\fP, \fBFFTSample\fP *\fBdata\fP)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_dct_end\fP (\fBDCTContext\fP *\fBs\fP)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBDCTContext\fP \fBDCTContext\fP"

.PP
Definition at line 91 of file avfft\&.h\&.
.SS "typedef struct \fBFFTComplex\fP  \fBFFTComplex\fP"

.SS "typedef struct \fBFFTContext\fP \fBFFTContext\fP"

.PP
Definition at line 41 of file avfft\&.h\&.
.SS "typedef float \fBFFTSample\fP"

.PP
Definition at line 35 of file avfft\&.h\&.
.SS "typedef struct \fBRDFTContext\fP \fBRDFTContext\fP"

.PP
Definition at line 78 of file avfft\&.h\&.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBDCTTransformType\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIDCT_II \fP\fP
.TP
\fB\fIDCT_III \fP\fP
.TP
\fB\fIDCT_I \fP\fP
.TP
\fB\fIDST_I \fP\fP
.PP
Definition at line 93 of file avfft\&.h\&.
.SS "enum \fBRDFTransformType\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIDFT_R2C \fP\fP
.TP
\fB\fIIDFT_C2R \fP\fP
.TP
\fB\fIIDFT_R2C \fP\fP
.TP
\fB\fIDFT_C2R \fP\fP
.PP
Definition at line 71 of file avfft\&.h\&.
.SH "Function Documentation"
.PP 
.SS "\fBvoid\fP av_dct_calc (\fBDCTContext\fP * s, \fBFFTSample\fP * data)"

.SS "\fBvoid\fP av_dct_end (\fBDCTContext\fP * s)"

.SS "\fBDCTContext\fP* av_dct_init (\fBint\fP nbits, enum \fBDCTTransformType\fP type)"
Set up DCT\&.
.PP
\fBParameters:\fP
.RS 4
\fInbits\fP size of the input array: (1 << nbits) for DCT-II, DCT-III and DST-I (1 << nbits) + 1 for DCT-I 
.br
\fItype\fP the type of transform
.RE
.PP
\fBNote:\fP
.RS 4
the first element of the input of DST-I is ignored 
.RE
.PP

.SS "\fBvoid\fP av_fft_calc (\fBFFTContext\fP * s, \fBFFTComplex\fP * z)"
Do a complex FFT with the parameters defined in \fBav_fft_init()\fP\&. The input data must be permuted before\&. No 1\&.0/sqrt(n) normalization is done\&. 
.SS "\fBvoid\fP av_fft_end (\fBFFTContext\fP * s)"

.SS "\fBFFTContext\fP* av_fft_init (\fBint\fP nbits, \fBint\fP inverse)"
Set up a complex FFT\&. 
.PP
\fBParameters:\fP
.RS 4
\fInbits\fP log2 of the length of the input array 
.br
\fIinverse\fP if 0 perform the forward transform, if 1 perform the inverse 
.RE
.PP

.SS "\fBvoid\fP av_fft_permute (\fBFFTContext\fP * s, \fBFFTComplex\fP * z)"
Do the permutation needed BEFORE calling ff_fft_calc()\&. 
.SS "\fBvoid\fP av_imdct_calc (\fBFFTContext\fP * s, \fBFFTSample\fP * output, \fBconst\fP \fBFFTSample\fP * input)"

.SS "\fBvoid\fP av_imdct_half (\fBFFTContext\fP * s, \fBFFTSample\fP * output, \fBconst\fP \fBFFTSample\fP * input)"

.SS "\fBvoid\fP av_mdct_calc (\fBFFTContext\fP * s, \fBFFTSample\fP * output, \fBconst\fP \fBFFTSample\fP * input)"

.SS "\fBvoid\fP av_mdct_end (\fBFFTContext\fP * s)"

.SS "\fBFFTContext\fP* av_mdct_init (\fBint\fP nbits, \fBint\fP inverse, double scale)"

.SS "\fBvoid\fP av_rdft_calc (\fBRDFTContext\fP * s, \fBFFTSample\fP * data)"

.SS "\fBvoid\fP av_rdft_end (\fBRDFTContext\fP * s)"

.SS "\fBRDFTContext\fP* av_rdft_init (\fBint\fP nbits, enum \fBRDFTransformType\fP trans)"
Set up a real FFT\&. 
.PP
\fBParameters:\fP
.RS 4
\fInbits\fP log2 of the length of the input array 
.br
\fItrans\fP the type of transform 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Audacity from the source code\&.
