.TH "AVFrame" 3 "Thu Apr 28 2016" "Audacity" \" -*- nroff -*-
.ad l
.nh
.SH NAME
AVFrame \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <frame\&.h>\fP
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBuint8_t\fP * \fBdata\fP [\fBAV_NUM_DATA_POINTERS\fP]"
.br
.ti -1c
.RI "\fBint\fP \fBlinesize\fP [\fBAV_NUM_DATA_POINTERS\fP]"
.br
.ti -1c
.RI "\fBuint8_t\fP ** \fBextended_data\fP"
.br
.ti -1c
.RI "\fBint\fP \fBwidth\fP"
.br
.ti -1c
.RI "\fBint\fP \fBheight\fP"
.br
.ti -1c
.RI "\fBint\fP \fBnb_samples\fP"
.br
.ti -1c
.RI "\fBint\fP \fBformat\fP"
.br
.ti -1c
.RI "\fBint\fP \fBkey_frame\fP"
.br
.ti -1c
.RI "enum \fBAVPictureType\fP \fBpict_type\fP"
.br
.ti -1c
.RI "\fBattribute_deprecated\fP \fBuint8_t\fP * \fBbase\fP [\fBAV_NUM_DATA_POINTERS\fP]"
.br
.ti -1c
.RI "\fBAVRational\fP \fBsample_aspect_ratio\fP"
.br
.ti -1c
.RI "\fBint64_t\fP \fBpts\fP"
.br
.ti -1c
.RI "\fBint64_t\fP \fBpkt_pts\fP"
.br
.ti -1c
.RI "\fBint64_t\fP \fBpkt_dts\fP"
.br
.ti -1c
.RI "\fBint\fP \fBcoded_picture_number\fP"
.br
.ti -1c
.RI "\fBint\fP \fBdisplay_picture_number\fP"
.br
.ti -1c
.RI "\fBint\fP \fBquality\fP"
.br
.ti -1c
.RI "\fBattribute_deprecated\fP \fBint\fP \fBreference\fP"
.br
.ti -1c
.RI "\fBattribute_deprecated\fP \fBint8_t\fP * \fBqscale_table\fP"
.br
.ti -1c
.RI "\fBattribute_deprecated\fP \fBint\fP \fBqstride\fP"
.br
.ti -1c
.RI "\fBattribute_deprecated\fP \fBint\fP \fBqscale_type\fP"
.br
.ti -1c
.RI "\fBattribute_deprecated\fP \fBuint8_t\fP * \fBmbskip_table\fP"
.br
.ti -1c
.RI "\fBattribute_deprecated\fP \fBint16_t\fP(*[2] \fBmotion_val\fP )[2]"
.br
.ti -1c
.RI "\fBattribute_deprecated\fP \fBuint32_t\fP * \fBmb_type\fP"
.br
.ti -1c
.RI "\fBattribute_deprecated\fP short * \fBdct_coeff\fP"
.br
.ti -1c
.RI "\fBattribute_deprecated\fP \fBint8_t\fP * \fBref_index\fP [2]"
.br
.ti -1c
.RI "\fBvoid\fP * \fBopaque\fP"
.br
.ti -1c
.RI "\fBuint64_t\fP \fBerror\fP [\fBAV_NUM_DATA_POINTERS\fP]"
.br
.ti -1c
.RI "\fBattribute_deprecated\fP \fBint\fP \fBtype\fP"
.br
.ti -1c
.RI "\fBint\fP \fBrepeat_pict\fP"
.br
.ti -1c
.RI "\fBint\fP \fBinterlaced_frame\fP"
.br
.ti -1c
.RI "\fBint\fP \fBtop_field_first\fP"
.br
.ti -1c
.RI "\fBint\fP \fBpalette_has_changed\fP"
.br
.ti -1c
.RI "\fBattribute_deprecated\fP \fBint\fP \fBbuffer_hints\fP"
.br
.ti -1c
.RI "\fBattribute_deprecated\fP struct \fBAVPanScan\fP * \fBpan_scan\fP"
.br
.ti -1c
.RI "\fBint64_t\fP \fBreordered_opaque\fP"
.br
.ti -1c
.RI "\fBattribute_deprecated\fP \fBvoid\fP * \fBhwaccel_picture_private\fP"
.br
.ti -1c
.RI "\fBattribute_deprecated\fP struct \fBAVCodecContext\fP * \fBowner\fP"
.br
.ti -1c
.RI "\fBattribute_deprecated\fP \fBvoid\fP * \fBthread_opaque\fP"
.br
.ti -1c
.RI "\fBattribute_deprecated\fP \fBuint8_t\fP \fBmotion_subsample_log2\fP"
.br
.ti -1c
.RI "\fBint\fP \fBsample_rate\fP"
.br
.ti -1c
.RI "\fBuint64_t\fP \fBchannel_layout\fP"
.br
.ti -1c
.RI "\fBAVBufferRef\fP * \fBbuf\fP [\fBAV_NUM_DATA_POINTERS\fP]"
.br
.ti -1c
.RI "\fBAVBufferRef\fP ** \fBextended_buf\fP"
.br
.ti -1c
.RI "\fBint\fP \fBnb_extended_buf\fP"
.br
.ti -1c
.RI "\fBAVFrameSideData\fP ** \fBside_data\fP"
.br
.ti -1c
.RI "\fBint\fP \fBnb_side_data\fP"
.br
.ti -1c
.RI "\fBint\fP \fBflags\fP"
.br
.ti -1c
.RI "\fBint64_t\fP \fBbest_effort_timestamp\fP"
.br
.ti -1c
.RI "\fBint64_t\fP \fBpkt_pos\fP"
.br
.ti -1c
.RI "\fBint64_t\fP \fBpkt_duration\fP"
.br
.ti -1c
.RI "\fBAVDictionary\fP * \fBmetadata\fP"
.br
.ti -1c
.RI "\fBint\fP \fBdecode_error_flags\fP"
.br
.ti -1c
.RI "\fBint\fP \fBchannels\fP"
.br
.ti -1c
.RI "\fBint\fP \fBpkt_size\fP"
.br
.ti -1c
.RI "enum \fBAVColorSpace\fP \fBcolorspace\fP"
.br
.ti -1c
.RI "enum \fBAVColorRange\fP \fBcolor_range\fP"
.br
.ti -1c
.RI "\fBAVBufferRef\fP * \fBqp_table_buf\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
This structure describes decoded (raw) audio or video data\&.
.PP
\fBAVFrame\fP must be allocated using \fBav_frame_alloc()\fP\&. Note that this only allocates the \fBAVFrame\fP itself, the buffers for the data must be managed through other means (see below)\&. \fBAVFrame\fP must be freed with \fBav_frame_free()\fP\&.
.PP
\fBAVFrame\fP is typically allocated once and then reused multiple times to hold different data (e\&.g\&. a single \fBAVFrame\fP to hold frames received from a decoder)\&. In such a case, \fBav_frame_unref()\fP will free any references held by the frame and reset it to its original clean state before it is reused again\&.
.PP
The data described by an \fBAVFrame\fP is usually reference counted through the AVBuffer API\&. The underlying buffer references are stored in \fBAVFrame\&.buf\fP / \fBAVFrame\&.extended_buf\fP\&. An \fBAVFrame\fP is considered to be reference counted if at least one reference is set, i\&.e\&. if \fBAVFrame\&.buf\fP[0] != NULL\&. In such a case, every single data plane must be contained in one of the buffers in \fBAVFrame\&.buf\fP or \fBAVFrame\&.extended_buf\fP\&. There may be a single buffer for all the data, or one separate buffer for each plane, or anything in between\&.
.PP
sizeof(AVFrame) is not a part of the public ABI, so new fields may be added to the end with a minor bump\&. Similarly fields that are marked as to be only accessed by \fBav_opt_ptr()\fP can be reordered\&. This allows 2 forks to add fields without breaking compatibility with each other\&. 
.PP
Definition at line 133 of file frame\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBattribute_deprecated\fP \fBuint8_t\fP* AVFrame::base[\fBAV_NUM_DATA_POINTERS\fP]"

.PP
Definition at line 208 of file frame\&.h\&.
.SS "\fBint64_t\fP AVFrame::best_effort_timestamp"
frame timestamp estimated using various heuristics, in stream time base Code outside libavcodec should access this field using: av_frame_get_best_effort_timestamp(frame)
.IP "\(bu" 2
encoding: unused
.IP "\(bu" 2
decoding: set by libavcodec, read by user\&. 
.PP

.PP
Definition at line 453 of file frame\&.h\&.
.SS "\fBAVBufferRef\fP* AVFrame::buf[\fBAV_NUM_DATA_POINTERS\fP]"
AVBuffer references backing the data for this frame\&. If all elements of this array are NULL, then this frame is not reference counted\&.
.PP
There may be at most one AVBuffer per data plane, so for video this array always contains all the references\&. For planar audio with more than AV_NUM_DATA_POINTERS channels, there may be more buffers than can fit in this array\&. Then the extra \fBAVBufferRef\fP pointers are stored in the extended_buf array\&. 
.PP
Definition at line 403 of file frame\&.h\&.
.SS "\fBattribute_deprecated\fP \fBint\fP AVFrame::buffer_hints"

.PP
Definition at line 344 of file frame\&.h\&.
.SS "\fBuint64_t\fP AVFrame::channel_layout"
Channel layout of the audio data\&. 
.PP
Definition at line 391 of file frame\&.h\&.
.SS "\fBint\fP AVFrame::channels"
number of audio channels, only used for audio\&. Code outside libavcodec should access this field using: av_frame_get_channels(frame)
.IP "\(bu" 2
encoding: unused
.IP "\(bu" 2
decoding: Read by user\&. 
.PP

.PP
Definition at line 503 of file frame\&.h\&.
.SS "\fBint\fP AVFrame::coded_picture_number"
picture number in bitstream order 
.PP
Definition at line 236 of file frame\&.h\&.
.SS "enum \fBAVColorRange\fP AVFrame::color_range"
MPEG vs JPEG YUV range\&. It must be accessed using \fBav_frame_get_color_range()\fP and \fBav_frame_set_color_range()\fP\&.
.IP "\(bu" 2
encoding: Set by user
.IP "\(bu" 2
decoding: Set by libavcodec 
.PP

.PP
Definition at line 531 of file frame\&.h\&.
.SS "enum \fBAVColorSpace\fP AVFrame::colorspace"
YUV colorspace type\&. It must be accessed using \fBav_frame_get_colorspace()\fP and \fBav_frame_set_colorspace()\fP\&.
.IP "\(bu" 2
encoding: Set by user
.IP "\(bu" 2
decoding: Set by libavcodec 
.PP

.PP
Definition at line 522 of file frame\&.h\&.
.SS "\fBuint8_t\fP* AVFrame::data[\fBAV_NUM_DATA_POINTERS\fP]"
pointer to the picture/channel planes\&. This might be different from the first allocated byte
.PP
Some decoders access areas outside 0,0 - width,height, please see \fBavcodec_align_dimensions2()\fP\&. Some filters and swscale can read up to 16 bytes beyond the planes, if these filters are to be used, then 16 extra bytes must be allocated\&. 
.PP
Definition at line 144 of file frame\&.h\&.
.SS "\fBattribute_deprecated\fP short* AVFrame::dct_coeff"
DCT coefficients 
.PP
Definition at line 296 of file frame\&.h\&.
.SS "\fBint\fP AVFrame::decode_error_flags"
decode error flags of the frame, set to a combination of FF_DECODE_ERROR_xxx flags if the decoder produced a frame, but there were errors during the decoding\&. Code outside libavcodec should access this field using: av_frame_get_decode_error_flags(frame)
.IP "\(bu" 2
encoding: unused
.IP "\(bu" 2
decoding: set by libavcodec, read by user\&. 
.PP

.PP
Definition at line 492 of file frame\&.h\&.
.SS "\fBint\fP AVFrame::display_picture_number"
picture number in display order 
.PP
Definition at line 240 of file frame\&.h\&.
.SS "\fBuint64_t\fP AVFrame::error[\fBAV_NUM_DATA_POINTERS\fP]"
error 
.PP
Definition at line 314 of file frame\&.h\&.
.SS "\fBAVBufferRef\fP** AVFrame::extended_buf"
For planar audio which requires more than AV_NUM_DATA_POINTERS \fBAVBufferRef\fP pointers, this array will hold all the references which cannot fit into \fBAVFrame\&.buf\fP\&.
.PP
Note that this is different from \fBAVFrame\&.extended_data\fP, which always contains all the pointers\&. This array only contains the extra pointers, which cannot fit into \fBAVFrame\&.buf\fP\&.
.PP
This array is always allocated using \fBav_malloc()\fP by whoever constructs the frame\&. It is freed in \fBav_frame_unref()\fP\&. 
.PP
Definition at line 417 of file frame\&.h\&.
.SS "\fBuint8_t\fP** AVFrame::extended_data"
pointers to the data planes/channels\&.
.PP
For video, this should simply point to data[]\&.
.PP
For planar audio, each channel has a separate data pointer, and linesize[0] contains the size of each channel buffer\&. For packed audio, there is just one data pointer, and linesize[0] contains the total size of the buffer for all channels\&.
.PP
Note: Both data and extended_data should always be set in a valid frame, but for planar audio with more channels that can fit in data, extended_data must be used in order to access all channels\&. 
.PP
Definition at line 177 of file frame\&.h\&.
.SS "\fBint\fP AVFrame::flags"
Frame flags, a combination of \fBAV_FRAME_FLAGS\fP 
.PP
Definition at line 444 of file frame\&.h\&.
.SS "\fBint\fP AVFrame::format"
format of the frame, -1 if unknown or unset Values correspond to enum AVPixelFormat for video frames, enum AVSampleFormat for audio) 
.PP
Definition at line 194 of file frame\&.h\&.
.SS "\fBint\fP AVFrame::height"

.PP
Definition at line 182 of file frame\&.h\&.
.SS "\fBattribute_deprecated\fP \fBvoid\fP* AVFrame::hwaccel_picture_private"

.PP
\fBDeprecated\fP
.RS 4
this field is unused 
.RE
.PP

.PP
Definition at line 368 of file frame\&.h\&.
.SS "\fBint\fP AVFrame::interlaced_frame"
The content of the picture is interlaced\&. 
.PP
Definition at line 330 of file frame\&.h\&.
.SS "\fBint\fP AVFrame::key_frame"
1 -> keyframe, 0-> not 
.PP
Definition at line 199 of file frame\&.h\&.
.SS "\fBint\fP AVFrame::linesize[\fBAV_NUM_DATA_POINTERS\fP]"
For video, size in bytes of each picture line\&. For audio, size in bytes of each plane\&.
.PP
For audio, only linesize[0] may be set\&. For planar audio, each channel plane must be the same size\&.
.PP
For video the linesizes should be multiplies of the CPUs alignment preference, this is 16 or 32 for modern desktop CPUs\&. Some code requires such alignment other code can be slower without correct alignment, for yet other it makes no difference\&.
.PP
\fBNote:\fP
.RS 4
The linesize may be larger than the size of usable data -- there may be extra padding present for performance reasons\&. 
.RE
.PP

.PP
Definition at line 161 of file frame\&.h\&.
.SS "\fBattribute_deprecated\fP \fBuint32_t\fP* AVFrame::mb_type"
macroblock type table mb_type_base + mb_width + 2 
.PP
Definition at line 290 of file frame\&.h\&.
.SS "\fBattribute_deprecated\fP \fBuint8_t\fP* AVFrame::mbskip_table"
mbskip_table[mb]>=1 if MB didn't change stride= mb_width = (width+15)>>4 
.PP
Definition at line 270 of file frame\&.h\&.
.SS "\fBAVDictionary\fP* AVFrame::metadata"
metadata\&. Code outside libavcodec should access this field using: av_frame_get_metadata(frame)
.IP "\(bu" 2
encoding: Set by user\&.
.IP "\(bu" 2
decoding: Set by libavcodec\&. 
.PP

.PP
Definition at line 481 of file frame\&.h\&.
.SS "\fBattribute_deprecated\fP \fBuint8_t\fP AVFrame::motion_subsample_log2"
log2 of the size of the block which a single vector in motion_val represents: (4->16x16, 3->8x8, 2-> 4x4, 1-> 2x2) 
.PP
Definition at line 380 of file frame\&.h\&.
.SS "\fBattribute_deprecated\fP \fBint16_t\fP(*[2] AVFrame::motion_val)[2]"
motion vector table 
.PP
.nf
example:
int mv_sample_log2= 4 - motion_subsample_log2;
int mb_width= (width+15)>>4;
int mv_stride= (mb_width << mv_sample_log2) + 1;
motion_val[direction][x + y*mv_stride][0->mv_x, 1->mv_y];

.fi
.PP
 
.PP
Definition at line 283 of file frame\&.h\&.
.SS "\fBint\fP AVFrame::nb_extended_buf"
Number of elements in extended_buf\&. 
.PP
Definition at line 421 of file frame\&.h\&.
.SS "\fBint\fP AVFrame::nb_samples"
number of audio samples (per channel) described by this frame 
.PP
Definition at line 187 of file frame\&.h\&.
.SS "\fBint\fP AVFrame::nb_side_data"

.PP
Definition at line 424 of file frame\&.h\&.
.SS "\fBvoid\fP* AVFrame::opaque"
for some private data of the user 
.PP
Definition at line 309 of file frame\&.h\&.
.SS "\fBattribute_deprecated\fP struct \fBAVCodecContext\fP* AVFrame::owner"

.PP
Definition at line 371 of file frame\&.h\&.
.SS "\fBint\fP AVFrame::palette_has_changed"
Tell user application that palette has changed from previous frame\&. 
.PP
Definition at line 340 of file frame\&.h\&.
.SS "\fBattribute_deprecated\fP struct \fBAVPanScan\fP* AVFrame::pan_scan"
Pan scan\&. 
.PP
Definition at line 350 of file frame\&.h\&.
.SS "enum \fBAVPictureType\fP AVFrame::pict_type"
Picture type of the frame\&. 
.PP
Definition at line 204 of file frame\&.h\&.
.SS "\fBint64_t\fP AVFrame::pkt_dts"
DTS copied from the \fBAVPacket\fP that triggered returning this frame\&. (if frame threading isnt used) This is also the Presentation time of this \fBAVFrame\fP calculated from only \fBAVPacket\&.dts\fP values without pts values\&. 
.PP
Definition at line 231 of file frame\&.h\&.
.SS "\fBint64_t\fP AVFrame::pkt_duration"
duration of the corresponding packet, expressed in AVStream->time_base units, 0 if unknown\&. Code outside libavcodec should access this field using: av_frame_get_pkt_duration(frame)
.IP "\(bu" 2
encoding: unused
.IP "\(bu" 2
decoding: Read by user\&. 
.PP

.PP
Definition at line 472 of file frame\&.h\&.
.SS "\fBint64_t\fP AVFrame::pkt_pos"
reordered pos from the last \fBAVPacket\fP that has been input into the decoder Code outside libavcodec should access this field using: av_frame_get_pkt_pos(frame)
.IP "\(bu" 2
encoding: unused
.IP "\(bu" 2
decoding: Read by user\&. 
.PP

.PP
Definition at line 462 of file frame\&.h\&.
.SS "\fBint64_t\fP AVFrame::pkt_pts"
PTS copied from the \fBAVPacket\fP that was decoded to produce this frame\&. 
.PP
Definition at line 224 of file frame\&.h\&.
.SS "\fBint\fP AVFrame::pkt_size"
size of the corresponding packet containing the compressed frame\&. It must be accessed using \fBav_frame_get_pkt_size()\fP and \fBav_frame_set_pkt_size()\fP\&. It is set to a negative value if unknown\&.
.IP "\(bu" 2
encoding: unused
.IP "\(bu" 2
decoding: set by libavcodec, read by user\&. 
.PP

.PP
Definition at line 513 of file frame\&.h\&.
.SS "\fBint64_t\fP AVFrame::pts"
Presentation timestamp in time_base units (time when frame should be shown to user)\&. 
.PP
Definition at line 219 of file frame\&.h\&.
.SS "\fBAVBufferRef\fP* AVFrame::qp_table_buf"
Not to be accessed directly from outside libavutil 
.PP
Definition at line 537 of file frame\&.h\&.
.SS "\fBattribute_deprecated\fP \fBint8_t\fP* AVFrame::qscale_table"
QP table 
.PP
Definition at line 255 of file frame\&.h\&.
.SS "\fBattribute_deprecated\fP \fBint\fP AVFrame::qscale_type"

.PP
Definition at line 263 of file frame\&.h\&.
.SS "\fBattribute_deprecated\fP \fBint\fP AVFrame::qstride"
QP store stride 
.PP
Definition at line 260 of file frame\&.h\&.
.SS "\fBint\fP AVFrame::quality"
quality (between 1 (good) and FF_LAMBDA_MAX (bad)) 
.PP
Definition at line 245 of file frame\&.h\&.
.SS "\fBattribute_deprecated\fP \fBint8_t\fP* AVFrame::ref_index[2]"
motion reference frame index the order in which these are stored can depend on the codec\&. 
.PP
Definition at line 303 of file frame\&.h\&.
.SS "\fBattribute_deprecated\fP \fBint\fP AVFrame::reference"

.PP
Definition at line 249 of file frame\&.h\&.
.SS "\fBint64_t\fP AVFrame::reordered_opaque"
reordered opaque 64bit (generally an integer or a double precision float PTS but can be anything)\&. The user sets \fBAVCodecContext\&.reordered_opaque\fP to represent the input at that time, the decoder reorders values as needed and sets \fBAVFrame\&.reordered_opaque\fP to exactly one of the values provided by the user through \fBAVCodecContext\&.reordered_opaque\fP 
.PP
\fBDeprecated\fP
.RS 4
in favor of pkt_pts 
.RE
.PP

.PP
Definition at line 362 of file frame\&.h\&.
.SS "\fBint\fP AVFrame::repeat_pict"
When decoding, this signals how much the picture must be delayed\&. extra_delay = repeat_pict / (2*fps) 
.PP
Definition at line 325 of file frame\&.h\&.
.SS "\fBAVRational\fP AVFrame::sample_aspect_ratio"
\fBSample\fP aspect ratio for the video frame, 0/1 if unknown/unspecified\&. 
.PP
Definition at line 214 of file frame\&.h\&.
.SS "\fBint\fP AVFrame::sample_rate"
\fBSample\fP rate of the audio data\&. 
.PP
Definition at line 386 of file frame\&.h\&.
.SS "\fBAVFrameSideData\fP** AVFrame::side_data"

.PP
Definition at line 423 of file frame\&.h\&.
.SS "\fBattribute_deprecated\fP \fBvoid\fP* AVFrame::thread_opaque"

.PP
Definition at line 373 of file frame\&.h\&.
.SS "\fBint\fP AVFrame::top_field_first"
If the content is interlaced, is top field displayed first\&. 
.PP
Definition at line 335 of file frame\&.h\&.
.SS "\fBattribute_deprecated\fP \fBint\fP AVFrame::type"

.PP
Definition at line 318 of file frame\&.h\&.
.SS "\fBint\fP AVFrame::width"
width and height of the video frame 
.PP
Definition at line 182 of file frame\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Audacity from the source code\&.
