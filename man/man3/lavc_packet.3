.TH "lavc_packet" 3 "Thu Apr 28 2016" "Audacity" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lavc_packet \- AVPacket
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBAVPacket\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBAV_PKT_FLAG_KEY\fP   0x0001"
.br
.RI "\fIThe packet contains a keyframe\&. \fP"
.ti -1c
.RI "#define \fBAV_PKT_FLAG_CORRUPT\fP   0x0002"
.br
.RI "\fIThe packet content is corrupted\&. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBAVPacket\fP \fBAVPacket\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBAVPacketSideDataType\fP { \fBAV_PKT_DATA_PALETTE\fP, \fBAV_PKT_DATA_NEW_EXTRADATA\fP, \fBAV_PKT_DATA_PARAM_CHANGE\fP, \fBAV_PKT_DATA_H263_MB_INFO\fP, \fBAV_PKT_DATA_SKIP_SAMPLES\fP =70, \fBAV_PKT_DATA_JP_DUALMONO\fP, \fBAV_PKT_DATA_STRINGS_METADATA\fP, \fBAV_PKT_DATA_SUBTITLE_POSITION\fP, \fBAV_PKT_DATA_MATROSKA_BLOCKADDITIONAL\fP, \fBAV_PKT_DATA_WEBVTT_IDENTIFIER\fP, \fBAV_PKT_DATA_WEBVTT_SETTINGS\fP, \fBAV_PKT_DATA_METADATA_UPDATE\fP }"
.br
.ti -1c
.RI "enum \fBAVSideDataParamChangeFlags\fP { \fBAV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT\fP = 0x0001, \fBAV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT\fP = 0x0002, \fBAV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE\fP = 0x0004, \fBAV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS\fP = 0x0008 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBattribute_deprecated\fP \fBvoid\fP \fBav_destruct_packet\fP (\fBAVPacket\fP *pkt)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_init_packet\fP (\fBAVPacket\fP *pkt)"
.br
.ti -1c
.RI "\fBint\fP \fBav_new_packet\fP (\fBAVPacket\fP *pkt, \fBint\fP \fBsize\fP)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_shrink_packet\fP (\fBAVPacket\fP *pkt, \fBint\fP \fBsize\fP)"
.br
.ti -1c
.RI "\fBint\fP \fBav_grow_packet\fP (\fBAVPacket\fP *pkt, \fBint\fP grow_by)"
.br
.ti -1c
.RI "\fBint\fP \fBav_packet_from_data\fP (\fBAVPacket\fP *pkt, \fBuint8_t\fP *\fBdata\fP, \fBint\fP \fBsize\fP)"
.br
.ti -1c
.RI "\fBint\fP \fBav_dup_packet\fP (\fBAVPacket\fP *pkt)"
.br
.ti -1c
.RI "\fBint\fP \fBav_copy_packet\fP (\fBAVPacket\fP *dst, \fBAVPacket\fP *src)"
.br
.ti -1c
.RI "\fBint\fP \fBav_copy_packet_side_data\fP (\fBAVPacket\fP *dst, \fBAVPacket\fP *src)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_free_packet\fP (\fBAVPacket\fP *pkt)"
.br
.ti -1c
.RI "\fBuint8_t\fP * \fBav_packet_new_side_data\fP (\fBAVPacket\fP *pkt, enum \fBAVPacketSideDataType\fP type, \fBint\fP \fBsize\fP)"
.br
.ti -1c
.RI "\fBint\fP \fBav_packet_shrink_side_data\fP (\fBAVPacket\fP *pkt, enum \fBAVPacketSideDataType\fP type, \fBint\fP \fBsize\fP)"
.br
.ti -1c
.RI "\fBuint8_t\fP * \fBav_packet_get_side_data\fP (\fBAVPacket\fP *pkt, enum \fBAVPacketSideDataType\fP type, \fBint\fP *\fBsize\fP)"
.br
.ti -1c
.RI "\fBint\fP \fBav_packet_merge_side_data\fP (\fBAVPacket\fP *pkt)"
.br
.ti -1c
.RI "\fBint\fP \fBav_packet_split_side_data\fP (\fBAVPacket\fP *pkt)"
.br
.ti -1c
.RI "\fBuint8_t\fP * \fBav_packet_pack_dictionary\fP (\fBAVDictionary\fP *dict, \fBint\fP *\fBsize\fP)"
.br
.ti -1c
.RI "\fBint\fP \fBav_packet_unpack_dictionary\fP (\fBconst\fP \fBuint8_t\fP *\fBdata\fP, \fBint\fP \fBsize\fP, \fBAVDictionary\fP **dict)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_packet_free_side_data\fP (\fBAVPacket\fP *pkt)"
.br
.ti -1c
.RI "\fBint\fP \fBav_packet_ref\fP (\fBAVPacket\fP *dst, \fBAVPacket\fP *src)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_packet_unref\fP (\fBAVPacket\fP *pkt)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_packet_move_ref\fP (\fBAVPacket\fP *dst, \fBAVPacket\fP *src)"
.br
.ti -1c
.RI "\fBint\fP \fBav_packet_copy_props\fP (\fBAVPacket\fP *dst, \fBconst\fP \fBAVPacket\fP *src)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Types and functions for working with \fBAVPacket\fP\&. 
.SH "Macro Definition Documentation"
.PP 
.SS "#define AV_PKT_FLAG_CORRUPT   0x0002"

.PP
The packet content is corrupted\&. 
.PP
Definition at line 1166 of file avcodec\&.h\&.
.SS "#define AV_PKT_FLAG_KEY   0x0001"

.PP
The packet contains a keyframe\&. 
.PP
Definition at line 1165 of file avcodec\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBAVPacket\fP  \fBAVPacket\fP"
This structure stores compressed data\&. It is typically exported by demuxers and then passed as input to decoders, or received as output from encoders and then passed to muxers\&.
.PP
For video, it should typically contain one compressed frame\&. For audio it may contain several compressed frames\&.
.PP
\fBAVPacket\fP is one of the few structs in FFmpeg, whose size is a part of public ABI\&. Thus it may be allocated on stack and no new fields can be added to it without libavcodec and libavformat major bump\&.
.PP
The semantics of data ownership depends on the buf or destruct (deprecated) fields\&. If either is set, the packet data is dynamically allocated and is valid indefinitely until \fBav_free_packet()\fP is called (which in turn calls \fBav_buffer_unref()\fP/the destruct callback to free the data)\&. If neither is set, the packet data is typically backed by some static buffer somewhere and is only valid for a limited time (e\&.g\&. until the next read call when demuxing)\&.
.PP
The side data is always allocated with \fBav_malloc()\fP and is freed in \fBav_free_packet()\fP\&. 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBAVPacketSideDataType\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIAV_PKT_DATA_PALETTE \fP\fP
.TP
\fB\fIAV_PKT_DATA_NEW_EXTRADATA \fP\fP
.TP
\fB\fIAV_PKT_DATA_PARAM_CHANGE \fP\fP
An AV_PKT_DATA_PARAM_CHANGE side data packet is laid out as follows: 
.PP
.nf
1 u32le param_flags
2 if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT)
3     s32le channel_count
4 if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT)
5     u64le channel_layout
6 if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE)
7     s32le sample_rate
8 if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS)
9     s32le width
10     s32le height

.fi
.PP
 
.TP
\fB\fIAV_PKT_DATA_H263_MB_INFO \fP\fP
An AV_PKT_DATA_H263_MB_INFO side data packet contains a number of structures with info about macroblocks relevant to splitting the packet into smaller packets on macroblock edges (e\&.g\&. as for RFC 2190)\&. That is, it does not necessarily contain info about all macroblocks, as long as the distance between macroblocks in the info is smaller than the target payload size\&. Each MB info structure is 12 bytes, and is laid out as follows: 
.PP
.nf
1 u32le bit offset from the start of the packet
2 u8    current quantizer at the start of the macroblock
3 u8    GOB number
4 u16le macroblock address within the GOB
5 u8    horizontal MV predictor
6 u8    vertical MV predictor
7 u8    horizontal MV predictor for block number 3
8 u8    vertical MV predictor for block number 3

.fi
.PP
 
.TP
\fB\fIAV_PKT_DATA_SKIP_SAMPLES \fP\fP
Recommmends skipping the specified number of samples 
.PP
.nf
1 u32le number of samples to skip from start of this packet
2 u32le number of samples to skip from end of this packet
3 u8    reason for start skip
4 u8    reason for end   skip (0=padding silence, 1=convergence)

.fi
.PP
 
.TP
\fB\fIAV_PKT_DATA_JP_DUALMONO \fP\fP
An AV_PKT_DATA_JP_DUALMONO side data packet indicates that the packet may contain 'dual mono' audio specific to Japanese DTV and if it is true, recommends only the selected channel to be used\&. 
.PP
.nf
1 u8    selected channels (0=mail/left, 1=sub/right, 2=both)

.fi
.PP
 
.TP
\fB\fIAV_PKT_DATA_STRINGS_METADATA \fP\fP
A list of zero terminated key/value strings\&. There is no end marker for the list, so it is required to rely on the side data size to stop\&. 
.TP
\fB\fIAV_PKT_DATA_SUBTITLE_POSITION \fP\fP
Subtitle event position 
.PP
.nf
1 u32le x1
2 u32le y1
3 u32le x2
4 u32le y2

.fi
.PP
 
.TP
\fB\fIAV_PKT_DATA_MATROSKA_BLOCKADDITIONAL \fP\fP
Data found in BlockAdditional element of matroska container\&. There is no end marker for the data, so it is required to rely on the side data size to recognize the end\&. 8 byte id (as found in BlockAddId) followed by data\&. 
.TP
\fB\fIAV_PKT_DATA_WEBVTT_IDENTIFIER \fP\fP
The optional first identifier line of a WebVTT cue\&. 
.TP
\fB\fIAV_PKT_DATA_WEBVTT_SETTINGS \fP\fP
The optional settings (rendering instructions) that immediately follow the timestamp specifier of a WebVTT cue\&. 
.TP
\fB\fIAV_PKT_DATA_METADATA_UPDATE \fP\fP
A list of zero terminated key/value strings\&. There is no end marker for the list, so it is required to rely on the side data size to stop\&. This side data includes updated metadata which appeared in the stream\&. 
.PP
Definition at line 963 of file avcodec\&.h\&.
.SS "enum \fBAVSideDataParamChangeFlags\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIAV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT \fP\fP
.TP
\fB\fIAV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT \fP\fP
.TP
\fB\fIAV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE \fP\fP
.TP
\fB\fIAV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS \fP\fP
.PP
Definition at line 1168 of file avcodec\&.h\&.
.SH "Function Documentation"
.PP 
.SS "\fBint\fP av_copy_packet (\fBAVPacket\fP * dst, \fBAVPacket\fP * src)"
Copy packet, including contents
.PP
\fBReturns:\fP
.RS 4
0 on success, negative AVERROR on fail 
.RE
.PP

.SS "\fBint\fP av_copy_packet_side_data (\fBAVPacket\fP * dst, \fBAVPacket\fP * src)"
Copy packet side data
.PP
\fBReturns:\fP
.RS 4
0 on success, negative AVERROR on fail 
.RE
.PP

.SS "\fBattribute_deprecated\fP \fBvoid\fP av_destruct_packet (\fBAVPacket\fP * pkt)"
Default packet destructor\&. 
.PP
\fBDeprecated\fP
.RS 4
use the AVBuffer API instead 
.RE
.PP

.SS "\fBint\fP av_dup_packet (\fBAVPacket\fP * pkt)"

.PP
\fBWarning:\fP
.RS 4
This is a hack - the packet memory allocation stuff is broken\&. The packet is allocated if it was not really allocated\&. 
.RE
.PP

.SS "\fBvoid\fP av_free_packet (\fBAVPacket\fP * pkt)"
Free a packet\&.
.PP
\fBParameters:\fP
.RS 4
\fIpkt\fP packet to free 
.RE
.PP

.SS "\fBint\fP av_grow_packet (\fBAVPacket\fP * pkt, \fBint\fP grow_by)"
Increase packet size, correctly zeroing padding
.PP
\fBParameters:\fP
.RS 4
\fIpkt\fP packet 
.br
\fIgrow_by\fP number of bytes by which to increase the size of the packet 
.RE
.PP

.SS "\fBvoid\fP av_init_packet (\fBAVPacket\fP * pkt)"
Initialize optional fields of a packet with default values\&.
.PP
Note, this does not touch the data and size members, which have to be initialized separately\&.
.PP
\fBParameters:\fP
.RS 4
\fIpkt\fP packet 
.RE
.PP

.SS "\fBint\fP av_new_packet (\fBAVPacket\fP * pkt, \fBint\fP size)"
Allocate the payload of a packet and initialize its fields with default values\&.
.PP
\fBParameters:\fP
.RS 4
\fIpkt\fP packet 
.br
\fIsize\fP wanted payload size 
.RE
.PP
\fBReturns:\fP
.RS 4
0 if OK, AVERROR_xxx otherwise 
.RE
.PP

.SS "\fBint\fP av_packet_copy_props (\fBAVPacket\fP * dst, \fBconst\fP \fBAVPacket\fP * src)"
Copy only 'properties' fields from src to dst\&.
.PP
Properties for the purpose of this function are all the fields beside those related to the packet data (buf, data, size)
.PP
\fBParameters:\fP
.RS 4
\fIdst\fP Destination packet 
.br
\fIsrc\fP Source packet
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success AVERROR on failure\&. 
.RE
.PP

.SS "\fBvoid\fP av_packet_free_side_data (\fBAVPacket\fP * pkt)"
Convenience function to free all the side data stored\&. All the other fields stay untouched\&.
.PP
\fBParameters:\fP
.RS 4
\fIpkt\fP packet 
.RE
.PP

.SS "\fBint\fP av_packet_from_data (\fBAVPacket\fP * pkt, \fBuint8_t\fP * data, \fBint\fP size)"
Initialize a reference-counted packet from \fBav_malloc()\fPed data\&.
.PP
\fBParameters:\fP
.RS 4
\fIpkt\fP packet to be initialized\&. This function will set the data, size, buf and destruct fields, all others are left untouched\&. 
.br
\fIdata\fP Data allocated by \fBav_malloc()\fP to be used as packet data\&. If this function returns successfully, the data is owned by the underlying AVBuffer\&. The caller may not access the data through other means\&. 
.br
\fIsize\fP size of data in bytes, without the padding\&. I\&.e\&. the full buffer size is assumed to be size + FF_INPUT_BUFFER_PADDING_SIZE\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, a negative AVERROR on error 
.RE
.PP

.SS "\fBuint8_t\fP* av_packet_get_side_data (\fBAVPacket\fP * pkt, enum \fBAVPacketSideDataType\fP type, \fBint\fP * size)"
Get side information from packet\&.
.PP
\fBParameters:\fP
.RS 4
\fIpkt\fP packet 
.br
\fItype\fP desired side information type 
.br
\fIsize\fP pointer for side information size to store (optional) 
.RE
.PP
\fBReturns:\fP
.RS 4
pointer to data if present or NULL otherwise 
.RE
.PP

.SS "\fBint\fP av_packet_merge_side_data (\fBAVPacket\fP * pkt)"

.SS "\fBvoid\fP av_packet_move_ref (\fBAVPacket\fP * dst, \fBAVPacket\fP * src)"
Move every field in src to dst and reset src\&.
.PP
\fBSee also:\fP
.RS 4
\fBav_packet_unref\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIsrc\fP Source packet, will be reset 
.br
\fIdst\fP Destination packet 
.RE
.PP

.SS "\fBuint8_t\fP* av_packet_new_side_data (\fBAVPacket\fP * pkt, enum \fBAVPacketSideDataType\fP type, \fBint\fP size)"
Allocate new information of a packet\&.
.PP
\fBParameters:\fP
.RS 4
\fIpkt\fP packet 
.br
\fItype\fP side information type 
.br
\fIsize\fP side information size 
.RE
.PP
\fBReturns:\fP
.RS 4
pointer to fresh allocated data or NULL otherwise 
.RE
.PP

.SS "\fBuint8_t\fP* av_packet_pack_dictionary (\fBAVDictionary\fP * dict, \fBint\fP * size)"
Pack a dictionary for use in side_data\&.
.PP
\fBParameters:\fP
.RS 4
\fIdict\fP The dictionary to pack\&. 
.br
\fIsize\fP pointer to store the size of the returned data 
.RE
.PP
\fBReturns:\fP
.RS 4
pointer to data if successful, NULL otherwise 
.RE
.PP

.SS "\fBint\fP av_packet_ref (\fBAVPacket\fP * dst, \fBAVPacket\fP * src)"
Setup a new reference to the data described by a given packet
.PP
If src is reference-counted, setup dst as a new reference to the buffer in src\&. Otherwise allocate a new buffer in dst and copy the data from src into it\&.
.PP
All the other fields are copied from src\&.
.PP
\fBSee also:\fP
.RS 4
\fBav_packet_unref\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIdst\fP Destination packet 
.br
\fIsrc\fP Source packet
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, a negative AVERROR on error\&. 
.RE
.PP

.SS "\fBint\fP av_packet_shrink_side_data (\fBAVPacket\fP * pkt, enum \fBAVPacketSideDataType\fP type, \fBint\fP size)"
Shrink the already allocated side data buffer
.PP
\fBParameters:\fP
.RS 4
\fIpkt\fP packet 
.br
\fItype\fP side information type 
.br
\fIsize\fP new side information size 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, < 0 on failure 
.RE
.PP

.SS "\fBint\fP av_packet_split_side_data (\fBAVPacket\fP * pkt)"

.SS "\fBint\fP av_packet_unpack_dictionary (\fBconst\fP \fBuint8_t\fP * data, \fBint\fP size, \fBAVDictionary\fP ** dict)"
Unpack a dictionary from side_data\&.
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP data from side_data 
.br
\fIsize\fP size of the data 
.br
\fIdict\fP the metadata storage dictionary 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, < 0 on failure 
.RE
.PP

.SS "\fBvoid\fP av_packet_unref (\fBAVPacket\fP * pkt)"
Wipe the packet\&.
.PP
Unreference the buffer referenced by the packet and reset the remaining packet fields to their default values\&.
.PP
\fBParameters:\fP
.RS 4
\fIpkt\fP The packet to be unreferenced\&. 
.RE
.PP

.SS "\fBvoid\fP av_shrink_packet (\fBAVPacket\fP * pkt, \fBint\fP size)"
Reduce packet size, correctly zeroing padding
.PP
\fBParameters:\fP
.RS 4
\fIpkt\fP packet 
.br
\fIsize\fP new size 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Audacity from the source code\&.
