.TH "lavu_math" 3 "Thu Apr 28 2016" "Audacity" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lavu_math \- Maths
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBAVRational\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBAVRational\fP \fBAVRational\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBAVRounding\fP { \fBAV_ROUND_ZERO\fP = 0, \fBAV_ROUND_INF\fP = 1, \fBAV_ROUND_DOWN\fP = 2, \fBAV_ROUND_UP\fP = 3, \fBAV_ROUND_NEAR_INF\fP = 5, \fBAV_ROUND_PASS_MINMAX\fP = 8192 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBint64_t\fP \fBav_const\fP \fBav_gcd\fP (\fBint64_t\fP \fBa\fP, \fBint64_t\fP \fBb\fP)"
.br
.ti -1c
.RI "\fBint64_t\fP \fBav_rescale\fP (\fBint64_t\fP \fBa\fP, \fBint64_t\fP \fBb\fP, \fBint64_t\fP \fBc\fP) \fBav_const\fP"
.br
.ti -1c
.RI "\fBint64_t\fP \fBav_rescale_rnd\fP (\fBint64_t\fP \fBa\fP, \fBint64_t\fP \fBb\fP, \fBint64_t\fP \fBc\fP, enum \fBAVRounding\fP) \fBav_const\fP"
.br
.ti -1c
.RI "\fBint64_t\fP \fBav_rescale_q\fP (\fBint64_t\fP \fBa\fP, \fBAVRational\fP bq, \fBAVRational\fP cq) \fBav_const\fP"
.br
.ti -1c
.RI "\fBint64_t\fP \fBav_rescale_q_rnd\fP (\fBint64_t\fP \fBa\fP, \fBAVRational\fP bq, \fBAVRational\fP cq, enum \fBAVRounding\fP) \fBav_const\fP"
.br
.ti -1c
.RI "\fBint\fP \fBav_compare_ts\fP (\fBint64_t\fP ts_a, \fBAVRational\fP tb_a, \fBint64_t\fP ts_b, \fBAVRational\fP tb_b)"
.br
.ti -1c
.RI "\fBint64_t\fP \fBav_compare_mod\fP (\fBuint64_t\fP \fBa\fP, \fBuint64_t\fP \fBb\fP, \fBuint64_t\fP mod)"
.br
.ti -1c
.RI "\fBint64_t\fP \fBav_rescale_delta\fP (\fBAVRational\fP in_tb, \fBint64_t\fP in_ts, \fBAVRational\fP fs_tb, \fBint\fP duration, \fBint64_t\fP *\fBlast\fP, \fBAVRational\fP out_tb)"
.br
.ti -1c
.RI "\fBint64_t\fP \fBav_add_stable\fP (\fBAVRational\fP ts_tb, \fBint64_t\fP ts, \fBAVRational\fP inc_tb, \fBint64_t\fP inc)"
.br
.ti -1c
.RI "\fBint\fP \fBav_reduce\fP (\fBint\fP *dst_num, \fBint\fP *dst_den, \fBint64_t\fP num, \fBint64_t\fP den, \fBint64_t\fP \fBmax\fP)"
.br
.ti -1c
.RI "\fBAVRational\fP \fBav_mul_q\fP (\fBAVRational\fP \fBb\fP, \fBAVRational\fP \fBc\fP) \fBav_const\fP"
.br
.ti -1c
.RI "\fBAVRational\fP \fBav_div_q\fP (\fBAVRational\fP \fBb\fP, \fBAVRational\fP \fBc\fP) \fBav_const\fP"
.br
.ti -1c
.RI "\fBAVRational\fP \fBav_add_q\fP (\fBAVRational\fP \fBb\fP, \fBAVRational\fP \fBc\fP) \fBav_const\fP"
.br
.ti -1c
.RI "\fBAVRational\fP \fBav_sub_q\fP (\fBAVRational\fP \fBb\fP, \fBAVRational\fP \fBc\fP) \fBav_const\fP"
.br
.ti -1c
.RI "\fBAVRational\fP \fBav_d2q\fP (double \fBd\fP, \fBint\fP \fBmax\fP) \fBav_const\fP"
.br
.ti -1c
.RI "\fBint\fP \fBav_nearer_q\fP (\fBAVRational\fP \fBq\fP, \fBAVRational\fP q1, \fBAVRational\fP q2)"
.br
.ti -1c
.RI "\fBint\fP \fBav_find_nearest_q_idx\fP (\fBAVRational\fP \fBq\fP, \fBconst\fP \fBAVRational\fP *q_list)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBAVRational\fP  \fBAVRational\fP"
rational number numerator/denominator 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBAVRounding\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIAV_ROUND_ZERO \fP\fP
Round toward zero\&. 
.TP
\fB\fIAV_ROUND_INF \fP\fP
Round away from zero\&. 
.TP
\fB\fIAV_ROUND_DOWN \fP\fP
Round toward -infinity\&. 
.TP
\fB\fIAV_ROUND_UP \fP\fP
Round toward +infinity\&. 
.TP
\fB\fIAV_ROUND_NEAR_INF \fP\fP
Round to nearest and halfway cases away from zero\&. 
.TP
\fB\fIAV_ROUND_PASS_MINMAX \fP\fP
Flag to pass INT64_MIN/MAX through instead of rescaling, this avoids special cases for AV_NOPTS_VALUE\&. 
.PP
Definition at line 70 of file mathematics\&.h\&.
.SH "Function Documentation"
.PP 
.SS "\fBAVRational\fP av_add_q (\fBAVRational\fP b, \fBAVRational\fP c) const"
Add two rationals\&. 
.PP
\fBParameters:\fP
.RS 4
\fIb\fP first rational 
.br
\fIc\fP second rational 
.RE
.PP
\fBReturns:\fP
.RS 4
b+c 
.RE
.PP

.SS "\fBint64_t\fP av_add_stable (\fBAVRational\fP ts_tb, \fBint64_t\fP ts, \fBAVRational\fP inc_tb, \fBint64_t\fP inc)"
Add a value to a timestamp\&.
.PP
This function gurantees that when the same value is repeatly added that no accumulation of rounding errors occurs\&.
.PP
\fBParameters:\fP
.RS 4
\fIts\fP Input timestamp 
.br
\fIts_tb\fP Input timestamp timebase 
.br
\fIinc\fP value to add to ts 
.br
\fIinc_tb\fP inc timebase 
.RE
.PP

.SS "\fBint64_t\fP av_compare_mod (\fBuint64_t\fP a, \fBuint64_t\fP b, \fBuint64_t\fP mod)"
Compare 2 integers modulo mod\&. That is we compare integers a and b for which only the least significant log2(mod) bits are known\&.
.PP
\fBParameters:\fP
.RS 4
\fImod\fP must be a power of 2 
.RE
.PP
\fBReturns:\fP
.RS 4
a negative value if a is smaller than b a positive value if a is greater than b 0 if a equals b 
.RE
.PP

.SS "\fBint\fP av_compare_ts (\fBint64_t\fP ts_a, \fBAVRational\fP tb_a, \fBint64_t\fP ts_b, \fBAVRational\fP tb_b)"
Compare 2 timestamps each in its own timebases\&. The result of the function is undefined if one of the timestamps is outside the int64_t range when represented in the others timebase\&. 
.PP
\fBReturns:\fP
.RS 4
-1 if ts_a is before ts_b, 1 if ts_a is after ts_b or 0 if they represent the same position 
.RE
.PP

.SS "\fBAVRational\fP av_d2q (double d, \fBint\fP max) const"
Convert a double precision floating point number to a rational\&. inf is expressed as {1,0} or {-1,0} depending on the sign\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP double to convert 
.br
\fImax\fP the maximum allowed numerator and denominator 
.RE
.PP
\fBReturns:\fP
.RS 4
(\fBAVRational\fP) d 
.RE
.PP

.SS "\fBAVRational\fP av_div_q (\fBAVRational\fP b, \fBAVRational\fP c) const"
Divide one rational by another\&. 
.PP
\fBParameters:\fP
.RS 4
\fIb\fP first rational 
.br
\fIc\fP second rational 
.RE
.PP
\fBReturns:\fP
.RS 4
b/c 
.RE
.PP

.SS "\fBint\fP av_find_nearest_q_idx (\fBAVRational\fP q, \fBconst\fP \fBAVRational\fP * q_list)"
Find the nearest value in q_list to q\&. 
.PP
\fBParameters:\fP
.RS 4
\fIq_list\fP an array of rationals terminated by {0, 0} 
.RE
.PP
\fBReturns:\fP
.RS 4
the index of the nearest value found in the array 
.RE
.PP

.SS "\fBint64_t\fP \fBav_const\fP av_gcd (\fBint64_t\fP a, \fBint64_t\fP b)"
Return the greatest common divisor of a and b\&. If both a and b are 0 or either or both are <0 then behavior is undefined\&. 
.SS "\fBAVRational\fP av_mul_q (\fBAVRational\fP b, \fBAVRational\fP c) const"
Multiply two rationals\&. 
.PP
\fBParameters:\fP
.RS 4
\fIb\fP first rational 
.br
\fIc\fP second rational 
.RE
.PP
\fBReturns:\fP
.RS 4
b*c 
.RE
.PP

.SS "\fBint\fP av_nearer_q (\fBAVRational\fP q, \fBAVRational\fP q1, \fBAVRational\fP q2)"

.PP
\fBReturns:\fP
.RS 4
1 if q1 is nearer to q than q2, -1 if q2 is nearer than q1, 0 if they have the same distance\&. 
.RE
.PP

.SS "\fBint\fP av_reduce (\fBint\fP * dst_num, \fBint\fP * dst_den, \fBint64_t\fP num, \fBint64_t\fP den, \fBint64_t\fP max)"
Reduce a fraction\&. This is useful for framerate calculations\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdst_num\fP destination numerator 
.br
\fIdst_den\fP destination denominator 
.br
\fInum\fP source numerator 
.br
\fIden\fP source denominator 
.br
\fImax\fP the maximum allowed for dst_num & dst_den 
.RE
.PP
\fBReturns:\fP
.RS 4
1 if exact, 0 otherwise 
.RE
.PP

.SS "\fBint64_t\fP av_rescale (\fBint64_t\fP a, \fBint64_t\fP b, \fBint64_t\fP c) const"
Rescale a 64-bit integer with rounding to nearest\&. A simple a*b/c isn't possible as it can overflow\&. 
.SS "\fBint64_t\fP av_rescale_delta (\fBAVRational\fP in_tb, \fBint64_t\fP in_ts, \fBAVRational\fP fs_tb, \fBint\fP duration, \fBint64_t\fP * last, \fBAVRational\fP out_tb)"
Rescale a timestamp while preserving known durations\&.
.PP
\fBParameters:\fP
.RS 4
\fIin_ts\fP Input timestamp 
.br
\fIin_tb\fP Input timebase 
.br
\fIfs_tb\fP Duration and *last timebase 
.br
\fIduration\fP duration till the next call 
.br
\fIout_tb\fP Output timebase 
.RE
.PP

.SS "\fBint64_t\fP av_rescale_q (\fBint64_t\fP a, \fBAVRational\fP bq, \fBAVRational\fP cq) const"
Rescale a 64-bit integer by 2 rational numbers\&. 
.SS "\fBint64_t\fP av_rescale_q_rnd (\fBint64_t\fP a, \fBAVRational\fP bq, \fBAVRational\fP cq, enum AVRounding) const"
Rescale a 64-bit integer by 2 rational numbers with specified rounding\&.
.PP
\fBReturns:\fP
.RS 4
rescaled value a, or if AV_ROUND_PASS_MINMAX is set and a is INT64_MIN or INT64_MAX then a is passed through unchanged\&. 
.RE
.PP

.SS "\fBint64_t\fP av_rescale_rnd (\fBint64_t\fP a, \fBint64_t\fP b, \fBint64_t\fP c, enum AVRounding) const"
Rescale a 64-bit integer with specified rounding\&. A simple a*b/c isn't possible as it can overflow\&.
.PP
\fBReturns:\fP
.RS 4
rescaled value a, or if AV_ROUND_PASS_MINMAX is set and a is INT64_MIN or INT64_MAX then a is passed through unchanged\&. 
.RE
.PP

.SS "\fBAVRational\fP av_sub_q (\fBAVRational\fP b, \fBAVRational\fP c) const"
Subtract one rational from another\&. 
.PP
\fBParameters:\fP
.RS 4
\fIb\fP first rational 
.br
\fIc\fP second rational 
.RE
.PP
\fBReturns:\fP
.RS 4
b-c 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Audacity from the source code\&.
