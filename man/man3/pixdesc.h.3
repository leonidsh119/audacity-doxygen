.TH "C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/pixdesc.h" 3 "Thu Apr 28 2016" "Audacity" \" -*- nroff -*-
.ad l
.nh
.SH NAME
C:/_dev/OpenU/Audacity/audacity/lib-src/ffmpeg/libavutil/pixdesc.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <inttypes\&.h>\fP
.br
\fC#include 'attributes\&.h'\fP
.br
\fC#include 'pixfmt\&.h'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBAVComponentDescriptor\fP"
.br
.ti -1c
.RI "struct \fBAVPixFmtDescriptor\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBAV_PIX_FMT_FLAG_BE\fP   (1 << 0)"
.br
.ti -1c
.RI "#define \fBAV_PIX_FMT_FLAG_PAL\fP   (1 << 1)"
.br
.ti -1c
.RI "#define \fBAV_PIX_FMT_FLAG_BITSTREAM\fP   (1 << 2)"
.br
.ti -1c
.RI "#define \fBAV_PIX_FMT_FLAG_HWACCEL\fP   (1 << 3)"
.br
.ti -1c
.RI "#define \fBAV_PIX_FMT_FLAG_PLANAR\fP   (1 << 4)"
.br
.ti -1c
.RI "#define \fBAV_PIX_FMT_FLAG_RGB\fP   (1 << 5)"
.br
.ti -1c
.RI "#define \fBAV_PIX_FMT_FLAG_PSEUDOPAL\fP   (1 << 6)"
.br
.ti -1c
.RI "#define \fBAV_PIX_FMT_FLAG_ALPHA\fP   (1 << 7)"
.br
.ti -1c
.RI "#define \fBPIX_FMT_BE\fP   \fBAV_PIX_FMT_FLAG_BE\fP"
.br
.ti -1c
.RI "#define \fBPIX_FMT_PAL\fP   \fBAV_PIX_FMT_FLAG_PAL\fP"
.br
.ti -1c
.RI "#define \fBPIX_FMT_BITSTREAM\fP   \fBAV_PIX_FMT_FLAG_BITSTREAM\fP"
.br
.ti -1c
.RI "#define \fBPIX_FMT_HWACCEL\fP   \fBAV_PIX_FMT_FLAG_HWACCEL\fP"
.br
.ti -1c
.RI "#define \fBPIX_FMT_PLANAR\fP   \fBAV_PIX_FMT_FLAG_PLANAR\fP"
.br
.ti -1c
.RI "#define \fBPIX_FMT_RGB\fP   \fBAV_PIX_FMT_FLAG_RGB\fP"
.br
.ti -1c
.RI "#define \fBPIX_FMT_PSEUDOPAL\fP   \fBAV_PIX_FMT_FLAG_PSEUDOPAL\fP"
.br
.ti -1c
.RI "#define \fBPIX_FMT_ALPHA\fP   \fBAV_PIX_FMT_FLAG_ALPHA\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBAVComponentDescriptor\fP \fBAVComponentDescriptor\fP"
.br
.ti -1c
.RI "typedef struct \fBAVPixFmtDescriptor\fP \fBAVPixFmtDescriptor\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBvoid\fP \fBav_read_image_line\fP (\fBuint16_t\fP *dst, \fBconst\fP \fBuint8_t\fP *\fBdata\fP[4], \fBconst\fP \fBint\fP \fBlinesize\fP[4], \fBconst\fP \fBAVPixFmtDescriptor\fP *\fBdesc\fP, \fBint\fP x, \fBint\fP y, \fBint\fP \fBc\fP, \fBint\fP w, \fBint\fP read_pal_component)"
.br
.ti -1c
.RI "\fBvoid\fP \fBav_write_image_line\fP (\fBconst\fP \fBuint16_t\fP *src, \fBuint8_t\fP *\fBdata\fP[4], \fBconst\fP \fBint\fP \fBlinesize\fP[4], \fBconst\fP \fBAVPixFmtDescriptor\fP *\fBdesc\fP, \fBint\fP x, \fBint\fP y, \fBint\fP \fBc\fP, \fBint\fP w)"
.br
.ti -1c
.RI "enum \fBAVPixelFormat\fP \fBav_get_pix_fmt\fP (\fBconst\fP char *\fBname\fP)"
.br
.ti -1c
.RI "\fBconst\fP char * \fBav_get_pix_fmt_name\fP (enum \fBAVPixelFormat\fP pix_fmt)"
.br
.ti -1c
.RI "char * \fBav_get_pix_fmt_string\fP (char *\fBbuf\fP, \fBint\fP buf_size, enum \fBAVPixelFormat\fP pix_fmt)"
.br
.ti -1c
.RI "\fBint\fP \fBav_get_bits_per_pixel\fP (\fBconst\fP \fBAVPixFmtDescriptor\fP *pixdesc)"
.br
.ti -1c
.RI "\fBint\fP \fBav_get_padded_bits_per_pixel\fP (\fBconst\fP \fBAVPixFmtDescriptor\fP *pixdesc)"
.br
.ti -1c
.RI "\fBconst\fP \fBAVPixFmtDescriptor\fP * \fBav_pix_fmt_desc_get\fP (enum \fBAVPixelFormat\fP pix_fmt)"
.br
.ti -1c
.RI "\fBconst\fP \fBAVPixFmtDescriptor\fP * \fBav_pix_fmt_desc_next\fP (\fBconst\fP \fBAVPixFmtDescriptor\fP *prev)"
.br
.ti -1c
.RI "enum \fBAVPixelFormat\fP \fBav_pix_fmt_desc_get_id\fP (\fBconst\fP \fBAVPixFmtDescriptor\fP *\fBdesc\fP)"
.br
.ti -1c
.RI "\fBint\fP \fBav_pix_fmt_get_chroma_sub_sample\fP (enum \fBAVPixelFormat\fP pix_fmt, \fBint\fP *h_shift, \fBint\fP *v_shift)"
.br
.ti -1c
.RI "\fBint\fP \fBav_pix_fmt_count_planes\fP (enum \fBAVPixelFormat\fP pix_fmt)"
.br
.ti -1c
.RI "\fBvoid\fP \fBff_check_pixfmt_descriptors\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "enum \fBAVPixelFormat\fP \fBav_pix_fmt_swap_endianness\fP (enum \fBAVPixelFormat\fP pix_fmt)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBattribute_deprecated\fP \fBconst\fP \fBAVPixFmtDescriptor\fP \fBav_pix_fmt_descriptors\fP []"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define AV_PIX_FMT_FLAG_ALPHA   (1 << 7)"
The pixel format has an alpha channel\&. 
.PP
Definition at line 124 of file pixdesc\&.h\&.
.SS "#define AV_PIX_FMT_FLAG_BE   (1 << 0)"
Pixel format is big-endian\&. 
.PP
Definition at line 94 of file pixdesc\&.h\&.
.SS "#define AV_PIX_FMT_FLAG_BITSTREAM   (1 << 2)"
All values of a component are bit-wise packed end to end\&. 
.PP
Definition at line 102 of file pixdesc\&.h\&.
.SS "#define AV_PIX_FMT_FLAG_HWACCEL   (1 << 3)"
Pixel format is an HW accelerated format\&. 
.PP
Definition at line 106 of file pixdesc\&.h\&.
.SS "#define AV_PIX_FMT_FLAG_PAL   (1 << 1)"
Pixel format has a palette in data[1], values are indexes in this palette\&. 
.PP
Definition at line 98 of file pixdesc\&.h\&.
.SS "#define AV_PIX_FMT_FLAG_PLANAR   (1 << 4)"
At least one pixel component is not in the first data plane\&. 
.PP
Definition at line 110 of file pixdesc\&.h\&.
.SS "#define AV_PIX_FMT_FLAG_PSEUDOPAL   (1 << 6)"
The pixel format is 'pseudo-paletted'\&. This means that FFmpeg treats it as paletted internally, but the palette is generated by the decoder and is not stored in the file\&. 
.PP
Definition at line 120 of file pixdesc\&.h\&.
.SS "#define AV_PIX_FMT_FLAG_RGB   (1 << 5)"
The pixel format contains RGB-like data (as opposed to YUV/grayscale)\&. 
.PP
Definition at line 114 of file pixdesc\&.h\&.
.SS "#define PIX_FMT_ALPHA   \fBAV_PIX_FMT_FLAG_ALPHA\fP"

.PP
Definition at line 137 of file pixdesc\&.h\&.
.SS "#define PIX_FMT_BE   \fBAV_PIX_FMT_FLAG_BE\fP"

.PP
\fBDeprecated\fP
.RS 4
use the AV_PIX_FMT_FLAG_* flags 
.RE
.PP

.PP
Definition at line 130 of file pixdesc\&.h\&.
.SS "#define PIX_FMT_BITSTREAM   \fBAV_PIX_FMT_FLAG_BITSTREAM\fP"

.PP
Definition at line 132 of file pixdesc\&.h\&.
.SS "#define PIX_FMT_HWACCEL   \fBAV_PIX_FMT_FLAG_HWACCEL\fP"

.PP
Definition at line 133 of file pixdesc\&.h\&.
.SS "#define PIX_FMT_PAL   \fBAV_PIX_FMT_FLAG_PAL\fP"

.PP
Definition at line 131 of file pixdesc\&.h\&.
.SS "#define PIX_FMT_PLANAR   \fBAV_PIX_FMT_FLAG_PLANAR\fP"

.PP
Definition at line 134 of file pixdesc\&.h\&.
.SS "#define PIX_FMT_PSEUDOPAL   \fBAV_PIX_FMT_FLAG_PSEUDOPAL\fP"

.PP
Definition at line 136 of file pixdesc\&.h\&.
.SS "#define PIX_FMT_RGB   \fBAV_PIX_FMT_FLAG_RGB\fP"

.PP
Definition at line 135 of file pixdesc\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBAVComponentDescriptor\fP \fBAVComponentDescriptor\fP"

.SS "typedef struct \fBAVPixFmtDescriptor\fP \fBAVPixFmtDescriptor\fP"
Descriptor that unambiguously describes how the bits of a pixel are stored in the up to 4 data planes of an image\&. It also stores the subsampling factors and number of components\&.
.PP
\fBNote:\fP
.RS 4
This is separate of the colorspace (RGB, YCbCr, YPbPr, JPEG-style YUV and all the YUV variants) \fBAVPixFmtDescriptor\fP just stores how values are stored not what these values represent\&. 
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "\fBint\fP av_get_bits_per_pixel (\fBconst\fP \fBAVPixFmtDescriptor\fP * pixdesc)"
Return the number of bits per pixel used by the pixel format described by pixdesc\&. Note that this is not the same as the number of bits per sample\&.
.PP
The returned number of bits refers to the number of bits actually used for storing the pixel information, that is padding bits are not counted\&. 
.SS "\fBint\fP av_get_padded_bits_per_pixel (\fBconst\fP \fBAVPixFmtDescriptor\fP * pixdesc)"
Return the number of bits per pixel for the pixel format described by pixdesc, including any padding or unused bits\&. 
.SS "enum \fBAVPixelFormat\fP av_get_pix_fmt (\fBconst\fP char * name)"
Return the pixel format corresponding to name\&.
.PP
If there is no pixel format with name name, then looks for a pixel format with the name corresponding to the native endian format of name\&. For example in a little-endian system, first looks for 'gray16', then for 'gray16le'\&.
.PP
Finally if no pixel format has been found, returns AV_PIX_FMT_NONE\&. 
.SS "\fBconst\fP char* av_get_pix_fmt_name (enum \fBAVPixelFormat\fP pix_fmt)"
Return the short name for a pixel format, NULL in case pix_fmt is unknown\&.
.PP
\fBSee also:\fP
.RS 4
\fBav_get_pix_fmt()\fP, \fBav_get_pix_fmt_string()\fP 
.RE
.PP

.SS "char* av_get_pix_fmt_string (char * buf, \fBint\fP buf_size, enum \fBAVPixelFormat\fP pix_fmt)"
Print in buf the string corresponding to the pixel format with number pix_fmt, or a header if pix_fmt is negative\&.
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP the buffer where to write the string 
.br
\fIbuf_size\fP the size of buf 
.br
\fIpix_fmt\fP the number of the pixel format to print the corresponding info string, or a negative value to print the corresponding header\&. 
.RE
.PP

.SS "\fBint\fP av_pix_fmt_count_planes (enum \fBAVPixelFormat\fP pix_fmt)"

.PP
\fBReturns:\fP
.RS 4
number of planes in pix_fmt, a negative AVERROR if pix_fmt is not a valid pixel format\&. 
.RE
.PP

.SS "\fBconst\fP \fBAVPixFmtDescriptor\fP* av_pix_fmt_desc_get (enum \fBAVPixelFormat\fP pix_fmt)"

.PP
\fBReturns:\fP
.RS 4
a pixel format descriptor for provided pixel format or NULL if this pixel format is unknown\&. 
.RE
.PP

.SS "enum \fBAVPixelFormat\fP av_pix_fmt_desc_get_id (\fBconst\fP \fBAVPixFmtDescriptor\fP * desc)"

.PP
\fBReturns:\fP
.RS 4
an AVPixelFormat id described by desc, or AV_PIX_FMT_NONE if desc is not a valid pointer to a pixel format descriptor\&. 
.RE
.PP

.SS "\fBconst\fP \fBAVPixFmtDescriptor\fP* av_pix_fmt_desc_next (\fBconst\fP \fBAVPixFmtDescriptor\fP * prev)"
Iterate over all pixel format descriptors known to libavutil\&.
.PP
\fBParameters:\fP
.RS 4
\fIprev\fP previous descriptor\&. NULL to get the first descriptor\&.
.RE
.PP
\fBReturns:\fP
.RS 4
next descriptor or NULL after the last descriptor 
.RE
.PP

.SS "\fBint\fP av_pix_fmt_get_chroma_sub_sample (enum \fBAVPixelFormat\fP pix_fmt, \fBint\fP * h_shift, \fBint\fP * v_shift)"
Utility function to access log2_chroma_w log2_chroma_h from the pixel format \fBAVPixFmtDescriptor\fP\&.
.PP
See \fBavcodec_get_chroma_sub_sample()\fP for a function that asserts a valid pixel format instead of returning an error code\&. Its recommanded that you use avcodec_get_chroma_sub_sample unless you do check the return code!
.PP
\fBParameters:\fP
.RS 4
\fIpix_fmt\fP the pixel format 
.br
\fIh_shift\fP store log2_chroma_w 
.br
\fIv_shift\fP store log2_chroma_h
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, \fBAVERROR(ENOSYS)\fP on invalid or unknown pixel format 
.RE
.PP

.SS "enum \fBAVPixelFormat\fP av_pix_fmt_swap_endianness (enum \fBAVPixelFormat\fP pix_fmt)"
Utility function to swap the endianness of a pixel format\&.
.PP
\fBParameters:\fP
.RS 4
\fIpix_fmt\fP the pixel format
.RE
.PP
\fBReturns:\fP
.RS 4
pixel format with swapped endianness if it exists, otherwise AV_PIX_FMT_NONE 
.RE
.PP

.SS "\fBvoid\fP av_read_image_line (\fBuint16_t\fP * dst, \fBconst\fP \fBuint8_t\fP * data[4], \fBconst\fP \fBint\fP linesize[4], \fBconst\fP \fBAVPixFmtDescriptor\fP * desc, \fBint\fP x, \fBint\fP y, \fBint\fP c, \fBint\fP w, \fBint\fP read_pal_component)"
Read a line from an image, and write the values of the pixel format component c to dst\&.
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP the array containing the pointers to the planes of the image 
.br
\fIlinesize\fP the array containing the linesizes of the image 
.br
\fIdesc\fP the pixel format descriptor for the image 
.br
\fIx\fP the horizontal coordinate of the first pixel to read 
.br
\fIy\fP the vertical coordinate of the first pixel to read 
.br
\fIw\fP the width of the line to read, that is the number of values to write to dst 
.br
\fIread_pal_component\fP if not zero and the format is a paletted format writes the values corresponding to the palette component c in data[1] to dst, rather than the palette indexes in data[0]\&. The behavior is undefined if the format is not paletted\&. 
.RE
.PP

.SS "\fBvoid\fP av_write_image_line (\fBconst\fP \fBuint16_t\fP * src, \fBuint8_t\fP * data[4], \fBconst\fP \fBint\fP linesize[4], \fBconst\fP \fBAVPixFmtDescriptor\fP * desc, \fBint\fP x, \fBint\fP y, \fBint\fP c, \fBint\fP w)"
Write the values from src to the pixel format component c of an image line\&.
.PP
\fBParameters:\fP
.RS 4
\fIsrc\fP array containing the values to write 
.br
\fIdata\fP the array containing the pointers to the planes of the image to write into\&. It is supposed to be zeroed\&. 
.br
\fIlinesize\fP the array containing the linesizes of the image 
.br
\fIdesc\fP the pixel format descriptor for the image 
.br
\fIx\fP the horizontal coordinate of the first pixel to write 
.br
\fIy\fP the vertical coordinate of the first pixel to write 
.br
\fIw\fP the width of the line to write, that is the number of values to write to the image line 
.RE
.PP

.SS "\fBvoid\fP ff_check_pixfmt_descriptors (\fBvoid\fP)"

.SH "Variable Documentation"
.PP 
.SS "\fBattribute_deprecated\fP \fBconst\fP \fBAVPixFmtDescriptor\fP av_pix_fmt_descriptors[]"
The array of all the pixel format descriptors\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for Audacity from the source code\&.
