.TH "AVInputFormat" 3 "Thu Apr 28 2016" "Audacity" \" -*- nroff -*-
.ad l
.nh
.SH NAME
AVInputFormat \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <avformat\&.h>\fP
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBconst\fP char * \fBname\fP"
.br
.ti -1c
.RI "\fBconst\fP char * \fBlong_name\fP"
.br
.ti -1c
.RI "\fBint\fP \fBflags\fP"
.br
.ti -1c
.RI "\fBconst\fP char * \fBextensions\fP"
.br
.ti -1c
.RI "\fBconst\fP struct AVCodecTag *\fBconst\fP * \fBcodec_tag\fP"
.br
.ti -1c
.RI "\fBconst\fP \fBAVClass\fP * \fBpriv_class\fP"
.br
.RI "\fI\fBAVClass\fP for the private context\&. \fP"
.ti -1c
.RI "struct \fBAVInputFormat\fP * \fBnext\fP"
.br
.ti -1c
.RI "\fBint\fP \fBraw_codec_id\fP"
.br
.ti -1c
.RI "\fBint\fP \fBpriv_data_size\fP"
.br
.ti -1c
.RI "\fBint\fP(* \fBread_probe\fP )(\fBAVProbeData\fP *)"
.br
.ti -1c
.RI "\fBint\fP(* \fBread_header\fP )(struct \fBAVFormatContext\fP *)"
.br
.ti -1c
.RI "\fBint\fP(* \fBread_packet\fP )(struct \fBAVFormatContext\fP *, \fBAVPacket\fP *pkt)"
.br
.ti -1c
.RI "\fBint\fP(* \fBread_close\fP )(struct \fBAVFormatContext\fP *)"
.br
.ti -1c
.RI "\fBint\fP(* \fBread_seek\fP )(struct \fBAVFormatContext\fP *, \fBint\fP stream_index, \fBint64_t\fP timestamp, \fBint\fP \fBflags\fP)"
.br
.ti -1c
.RI "\fBint64_t\fP(* \fBread_timestamp\fP )(struct \fBAVFormatContext\fP *\fBs\fP, \fBint\fP stream_index, \fBint64_t\fP *pos, \fBint64_t\fP pos_limit)"
.br
.ti -1c
.RI "\fBint\fP(* \fBread_play\fP )(struct \fBAVFormatContext\fP *)"
.br
.ti -1c
.RI "\fBint\fP(* \fBread_pause\fP )(struct \fBAVFormatContext\fP *)"
.br
.ti -1c
.RI "\fBint\fP(* \fBread_seek2\fP )(struct \fBAVFormatContext\fP *\fBs\fP, \fBint\fP stream_index, \fBint64_t\fP min_ts, \fBint64_t\fP ts, \fBint64_t\fP max_ts, \fBint\fP \fBflags\fP)"
.br
.ti -1c
.RI "\fBint\fP(* \fBget_device_list\fP )(struct \fBAVFormatContext\fP *\fBs\fP, struct AVDeviceInfoList *device_list)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 551 of file avformat\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBconst\fP struct AVCodecTag* \fBconst\fP* AVInputFormat::codec_tag"

.PP
Definition at line 579 of file avformat\&.h\&.
.SS "\fBconst\fP char* AVInputFormat::extensions"
If extensions are defined, then no probe is done\&. You should usually not use extension format guessing because it is not reliable enough 
.PP
Definition at line 577 of file avformat\&.h\&.
.SS "\fBint\fP AVInputFormat::flags"
Can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_SHOW_IDS, AVFMT_GENERIC_INDEX, AVFMT_TS_DISCONT, AVFMT_NOBINSEARCH, AVFMT_NOGENSEARCH, AVFMT_NO_BYTE_SEEK, AVFMT_SEEK_TO_PTS\&. 
.PP
Definition at line 570 of file avformat\&.h\&.
.SS "\fBint\fP(* AVInputFormat::get_device_list) (struct \fBAVFormatContext\fP *\fBs\fP, struct AVDeviceInfoList *device_list)"
Returns device list with it properties\&. 
.PP
\fBSee also:\fP
.RS 4
avdevice_list_devices() \fBfor\fP more details\&. 
.RE
.PP

.PP
Definition at line 675 of file avformat\&.h\&.
.SS "\fBconst\fP char* AVInputFormat::long_name"
Descriptive name for the format, meant to be more human-readable than name\&. You should use the NULL_IF_CONFIG_SMALL() macro to define it\&. 
.PP
Definition at line 563 of file avformat\&.h\&.
.SS "\fBconst\fP char* AVInputFormat::name"
A comma separated list of short names for the format\&. New names may be appended with a minor bump\&. 
.PP
Definition at line 556 of file avformat\&.h\&.
.SS "struct \fBAVInputFormat\fP* AVInputFormat::next"

.PP
Definition at line 590 of file avformat\&.h\&.
.SS "\fBconst\fP \fBAVClass\fP* AVInputFormat::priv_class"

.PP
\fBAVClass\fP for the private context\&. 
.PP
Definition at line 581 of file avformat\&.h\&.
.SS "\fBint\fP AVInputFormat::priv_data_size"
Size of private data so that it can be allocated in the wrapper\&. 
.PP
Definition at line 600 of file avformat\&.h\&.
.SS "\fBint\fP AVInputFormat::raw_codec_id"
Raw demuxers store their codec ID here\&. 
.PP
Definition at line 595 of file avformat\&.h\&.
.SS "\fBint\fP(* AVInputFormat::read_close) (struct \fBAVFormatContext\fP *)"
Close the stream\&. The \fBAVFormatContext\fP and AVStreams are not freed by this function 
.PP
Definition at line 631 of file avformat\&.h\&.
.SS "\fBint\fP(* AVInputFormat::read_header) (struct \fBAVFormatContext\fP *)"
Read the format header and initialize the \fBAVFormatContext\fP structure\&. Return 0 if OK\&. Only used in raw format right now\&. 'avformat_new_stream' should be called to create new streams\&. 
.PP
Definition at line 614 of file avformat\&.h\&.
.SS "\fBint\fP(* AVInputFormat::read_packet) (struct \fBAVFormatContext\fP *, \fBAVPacket\fP *pkt)"
Read one packet and put it in 'pkt'\&. pts and flags are also set\&. 'avformat_new_stream' can be called only if the flag AVFMTCTX_NOHEADER is used and only in the calling thread (not in a background thread)\&. 
.PP
\fBReturns:\fP
.RS 4
0 on success, < 0 on error\&. When returning an error, pkt must not have been allocated or must be freed before returning 
.RE
.PP

.PP
Definition at line 625 of file avformat\&.h\&.
.SS "\fBint\fP(* AVInputFormat::read_pause) (struct \fBAVFormatContext\fP *)"
Pause playing - only meaningful if using a network-based format (RTSP)\&. 
.PP
Definition at line 661 of file avformat\&.h\&.
.SS "\fBint\fP(* AVInputFormat::read_play) (struct \fBAVFormatContext\fP *)"
Start/resume playing - only meaningful if using a network-based format (RTSP)\&. 
.PP
Definition at line 655 of file avformat\&.h\&.
.SS "\fBint\fP(* AVInputFormat::read_probe) (\fBAVProbeData\fP *)"
Tell if a given file has a chance of being parsed as this format\&. The buffer provided is guaranteed to be AVPROBE_PADDING_SIZE bytes big so you do not have to check for that unless you need more\&. 
.PP
Definition at line 607 of file avformat\&.h\&.
.SS "\fBint\fP(* AVInputFormat::read_seek) (struct \fBAVFormatContext\fP *, \fBint\fP stream_index, \fBint64_t\fP timestamp, \fBint\fP \fBflags\fP)"
Seek to a given timestamp relative to the frames in stream component stream_index\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstream_index\fP Must not be -1\&. 
.br
\fIflags\fP Selects which direction should be preferred if no exact match is available\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
>= 0 on success (but not necessarily the new offset) 
.RE
.PP

.PP
Definition at line 641 of file avformat\&.h\&.
.SS "\fBint\fP(* AVInputFormat::read_seek2) (struct \fBAVFormatContext\fP *\fBs\fP, \fBint\fP stream_index, \fBint64_t\fP min_ts, \fBint64_t\fP ts, \fBint64_t\fP max_ts, \fBint\fP \fBflags\fP)"
Seek to timestamp ts\&. Seeking will be done so that the point from which all active streams can be presented successfully will be closest to ts and within min/max_ts\&. Active streams are all streams that have \fBAVStream\&.discard\fP < AVDISCARD_ALL\&. 
.PP
Definition at line 669 of file avformat\&.h\&.
.SS "\fBint64_t\fP(* AVInputFormat::read_timestamp) (struct \fBAVFormatContext\fP *\fBs\fP, \fBint\fP stream_index, \fBint64_t\fP *pos, \fBint64_t\fP pos_limit)"
Get the next timestamp in stream[stream_index]\&.time_base units\&. 
.PP
\fBReturns:\fP
.RS 4
the timestamp or AV_NOPTS_VALUE if an error occurred 
.RE
.PP

.PP
Definition at line 648 of file avformat\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Audacity from the source code\&.
